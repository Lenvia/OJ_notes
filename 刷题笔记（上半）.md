[TOC]

# 暴力

## 枚举

#### 反序数

```
int Reverse (int x){
		int revx =0;
		while(x!=0){
			revx *= 10;
			revx += x%10;
			x /=10;
		}
		return revx;
}
```



#### 百鸡问题

http://t.cn/E9ldhru

```
#include <iostream>
using namespace std;


int main(){
    int n;
    cin>>n;
    for(int x=0;x<= n/5; x++){
        for(int y=0; y<=100-x ;y++){
                    if(5*x+3*y+(100-x-y)/3 <=n)
                        printf("%d %d %d\n",x,y,100-x-y);
        }
    }

    return 0;
}
```

这里本来我用的无脑三层循环，这题不好处理的是z的价格是1/3，我一开始以为需要用到double，但是好像直接z/3不影响

参考评论区解法，将y变量和z变量分别用前面的变量表示。同时，我缩小了x的上限为n/5



#### Old Bill

http://t.cn/E9jqijR

```
#include <iostream>
using namespace std;

int main(){
    int N;
    int a,b,c,d,e;
    while(cin>>N>>b>>c>>d){
        int sum,flag=0;

        for(int a=9;a>=1;a--){
            for(int e=9;e>=0;e--){
                sum = 10000*a+1000*b+100*c+10*d+e;
                if(sum%N==0){
                    printf("%d %d %d\n",a,e,sum/N);
                    flag=1;
                    break;
                }
            }
            if(flag)
                break;
        }
        if(flag==0)
            cout<<0<<endl;
    }
    return 0;
    
}
```

注意点：

​	五位价格，说明a最小为1而不是0

​	求最大火鸡单价，因为给定了N，所以从最大火鸡总价开始，即a和e从9开始减，只要遇到合适的直接输出并break

​	如果无解的话需要输出0，这个需要添加flag判断



## 模拟

### 图形排版

#### 叠框

P12

题目是输出一圈一圈交错的框，用平凡输出逻辑比较混乱。

答案用的是二维数组，先根据规律赋值，以每个圈的左上角和右下角坐标表示整个圈，并求出每一圈的长度。

等赋值结束后直接遍历数组输出就行了。

<font color=blue>即并不是在输出时使用得到的规律，而用另一种更容易的方法完成排版</font>

<font color=red>当图形对位置要求比较灵活时，可以考虑二维数组</font>





#### Repeater

http://t.cn/E9jcaVb

```
/**
参考高赞的回答，适当的加了一些解释
题解思路:通过dfs找到每一个子图的左上角的起始点，然后在每一个元图像上面作画。
*/
#include <iostream>
#include <math.h>
 
using namespace std;
 
char str[6][6];
char map[3001][3001];
int n;
 
int IntPow(int x,int n){//自定义指数运算
    int ans=1;
    for(int i=1;i<=n;i++)
        ans*=x;
    return ans;
}
 
//在以(x,y)为左上角顶点的区域中填充级别为level的块
void dfs(int x,int y,int level){//x,y为子图形的左上角起始点
    if(level==1){//搜索到了基础图形级别，直接把输入的二维数组复制过去
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                map[x+i][y+j]=str[i][j];
            }
        }
        return;
    }
    int Size = IntPow(n,level-1);
    //每次调用dfs(...,...,level-1)只能填充一块，所以要用二层循环，把所有相同规模的块填充，组成一个大块
    for(int i=0;i<n;i++){//搜索每一个位置对应的缩放的位置
        for(int j=0;j<n;j++){
            //这一句很有意义，输入str里该位置不为空，则在投影后对应区域(以(x+i*Size,y+j*Size)为左上角顶点的区域）需要填充本单位
            if(str[i][j]!=' ')
                dfs(x+i*Size,y+j*Size,level-1);//一共两层循环，对于每组i,j，全执行完毕后是把本单位扩大投影到比本单位高一级的单位
        }
    }
}

int main()
{
//    int m;
    while(cin >> n){
        if(n==0)break;
        getchar();
        for (int i = 0; i < n; i++){
            cin.getline(str[i],6);
        }
        int m;//level
        cin >> m;
        int size = (int)pow(n*1.0, m);//size=n^m
        for (int i = 0; i<size; i++){
            for (int j = 0; j<size; j++)
                map[i][j] = ' ';
            map[i][size] = '\0';
        }
        dfs(0,0,m);
        for(int i=0;i<size;i++){
            cout<<map[i]<<endl;
        }
    }
    return 0;
}
 

```



#### Hellow World for U

http://t.cn/E9jizni

题目大概三个步骤

1.划分每个数组的长度

2.按长度赋值（可以省略/优化）

3.在二维数组中填充（记得在每次测试前先初始化一下）

```
#include <iostream>
#include <cstring>

#include <stdio.h>

using namespace std;

int num1,num2,num3,sum;//各数组的长度

void curve(int sum){
    for(num2=3; num2<=sum; num2++){
        num1=num3=(int)(sum+2-num2)/2;
//        cout<<"*"<<num1<<"*"<<num2<<"*"<<num3<<"*"<<endl;
        if(num1+num2+num3-2==sum)
            if(num1<=num2)
                break;
    }
}

int main() {
    
    char n1[27];
    char n2[27];
    char n3[27];
    char str[80];
    char map[27][27];
    
    
    while(gets(str)&& strlen(str)>0){
        
        //每次测试都要初始化一下
        for(int i=0;i<27;i++)
            for(int j=0;j<27;j++)
                map[i][j]=' ';
        
        sum = strlen(str);
    //    cout<<sum<<endl;
        //划分长度
        curve(sum);
    //    cout<<num1<<" "<<num2<<" "<<num3<<endl;
        
        //赋值
        for(int i=0;i<num1;i++)
            n1[i]=str[i];
        for(int i=0;i<num2;i++)
            n2[i]=str[num1+i-1];
        for(int i=0;i<num3;i++)
            n3[i]=str[num1+num2+i-2];
        
        //显示各数组
    //    for(int i=0;i<num1;i++)
    //        cout<<n1[i]<<" ";
    //    cout<<endl;
    //    for(int i=0;i<num2;i++)
    //        cout<<n2[i]<<" ";
    //    cout<<endl;
    //    for(int i=0;i<num3;i++)
    //        cout<<n3[i]<<" ";
    //    cout<<endl;
        
        //构造U型图
        for(int i=0;i<num1;i++)
            map[i][0]=n1[i];
        for(int j=0;j<num2;j++)
            map[num1-1][j]=n2[j];
        for(int i=num3-1;i>=0;i--)
            map[i][num2-1]=n3[num3-i-1];

    //    cout<<endl;
    //    cout<<endl;
        for(int i=0;i<num1;i++){
            for(int j=0;j<num2;j++)
                cout<<map[i][j];
            cout<<endl;
        }
    }
    
    return 0;
}

```

优化后代码：

```
//优化版（运行时间：4ms）
#include <iostream>
#include <cstring>
#include <stdio.h>

using namespace std;

int main() {
    char n3[27];
    char str[80];
    char map[27][27];
    int num1,num2,num3,sum;
    
    while(gets(str)&& strlen(str)>0){
        //每次测试都要初始化一下
        for(int i=0;i<27;i++)
            for(int j=0;j<27;j++)
                map[i][j]=' ';
        sum = strlen(str);
        //划分长度
        for(num2=3; num2<=sum; num2++){
            num1=num3=(int)(sum+2-num2)/2;
            if(num1+num2+num3-2==sum)
                if(num1<=num2)
                    break;
        }
        
        //赋值（因为n3要倒着输出为了方便这里先赋值）
        for(int i=0;i<num3;i++)
            n3[i]=str[num1+num2+i-2];
        
        //构造U型图
        for(int i=0;i<num1;i++)
            map[i][0]=str[i];
        for(int j=0;j<num2;j++)
            map[num1-1][j]=str[num1+j-1];
        for(int i=num3-1;i>=0;i--)
            map[i][num2-1]=n3[num3-i-1];
        //输出
        for(int i=0;i<num1;i++){
            for(int j=0;j<num2;j++)
                cout<<map[i][j];
            cout<<endl;
        }
    }
    return 0;
}
```



### 日期问题

预处理 很关键。

#### 日期累加

http://t.cn/E9Yw0Cr

这一题综合了 **今年的第几天？**http://t.cn/E9jXK5A 和**打印日期**http://t.cn/E9YP2a8 

```
#include <iostream>
#include <cstdio>
using namespace std;
 
int daytab[2][13]={
    {0,31,28,31,30,31,30,31,31,30,31,30,31},
    {0,31,29,31,30,31,30,31,31,30,31,30,31}
};

int daynum[2]={365,366};

int isLeapYear(int year){
    if((year%4==0 && year%100!=0) || year%400==0)
        return 1;
    else return 0;
}

int main(){
    int n;
    cin>>n;
    while(n--){
        int year,month,day,number;
        int rmonth=0;//结果月份
        int rday=0;//结果日期
        cin>>year>>month>>day>>number;
        int row=isLeapYear(year);
        for(int j=0; j<month; j++){
            number+=daytab[row][j];
        }
        number+=day;
        //到现在目标日期是相对于当前year的第number天
        //先确定目标年份
        while(number>daynum[row]){
            number -=daynum[row];
            year++;
            row = isLeapYear(year);
        }
        //现在就变成了一年内给定天数打印日期
        for(;rmonth<=12;rmonth++){
            if(number-daytab[row][rmonth]>0){
                number -=daytab[row][rmonth];
                continue;
            }
            rday=number;
            break;
        }
        printf("%04d-%02d-%02d\n",year,rmonth,rday);
    }
}
```



### 其他模拟

#### 手机键盘

http://t.cn/E9ulcIc

我的解法是直接switch各种情况，赋值当前字母所在组currentGroup和按压次数press

之后如果currentGroup和上一字母所在组lastGroup相等，则再+2。

看了论坛里大佬的解法：

```
#include<iostream>
#include<string>
using namespace std;
int main()
{
    int key[26] = {1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,1,2,3,1,2,3,4};
    string str;
    while(cin>>str)
    {
        int count = key[str[0]-'a'];
        for(int i=1;i<str.size();++i)
        {
            count += key[str[i]-'a'];
            if(key[str[i]-'a']-key[str[i-1]-'a']==str[i]-str[i-1])//判断是否在同一个按键上
                count+=2;
        }
        cout<<count<<endl;
    }
}
```

**用key顺序记录26个字母按键次数，**
**然后判断两个字母是否在同一个按键上，如果在同一个按键上，那么下标差（字母间距）就等于按键次数差。**



#### <font color=purple>路径打印</font>

http://t.cn/E9dvHs4

这题需要考虑的地方很多！！！

我是仿照评论区大神的解法写的

```
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;

vector<string> vstr, vs;  //vstr存放原始输入，vs存放去掉反斜杠的输入
vector<vector<string>> v;  //v存放vs排序后的集合

int main(){
    int n;
    string str;
    while(cin>>n && n){
        //初始化
        vstr.clear();

        for(int i=0; i<n; i++){
            cin>>str;
            if(str[str.length()-1]!='\\') str+='\\';
            vstr.push_back(str);
        }
        sort(vstr.begin(), vstr.end());//排序

        v.clear();
        for(int i=0; i<vstr.size(); i++){
            vs.clear();  //注意每次都要初始化vs
            int start = 0, end = 0;
            while(vstr[i].find('\\', start)!= string::npos){  //查找某一给定位置后的子串的位置
                end = vstr[i].find('\\', start);  //这里别漏了起始位置啊啊啊
                vs.push_back(vstr[i].substr(start,end-start));  //提取被反斜杠隔开的每个子串
                start = end+1;  //注意要更新start
            }
            v.push_back(vs);
        }

        for(int i=0; i<n; i++){
            if(i==0){
                for(int j=0; j<v[i].size(); j++){
                    for(int k=0; k<j; k++)
                        cout<<"  ";
                    cout<<v[i][j]<<endl;
                }
            }
            else{
                int j=0;
                while(j<v[i].size() && v[i][j]==v[i-1][j]) { j++;}  //跳过与前一串相同的字符！！！而不是根串
                for(; j<v[i].size(); j++){
                    for(int k=0; k<j; k++)
                        cout<<"  ";
                    cout<<v[i][j]<<endl;
                }
            }
        }
        cout<<endl;
    }
    return 0;
}
```



#### <font color = blue>坠落的蚂蚁</font>

思想很不错，值得细品。

待完善。

https://www.nowcoder.com/questionTerminal/fdd6698014c340178a8b1f28ea5fadf8?toCommentId=5234233

```
#include <iostream>
#include<algorithm>
using namespace std;

int main(){
    int N;
    while(cin>>N){
        //下面呢9个变量的解释分别是
        //输入位置、输入方向、蚂蚁A的位置、排序后左边最接近foucs的下标、排序后右边最接近focus的下标
        //向右运动蚂蚁总数、向左运动蚂蚁总数、排序后在左边并且向右运动数量、排序后在右边并且向左运动数量
        int loc,dir,focus,index1,index2,numL,numR,num1,num2;
        //用来存放向右运动和向左运动的所有蚂蚁的位置
        int left[100],right[100];
        for(int i=0;i<100;i++){
            left[i]=0;right[i]=0;//初始化
        }
        numL=0;numR=0;index1=0;index2=0;num1=0;num2=0;//初始化
        while(N--){
            cin>>loc>>dir;
            if(dir==0)
                focus=loc;//找到蚂蚁A的位置
            if(dir==1){//向右运动，放到left里
                left[numL]=loc;
                numL++;
            }
            if(dir==-1){//向左运动，放到right里
                right[numR]=loc;
                numR++;
            }
        }
        sort(left,left+numL);//排序
        sort(right,right+numR);
        
        for(int i=0;i<numL;i++){
           if(left[i]<focus){//找到在focus左边并且向右运动的最接近focus的下标index1
               num1++;
               index1=i;
               continue;
           }
            break;
        }
        for(int i=numR-1;i>=0;i--){//找到在focus右边并且向左运动的最接近focus的下标index2
           if(right[i]>focus){
               num2++;
                index2=i;
                continue;
           }
            break;
        }
       
        if(num1==num2)//不会掉落的条件是 在focus左边向右运动的数量==在focus右边向左运动的数量
            cout<<"Cannot fall!"<<endl;
        if(num1<num2)//这个语言不太好表达，可以自己举个例子，在纸上画一画 排序后的数组元素哪些用不到，哪些用得到
            cout<<right[index2+num1]<<endl;
        if(num1>num2)
            cout<<100-left[index1-num2]<<endl;
        
    }
    return 0;
}

```



# 排序与查找

## 排序

### 成绩排序

http://t.cn/E9d3ysv

```
#include <iostream>
#include <algorithm>
#include <cstdio>

using namespace std;

struct Student{
    int number;
    int score;
};

bool cmp(Student x, Student y){
    if(x.score==y.score)
        return x.number<y.number;
    else return x.score<y.score;
}

Student stu[100];

int main(){
    int N;
    while(cin>>N){
        for(int i=0;i<N;i++)
            cin>>stu[i].number>>stu[i].score;
        
        sort(stu,stu+N,cmp);
        for(int i=0;i<N;i++)
            cout<<stu[i].number<<" "<<stu[i].score<<endl;
    }
    return 0;
}
```

这里需要定义结构体数组，直接使用std里的sort函数。

sort(first, last, comp) 第三个参数为排序方式，可以不填写，不填写默认为升序。

在本题中，comp为我自定义的bool cmp(Studenx, Student y)函数。分数一样时按照学号升序，不一样时按照分数升序。

**排序规则：当比较函数的返回值为true时，表示的是比较函数的一个参数将会排在第二个参数前面。**

进阶：http://t.cn/E9gyHM1



### 奥运排序

http://t.cn/E9gYpyl

这个坑好多啊。

我是直接创建个结构体，记录国家号、金牌数、奖牌数、金牌比例、奖牌比例以及 四个排名和 最终排名、最终方法。

四个排名分别在四次排序 先后赋值。最终使用循环检查结构体，给最终排名赋值。

遇到的坑：

1.并列第几并不影响后面不并列的名次

2.人口数可能为0，这样金牌/奖牌比例可能为 0 或 无穷大

3.金牌为0，人口为0的时候 金牌比例是0而不是无穷大

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#define MAXGOAL 99999
using namespace std;

struct country{
    int id;//国家号
    int gold;//金牌总数
    int medal;//奖牌总数
    int people;//人口数
    double ratioG;//金牌人口比例
    double ratioM;//奖牌人口比例
    int rankG=-1;//按金牌排名的位置
    int rankM=-1;//按奖牌
    int rankGR=-1;//按金牌人口比例
    int rankMR=-1;//按奖牌人口比例
    int finalRank=-1;
    int finalNum=-1;
};
bool cmp0(country c1, country c2){
    return c1.id<c2.id;
}
bool cmp1(country c1, country c2){
    return c1.gold>c2.gold;
}
bool cmp2(country c1, country c2){
    return c1.medal>c2.medal;
}
bool cmp3(country c1, country c2){
    return c1.ratioG>c2.ratioG;
}
bool cmp4(country c1, country c2){
    return c1.ratioM>c2.ratioM;
}

country con[10];//输入的数据
int testId[10];//用于排名的id
country testCon[10];//用于排名的国家

int main(){
    int N,M;
    while(cin>>N){
        cin>>M;
        for(int i=0;i<N;i++){
            cin>>con[i].gold>>con[i].medal>>con[i].people;//输入金牌、奖牌、人口
            con[i].id=i;//国家号
            if(con[i].people==0){//人口数可能为0，这里注意，为0后 同为无穷大默认相等
                //金牌数和奖牌数也可能为0 啊啊啊啊啊啊 
                if(con[i].gold==0)
                    con[i].ratioG=0;
                else 
                    con[i].ratioG=MAXGOAL;
                if(con[i].medal==0)
                    con[i].ratioM=0;
                else 
                    con[i].ratioM=MAXGOAL;
            }
            else{
                con[i].ratioG=(con[i].gold*1.0)/(con[i].people*1.0);
                con[i].ratioM=(con[i].medal*1.0)/(con[i].people*1.0);
            }
        }
        for(int i=0;i<M;i++)
            cin>>testId[i];//输入需要排序的国家号
        for(int i=0;i<M;i++)
            testCon[i]=con[testId[i]];//放到另一个数组里
        //现在是要对testCon里的进行排序
        sort(testCon,testCon+M,cmp1);//按金牌总数排名，赋值rankG
        for(int i=0;i<M;i++){
            if(i==0)
                testCon[i].rankG=1;
            else{
                if(testCon[i].gold==testCon[i-1].gold)
                    testCon[i].rankG=testCon[i-1].rankG;
                else testCon[i].rankG=i+1;//注意，例子，如果出现金牌总数为 100,90,90,80.则排名为1,2,2,4.而不是1,2,2,3
            }
        }
        sort(testCon,testCon+M,cmp2);//按奖牌总数排名，赋值rankM
        for(int i=0;i<M;i++){
            if(i==0)
                testCon[i].rankM=1;
            else{
                if(testCon[i].medal==testCon[i-1].medal)
                    testCon[i].rankM=testCon[i-1].rankM;
                else testCon[i].rankM=i+1;
            }
        }
        sort(testCon,testCon+M,cmp3);//按金牌人口比例排名，赋值rankGR
        for(int i=0;i<M;i++){
            if(i==0)
                testCon[i].rankGR=1;
            else{
                if(testCon[i].ratioG==testCon[i-1].ratioG)
                    testCon[i].rankGR=testCon[i-1].rankGR;
                else testCon[i].rankGR=i+1;
            }
        }
        sort(testCon,testCon+M,cmp4);//按奖牌人口比例排名，并为finalRank赋值默认为rankMR，finkalNum默认为4
        for(int i=0;i<M;i++){
            if(i==0)
                testCon[i].rankMR=1;
            else{
                if(testCon[i].ratioM==testCon[i-1].ratioM)
                    testCon[i].rankMR=testCon[i-1].rankMR;
                else testCon[i].rankMR=i+1;
            }
            testCon[i].finalRank=testCon[i].rankMR;
            testCon[i].finalNum=4;
        }
        sort(testCon,testCon+M,cmp0);//按id排序并输出
        for(int i=0;i<M;i++){
            if(testCon[i].finalRank>=testCon[i].rankGR){
                testCon[i].finalRank=testCon[i].rankGR;
                testCon[i].finalNum=3;
            }
            if(testCon[i].finalRank>=testCon[i].rankM){
                testCon[i].finalRank=testCon[i].rankM;
                testCon[i].finalNum=2;
            }
            if(testCon[i].finalRank>=testCon[i].rankG){
                testCon[i].finalRank=testCon[i].rankG;
                testCon[i].finalNum=1;
            }
        }
        for(int i=0;i<M;i++){
            cout<<testCon[i].finalRank<<":"<<testCon[i].finalNum<<endl;
        }
        cout<<endl;
    }
}
```



## 查找

### 查找（名字就叫查找）

http://t.cn/E9g8aaR

使用的二分查找

**注意：在int middle = (left+right)/2 中，如果left和right非常接近整型最大值的情况，则相加会出现溢出。因此要用代码 int middle = (left + (right-left)) /2 代替。**

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#define MAXN 100
using namespace std;

int a[MAXN];
//二分查找
bool BinarySearch(int n, int target){
    int left=0;
    int right=n-1;
    while(left<=right){
        int middle= (left+right)/2;
        if(a[middle]<target)
            left=middle+1;
        else if(a[middle]>target)
            right=middle-1;
        else return true;
    }
    return false;
}

int main(){
    int n,m;
    while(cin>>n){
        for(int i=0;i<n;i++)
            cin>>a[i];
        sort(a,a+n);
        cin>>m;
        for(int i=0;i<m;i++){
            int target;
            cin>>target;
            if(BinarySearch(n,target))
                cout<<"YES"<<endl;
            else cout<<"NO"<<endl;
        }
    }
    return 0;
}
```



### 找最小数

http://t.cn/E9gekWa

我刚开始很傻逼的想用二维数组，并且用sort给二维数组排序。

后来想到结构体（结构体太香了），对结构体数组排序后直接输出第一个结构体的x和y就行了。

评论区大神直接在输入的时候就开始筛选了

```
if(t.x<min.x || (t.x == min.x&&t.y < min.y))
	min = t;
```

下面是完整的两种代码

```
//#include <iostream>
//#include <cstdio>
//#include <algorithm>
//using namespace std;
//
//struct num{
//    int x;
//    int y;
//};
//
//bool cmp(num p, num q){
//    if(p.x==q.x)
//        return p.y<q.y;
//    else return p.x<q.x;
//}
//
//num a[1000];
//
//int main(){
//    int n;
//    while(cin>>n){
//        for(int i=0;i<n;i++)
//            cin>>a[i].x>>a[i].y;
//        sort(a,a+n,cmp);
//        cout<<a[0].x<<" "<<a[0].y<<endl;
//    }
//    return 0;
//}

//论坛大佬进阶版
//链接：https://www.nowcoder.com/questionTerminal/ba91786c4759403992896d859e87a6cd
//来源：牛客网

#include <stdio.h>
#define INT_MAX 0x7fffffff
struct s{
    int x,y;
};
int main(){
    int n;
    while(~scanf("%d",&n)){
        s min,t;
        min.x=INT_MAX;
        min.y=INT_MAX;
        while(n--){
            scanf("%d %d",&t.x,&t.y);
            if(t.x<min.x || (t.x == min.x&&t.y < min.y))
                min = t;
        }
        printf("%d %d\n",min.x,min.y);
    }
}

```



### 打印极值点下标

（示例有坑，第一行的组数是多余的）水题

http://t.cn/E9ehDw4

```
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;
int a[80];
int index[80];
int main(){
    int k;
    int num=0;
    while(cin>>k){
        //输入数据
        for(int i=0;i<k;i++)
            cin>>a[i];
        //判断开头、结尾、其他；并用新数组存放下标（方便输出格式）
        for(int i=0;i<k;i++){
            if(i==0){
                if(a[i]!=a[i+1]){
                    index[num]=i;
                    num++;
                }
            }
            else if(i==k-1){
                if(a[i]!=a[i-1]){
                    index[num]=i;
                    num++;
                }
            }
            else{
                if((a[i]<a[i-1] && a[i]<a[i+1]) || (a[i]>a[i-1] && a[i]>a[i+1])){
                    index[num]=i;
                    num++;
                }
            }
        }
        sort(index, index+num);  //要么排序，要么上面判断末尾极值点放在最后
        //输出结果
        for(int i=0;i<num;i++){
            if(i==0)
                cout<<index[i];
            else
                cout<<" "<<index[i];
        }

        cout<<endl;
    }
    return 0;
}
```





### 找位置

http://t.cn/E9eh4jY

我借助了string方法里的find(ch,pos)来获取同一个字符的所有位置 

通过 postion = str.find(ch, postion+1)可以获取下一个位置 

代码还有改进的地方，比如舍弃flag数组，检查过的直接更改为符号'*'就行了。[点此查看](https://www.nowcoder.com/profile/748608757/codeBookDetail?submissionId=79842160)不过为啥耗时和内存都增加了？

关于find()的使用 https://www.cnblogs.com/wkfvawl/p/9429128.html

```
#include<cstring>
#include<cstdio>
#include<iostream>
using namespace std;

int flag[100];//指示是否已经被输出过
int out[100];
int main(){
    string str;
    while(cin>>str){
        char ch; int position; int num;//当前字符、位置、数量
        for(int i=0;i<str.length();i++)
            flag[i]=1;
        for(int i=0;i<str.length();i++){
            if(flag[i]){//只检查flag为1的字符
                num=0;//初始化数量
                ch=str[i];//获取当前字符
                position=i;//当前字符的第一个位置一定是它当前的下标（原因在下面）
                while(position!=-1){
                    flag[position]=0;//置flag为0，即将被输出
                    out[num]=position;//将位置存进另一数组
                    num++;
                    position=str.find(ch,position+1);//不断地使用find来获取当前字符的下一个位置
                }
                if(num>1){
                    for(int i=0;i<num;i++){
                        if(i==0)
                            cout<<ch<<":"<<out[i];
                        else
                            cout<<","<<ch<<":"<<out[i];
                    }
                    cout<<endl;
                }
            }
        }
    }
    return 0;
}
```





# 字符串

## 字符串处理

### 统计字符

http://t.cn/Ai8fvq4I

有几个注意点：

1.字符串含有空格要用getline自定义读入

2.find函数的使用

3.或者直接使用自带的count函数  [点此查看](https://www.nowcoder.com/profile/748608757/codeBookDetail?submissionId=79843908)

4.也可以使用数组计数，初始化全为0，遇到一个对应位置+1

```
#include <iostream>
#include <string>
#include <cstdio>
using namespace std;

int main(){
    string chs;
    while(getline(cin,chs,'\n') && chs!="#"){
        string str;
        getline(cin,str,'\n');
        for(int i=0;i<chs.length();i++){
            //也可以直接用自带的count(str.begin(),str.end(),chs[i])来计数
            int pos=str.find(chs[i],0);
            int num=0;
            while(pos!=string::npos){
                num++;
                pos=str.find(chs[i],pos+1);
            }
            cout<<chs[i]<<" "<<num<<endl;
        }
    }
    return 0;
}
```



### <font color=blue>浮点数加法</font>（字符串加法）

http://t.cn/Ai8I4v0j

分别取整数部分和小数部分分别相加。

先对齐，再相加，注意进位。

```
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
using namespace std;

int carry;

string addInt(string s1, string s2){
    //位数对齐
    if(s1.length()<s2.length())
        s1.insert(0,s2.length()-s1.length(),'0');
    if(s2.length()<s1.length())  //这里不能直接写成else！！！！！！！！！
        s2.insert(0,s1.length()-s2.length(),'0');
    int flag=0;//进位
    for(int i=s1.length()-1; i>=0; i--){//减号
        int temp;
        temp=(s1[i]-'0')+(s2[i]-'0')+flag;
        if(temp>=10){
            flag=1;
            temp-=10;
        }
        else flag=0;
        
        s1[i]=temp+'0';
        if(i==0 && flag==1)
            s1.insert(0,1,'1');
    }
    return s1;
}

string addDec(string s1, string s2){
    //位数对齐
    if(s1.length()<s2.length())
        s1.insert(s1.length(),s2.length()-s1.length(),'0');
    if(s2.length()<s1.length())
        s2.insert(s2.length(),s1.length()-s2.length(),'0');
    int flag=0;//进位
    for(int i=s1.length()-1; i>=0; i--){
        int temp;
        temp=(s1[i]-'0')+(s2[i]-'0')+flag;
        if(temp>=10){
            flag=1;
            temp-=10;
        }
        else flag=0;
        
        s1[i]=temp+'0';
        if(i==0 && flag==1)
            carry=1;//小数进位
    }
    return s1;
    
}


int main(){
    string f1,f2,s;
    while(cin>>f1){
        cin>>f2;
        carry=0;
        int pos1,pos2;
        string int0, int1, int2, dec0,dec1,dec2;
        //定位小数点的位置
        pos1=f1.find('.',0);
        pos2=f2.find('.',0);
        //取整数部分
        int1= f1.substr(0,pos1);
        int2= f2.substr(0,pos2);
        //取小数部分
        dec1= f1.substr(pos1+1,f1.length()-pos1+1);
        dec2= f2.substr(pos2+1,f2.length()-pos2+1);
        //整数部分加法
        int0 = addInt(int1,int2);
        //小数部分加法
        dec0 = addDec(dec1,dec2);
        //如果小数部分有进位
        if(carry)
            int0 = addInt(int0,"1");
        //cout<<int0<<endl<<dec0<<endl;
        s=int0+'.'+dec0;
        cout<<s<<endl;
    }
    return 0;
}

```

评论区更简洁的方法

链接：https://www.nowcoder.com/questionTerminal/ddec753f446e4ba4944e35378ba635c8
来源：牛客网

```
#include<iostream>
#include<string>
/** \brief
整体来说，分为整数的相加和小数的相加，
整数部分分别存在z1和z2中，小数部分分别存在x1和x2中
剩下的就是字符串的相加了
 */
 
using namespace std;
int main(){
    string s1,s2,z1,z2,x1,x2;
    cin>>s1>>s2;
    z1=string(s1,0,s1.find(".",0));//取整数部分
    x1=string(s1,s1.find(".",0)+1,s1.length()-s1.find(".",0));//取小数部分
    z2=string(s2,0,s2.find(".",0));
    x2=string(s2,s2.find(".",0)+1,s2.length()-s2.find(".",0));
    //cout<<z1<<endl<<x1<<endl<<z2<<endl<<x2;
    if(z1.length()<z2.length())//总是使z1最长
        z1.swap(z2);
    if(x1.length()<x2.length())//总是使x1最长
        x1.swap(x2);
    int f=0;                    //标志位，进位时使用
    for(int i=x2.length()-1;i>=0;i--){  //先加小数部分，因为小数部分可能向整数部分进位
        int a=x1[i]-'0'+x2[i]-'0'+f;    //对应位相加，注意从最短数的最后一位相加
        x1[i]=a%10+'0';                 //更新该位值
        f=a/10;                         //更新进位标志
    }
    int l=z1.length()-1;                //整数部分相加
    for(int i=z2.length()-1;i>=0;i--){  //注意从最短数最后一位相加
        int a=z1[l]-'0'+z2[i]-'0'+f;
        z1[l]=a%10+'0';
        f=a/10;
        l--;                //调整最长位标志
    }
    while(l>=0){            //继续更新最长位，到起始值位置
        int a=z1[l]-'0'+f;
        z1[l]=a%10+'0';
        f=a/10;
        l--;
    }
    cout<<z1<<'.'<<x1;      //输出对应整数和小数
}
```



## 字符串匹配

主要是KMP算法，在不同情况下做调整。

https://www.cnblogs.com/yjiyjige/p/3263858.html

详见《题目无关》——KMP算法



# 数据结构一

## 向量



## 队列

## 栈

### 括号匹配问题

P75

```
#include <iostream>
#include <stack>
#include <cstdio>
using namespace std;

/**
 设置一个左括号栈，用来存放左括号在原数组中的下标。
 每当遇到一个右括号，若栈里有左括号，则左括号出栈。
 所以可以先默认遇到左括号时，印上一个'$'，当它出栈的时候在赋值为' '。
 
 左括号不匹配：当遍历完整个字符串后栈里还剩左括号，则剩下的都不匹配
 右括号不匹配：扫描到右括号但是栈空。
 */
int main(){
    string str;
    while(getline(cin,str,'\n')){
        stack<int>left;//存放左括号的位置
        string s(str.length(),' ');//初始化
        for(int i=0;i<str.length();i++){
            if(str[i]=='('){
                left.push(i);
                s[i]='$';
            }
            else if(str[i]==')'){

                if(left.empty())
                    s[i]='?';//左括号栈空则表明当前右括号不能匹配
                else{//匹配到了，左括号原本的位置变为空格，然后出栈
                    s[left.top()]=' ';
                    left.pop();
                }
            }
        }
        cout<<str<<endl;
        cout<<s<<endl;
    }
    return 0;
}

```



### <font color=red>简单计算器</font>

http://t.cn/AiKoGS94

在什么时候进栈的地方有难度。还得设置优先级判断，还得在字符串和栈底添加符号。

1.将运算符栈占地的特殊运算符#的优先级设为最低，于是后续遇到的任何运算符的优先级都会比它高，能够顺利入栈。

2.将表达式尾部的特殊运算符\$的优先级设为次低，于是当遍历到表达式尾部时，若运算符栈中尚有可以运算的符号，则可继续进行运算；若运算符中只剩下特殊符号#，则也可保证\$能够顺利入栈，并且让程序正确的退出。

3.isdigit()函数在头文件cctype中，该函数能够用来检查字符是否为十进制数字字符。



（我还根据下一题的评论区逻辑仿写了一种不用栈的方法，但是细节较多，不太推荐。  [点此跳转](https://www.nowcoder.com/profile/748608757/codeBooks?problemId=3776))

```
#include <iostream>
#include <stack>
#include <cstdio>
#include <cctype>
#include <string>
using namespace std;

int pri (char ch){//返回字符优先级
    int p=-1;
    if(ch=='#')
        p=0;
    else if(ch=='$')
        p=1;
    else if(ch=='+'||ch=='-')
        p=2;
    else
        p=3;
    return p;
}

double getNumber(string s, int& index){//返回字符串当前下标到下一个空格间的数字
    double ans=0;
    while(isdigit(s[index])){
        ans*=10;
        ans+=s[index]-'0';
        index++;
    }
    return ans;
}

double cal (double x, double y, char ch){//返回运算结果
    double result=0;
    if(ch=='+')
        result=x+y;
    else if(ch=='-')
        result=x-y;
    else if(ch=='*')
        result=x*y;
    else if(ch=='/')
        result=x/y;
    return result;
}
       
int main(){
    string str;
    while(getline(cin,str,'\n') && str!="0"){     
        int index=0;
        stack<double>num;
        stack<char>op;
        str+='$';//因为遇到符号才会计算，添加'$'是为了保证末尾的计算，否则无法触发计算。
        op.push('#');
        while(index<str.length()){
            if(str[index]==' '){
                index++;
            }
            else if(isdigit(str[index])){
                num.push(getNumber(str, index));
            }
            else{
                if(pri(str[index])>pri(op.top())){//如果当前字符比栈顶字符的优先级高，则进栈
                    op.push(str[index]);
                    index++;
                }
                else{//如果当前字符比栈顶字符的优先级低或相等，则计算栈里的
                    //数字的顺序别弄反了
                    double y = num.top();
                    num.pop();
                    double x = num.top();
                    num.pop();
                    char ch = op.top();
                    num.push(cal(x,y,ch));//结果再放入栈
                    op.pop();
                }
            }
        }
        printf("%.2f\n",num.top());
    }
    return 0;
}

```



### <font color=blue>计算表达式（和上一题很相似，稍微简单一点）</font>

http://t.cn/AiKKJjJ5

我的代码：（使用栈）

https://www.nowcoder.com/profile/748608757/codeBookDetail?submissionId=64392525

**评论区不用栈的代码：**

将减法转变为加法，遇到加号或减号，将下一个数字存到数组的下一位。

遇到乘号或除号，直接在数组当前位进行运算

妙啊。

```
#include<cstdio>
#include<iostream>
using namespace std;
int main(){
   double t;
     double a[1000];
    while(scanf("%lf",&t)!=EOF){
        double sum=0;
        char ch;int i=0;a[0]=t;
        while(scanf("%c",&ch)!=EOF&&ch!='\n'){
            double tem;
            scanf("%lf",&tem);
            if(ch=='+') 
                a[++i]=tem;
            else if(ch=='-')
                a[++i]=-tem;
            else if(ch=='*')
                a[i]*=tem;
            else if(ch=='/')
                a[i]/=tem;
        }
        for(int j=0;j<=i;j++)
            sum+=a[j];
        cout<<sum<<endl;
    }
}
```



# 数学问题

## 进制转换

### 二进制数（小型十进制转二进制）

http://t.cn/AiCuKTOv

x%2是最低位的，x/2可让高数位向低数位移动。
$$
x\%2=(b_0*2^0+b_1*2^1+b_2*2^2+...+b_n*2^n)\%2\\
x\%2=b_0
$$

$$
x/2=(b_0*2^0+b_1*2^1+b_2*2^2+...+b_n*2^n)/2\\
x/2=b_1*2^0+b_2*2^1+b_3*2^2+...+b_n*2^{n-1}
$$

不断进行求模和整除运算，便可依次求得被移动到最低数位的值；以此类推，便可得到所有数位上的值。

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <string>
#include <cstring>

using namespace std;

string convert(int num){
    string s;
    while(num){
        s+=num%2+'0';
        num/=2;
    }
    reverse(s.begin(),s.end());
    while(s[0]=='0'){
        s=s.substr(1);//截取s[1]到结尾
    }
    return s;
}

int main(){
    int num;
    string bi;
    while(cin>>num){
        bi=convert(num);
        cout<<bi<<endl;
    }
    return 0;
}
```

书上使用向量的版本：

```
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;

int main(){
    unsigned int n;
    while(cin>>n && n){
        vector<int> binary;
        while(n){
            binary.push_back(n%2);
            n/=2;
        }
        for(int i=binary.size()-1; i>=0; i--)
            cout<<binary[i];
        cout<<endl;
    }
    return 0;
}

```

### 进制转换（大型十进制转二进制）

http://t.cn/AiCuoPRO

**大数除法的原理：把字符串<font color=red>从高到低</font>逐位除以除数。如果某位不能整除，那么就保留它的余数，余数乘以原进制（这里为10）后和低一位一起进行处理。 最后的结果是商，而最后的余数其实也就是余数**

这里由于10进制直接用个位模2就行了，所以大数除法时不用同时返回余数，其他情况下需要把大数除法直接融入main函数

**<font color=red>大数除法并不改变进制！！！</font>**

```
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

//字符串除法
string Divide(string str, int x){
    int remainder=0;
    for(int i=0; i<str.length(); i++){
        int current= str[i]-'0'+remainder*10;
        str[i]=current/x + '0';
        remainder = current %x;
    }
    int pos=0;
    while(str[pos]=='0')
        pos++;
    str=str.substr(pos);
    return str;
}


int main(){
    string str;
    while(cin>>str){
        vector<int>binary;
        while(str.size()!=0){
            int last = str[str.size()-1]-'0';
            binary.push_back(last%2);
            str = Divide(str,2);
        }
        for(int i=binary.size()-1; i>=0; i--)
            cout<<binary[i];
        cout<<endl;
    }
    return 0;
}

```



### （大数）十进制转八进制

**如果是其他进制(<10)，只要改改数字就行**

基本都差不多，但是进栈不是用最后一位去模了，而是应该获取除法过程中的余数

http://t.cn/AiCu0lHe

```
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
#include <cstdio>
#include <cstring>
using namespace std;

//string Divide(string str, int x){
//    int remain=0;
//    for(int i=0; i<str.length(); i++){
//        int current = str[i]-'0'+ remain*10;
//        str[i] = current/ x +'0';
//        remain = current %x;
//    }
//    int pos=0;
//    while(str[pos]=='0')
//        pos++;
//    str= str.substr(pos);
//    return str;
//}


int main(){
    string str;
    while(cin>>str){
        vector<int>oct;
        while(str.size()!=0){
            int remain=0;
            for(int i=0; i<str.length(); i++){
                int current = str[i]-'0'+ remain*10;
                str[i] = current/ 8 +'0';
                remain = current %8;
            }
            int pos=0;
            while(str[pos]=='0')
                pos++;
            str=str.substr(pos);
            oct.push_back(remain);
        }
        for(int i=oct.size()-1; i>=0; i--){
            cout<<oct[i];
        }
        cout<<endl;
    }
    return 0;
}

```

### <font color=blue>进制转换（十六进制转十进制）</font>

http://t.cn/AiCuig9B

按理说可以实现不同进制的转换，可能需要小的修改。（十六进制转10进制没问题）

```
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;

int char2int(char ch){
    if(ch>='0' && ch <='9')
        return ch-'0';
    else
        return ch-'A'+10;
}
char int2char(int x){
    if(x>=0 && x<=9)
        return x+'0';
    else
        return x-10+'A';
}

int main(){
    string str;
    while(cin>>str){
        vector<int>ans;
        int n=16;//当前进制
        int m=10;//目标进制
        str=str.substr(2);//去掉前面的0x两个字符
        while(str.size()!=0){
            int remain=0;
            for(int i=0; i<str.length(); i++){
                int current = char2int(str[i])+ remain*n;
                str[i] = int2char(current/ m);
                remain = current %m;
            }
            int pos=0;
            while(str[pos]=='0')
                pos++;
            str=str.substr(pos);
            ans.push_back(remain);
        }
        for(int i=ans.size()-1; i>=0; i--){
            cout<<ans[i];
        }
        cout<<endl;
    }
    return 0;
}

```

评论区各种大神的进制转换：

https://www.nowcoder.com/questionTerminal/deb19498bc644f53a6a99905ef5ee01d?toCommentId=5240895



### 又一版A+B（大数加法+进制转换）

http://t.cn/AiCuOSWv

```
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;

//大数加法
string addStr(string s1, string s2){
    string s;
    if(s1.length()<s2.length())
        s1.swap(s2);
    s2.insert(0,s1.length()-s2.length(),'0');//对齐
    int flag=0;
    int temp=0;
    for(int i=s1.length()-1; i>=0;i--){
        
//        cout<<s1<<" "<<s2<<endl;
        temp= s1[i]-'0'+s2[i]-'0'+flag;
//        cout<<temp<<"  ";
        if(temp>=10){
            flag=1;
            temp%=10;
        }
        else
            flag=0;//这一步不能忘！
        s+=(temp+'0');
    }
    if(flag)//如果还有进位
        s+='1';
    reverse(s.begin(),s.end());
    return s;
}

int main(){
    int m;
    string A,B,s;
    while(cin>>m && m){
        cin>>A>>B;
        s=addStr(A,B);//大数加法
        
        vector<int>ans;
//        cout<<s<<endl;
        while(s.size()!=0){
            int remain=0;
            for(int i=0; i<s.length(); i++){
                int current = s[i]-'0'+ remain*10;
                s[i] = current/ m +'0';
                remain = current %m;
            }
            int pos=0;
            while(s[pos]=='0')
                pos++;
            s=s.substr(pos);
            ans.push_back(remain);
        }
        for(int i=ans.size()-1; i>=0; i--){
            cout<<ans[i];
        }
        cout<<endl;
    }
    return 0;
}

```



### <font color=red>十六以内任意进制转换</font>

http://t.cn/AiCu6ne4

改进的地方是把向量类型设置为了char，然后每次进栈的是 int2char(remain)

**<font color=red>大数除法并不改变进制！！！进制转换的原理还是反复模除，最后倒序输出</font>**

```
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;

int char2int(char ch){
    if(ch>='0' && ch <='9')
        return ch-'0';
    else if(ch>='A' && ch <='Z')
        return ch-'A'+10;
    else
        return ch-'a'+10;
}
char int2char(int x){
    if(x>=0 && x<=9)
        return x+'0';
    else
        return x-10+'A';
}

int main(){
    string str;
    int a,b;//原始进制，目标进制
    while(cin>>a>>str>>b){
        vector<char>ans;
        while(str.size()!=0){
            int remain=0;
            for(int i=0; i<str.length(); i++){
                int current = char2int(str[i])+ remain*a;
                str[i] = int2char(current/ b);
                remain = current %b;
            }
            int pos=0;
            while(str[pos]=='0')
                pos++;
            str=str.substr(pos);
            ans.push_back(int2char(remain));
        }
        for(int i=ans.size()-1; i>=0; i--){
            cout<<ans[i];
        }
        cout<<endl;
    }
    return 0;
}
```



## 最大公约数与最小公倍数

### 最大公约数

http://t.cn/AiCuWLTS

```
#include <iostream>
#include <algorithm>
using namespace std;

//非递归
int gcd(int a, int b){
    int r,temp=0;
    if(a < b){
        temp = a;
        a = b;
        b = temp;
    }
    while(a%b!=0){
        r=a%b;
        a=b;
        b=r;
    }
    return b;
}
//递归
int gcd2(int a, int b){
    if(b==0)
        return a;
    else{
        return gcd2(b, a%b);
    }
}

int main(){
    int a,b;
    while(cin>>a>>b){
        cout<<gcd(a,b)<<endl;
    }
    return 0;
}
```

### 最小公倍数

```
#include <iostream>
#include <algorithm>
using namespace std;

//非递归
int gcd(int a, int b){
    int r,temp=0;
    if(a < b){
        temp = a;
        a = b;
        b = temp;
    }
    while(a%b!=0){
        r=a%b;
        a=b;
        b=r;
    }
    return b;
}

int main(){
    int a,b;
    while(cin>>a>>b){
        cout<<a*b/gcd(a,b)<<endl;
    }
    return 0;
}
```



## 质数

### 素数（求两个整数之间的所有素数）

http://t.cn/AiCulqtW

**若一个数不是素数，则必存在一个小于它的素数为其因数。**

**<font color=blue>素数筛法：</font>**（推荐看下一题的）

找到一个素数，就将它的所有倍数均标记成非素数；若它未被任何小于它的素数标记为非素数，则确定为素数。

（我写的很乱逻辑，所以用书上的）

**initial()这个函数可以背一下，也可以把向量换成数组（可以参考下一题的initial()）**

MAXN不能过大，否则 **for(int j=i*i; j<MAXN; j+=i)** 会越界

```
#include <iostream>
#include <cmath>
#include <vector>
using namespace std;

const int MAXN =10001;
vector<int>prime;
bool isPrime[MAXN];

void initial(){
    for(int i=0; i<MAXN; i++)
        isPrime[i]=true;
    isPrime[0]=false;
    isPrime[1]=true;
    for(int i=2; i<MAXN; i++){
        if(!isPrime[i])
            continue;
        prime.push_back(i);
        for(int j=i*i; j<MAXN; j+=i)//这里很细节
            isPrime[j]=false;
    }
        return ;
}

int main(){
    initial();
    int n;
    while(cin>>n&& n){
        int sign=0;//默认无符合条件的输出
        int flag=1;//第一个数前面不带空格
        for(int i=0; i<prime.size() && prime[i]<n; i++){//注意这里判断的条件
            if(prime[i]%10==1){
                sign=1;
                if(flag){
                    cout<<prime[i];
                    flag=0;
                }
                else
                    cout<<" "<<prime[i];
            }
        }
        cout<<endl;
    }
    return 0;
}

```



### <font color=red>Prime Number</font>

http://t.cn/AiCulrSh

MAXC是题目要求最大的数量（即第几个素数）

MAXN设会导致内存溢出（第10000个素数是十万多一点）

我设置的1,000,000消耗的内存是1500K，耗时10ms；

可以设置为110,000，消耗内存512K，耗时5ms。

注意 double bound = sqrt(MAXN);  必须为double类型，否则会损失精度导致错误

**bound的设置很关键**

```
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
 
using namespace std;
 
const int MAXN=110000;
const int MAXC=10000;
 
bool isPrime[MAXN];
int num[MAXC];//用来存储素数，如果用vector会耗时一点
 
void initial(int& count){
    //经评论区大哥提醒这里bound应为double
    //如果是int，MAXN开根号可能会损失精度，在if(i>=bound)处直接跳过而少清理一个合数
    double bound = sqrt(MAXN);
    count=0;
    for(int i=0; i<MAXN; i++)
        isPrime[i]=true;
    isPrime[0]=false;
    isPrime[1]=true;
     
    for(int i=2; i<MAXN && count<MAXC; i++){//添加了count的条件
        if(!isPrime[i])
            continue;
        num[count]=i;
        count++;
        //***********防止越界**************
        if(i>=bound)
            continue;
        //********************************
        for(int j=i*i; j<MAXN; j+=i)
            isPrime[j]=false;
    }
        return ;
}
 
int main(){
    int k;
    int count=0;
    initial(count);
//    for(int i=0; i<count; i++)
//        cout<<i<<" "<<num[i]<<endl;
//    cout<<endl;
    while(cin>>k){
        cout<<num[k-1]<<endl;
    }
    return 0;
}

```



## 分解质因数

### 质因数的个数

我是先在初始化函数initial()中算出一定范围内的所有素数并存储在数组中

然后再用输入的数不断遍历刚才的数组，得到结果。

（但是我一想不用初始化直接除以的话好像也没问题，因为当除数是合数时，它一定可以表示成素数的积，所以当前被除数一定不能被这个除数整除，所以就直接找下一个了，好像挺节省时间的（方法在这段代码的下一段）。）

```
#include <iostream>
#include <cmath>
using namespace std;
 
const int MAXN=100000+1;//MAXN应该取上限的 开根号 +1
const int MAXC=10000;
 
bool isPrime[MAXN];
int num[MAXC];//用来存储素数，如果用vector会耗时一点
int mount=0;
 
void initial(){
    double bound = sqrt(MAXN);
    int count=0;
    for(int i=0; i<MAXN; i++)
        isPrime[i]=true;
    isPrime[0]=false;
    isPrime[1]=true;
     
    for(int i=2; i<MAXN && count<MAXC; i++){//添加了count的条件
        if(!isPrime[i])
            continue;
        num[count]=i;
        count++;
        //***********防止越界**************
        if(i>=bound)
            continue;
        //********************************
        for(int j=i*i; j<MAXN; j+=i)
            isPrime[j]=false;
    }
    mount=count;
        return ;
}
 
int getPriNum(int x){
    int q=0;
    for(int i=0;i<mount && num[i]<=sqrt(x);){//注意这里 没有i++
        if(x%num[i]==0){
//                cout<<num[i];
            q++;
            x/=num[i];
//            cout<<" "<<x<<endl;
            i=0;//每次找到合适的后都重置i
        }
        else i++;//i++在这
    }
    if(x>1)
        q++;//表示当前x就是质数 
    return q;
}
 
int main(){
    int n;
    initial();
    while(cin>>n){
        cout<<getPriNum(n)<<endl;
    }
    return 0;
}
```

**评论区大佬的方法：**

```
#include <iostream>
#include <cmath>
using namespace std;
int main(){
    //这题的关键：
    //1、是sqrt,可以极大减少复杂度，若是到方根N仍大于1，则必还有且只还有1个质因数
    //2、每次瞬间整除都可帮助减少遍历范围
    long M=100;
    while(cin>>M){
        long count=0;
            for(long j=2;j<=sqrt(M);j++){
             while(M%j==0)
             {
                 M=M/j;
                 count++;
             }
             if(M<=1)break;
            }
        if(M>1)count++;
        cout<<count<<endl;
    }  
    return 0;
}
```



### 约数的个数

http://t.cn/Aip7dTUp

约数是对称的啊！！！一定要对称计算，否则超时！

还有sqrt运算耗时，应该事先赋值到bound上再带入循环

```
#include <iostream>
#include <cmath>
#include <cstdio>
using namespace std;

int main(){
    int n;
    while(cin>>n){
        while(n--){
            int temp,num=0;
            cin>>temp;
            if(temp!=1){
                int i;
                double bound=sqrt(temp);
                for(i=1; i<=bound; i++){
                    if(temp%i==0){
                        num+=2;
                    if(i*i==temp)  //如果因数是相同的，减去重复的
                        num--;
                    }
                }
            }
            else num=1;
            cout<<num<<endl;
        }
    }
    return 0;
}
```



### <font color=red>整除问题</font>

http://t.cn/Aip7eHBD

这一题 **不能** 暴力（先计算阶乘再分解），因为阶乘会溢出！！！

具体细节见"题目无关.md"中的<font color=red>阶乘的质因数分解</font>

（我没做出来，但我看懂了评论区大神的代码）

（有点繁琐，有重复的地方。 建议看下一段精简写法。）

```
#include <cstdio>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;
const int MAXN=1010;
const int INF=(1<<31)-1;
//素数筛
bool p[MAXN]={false};//未被筛选
vector<int> prime;
void getPrime()
{
    p[0]=p[1]=true;//被筛去，不是素数
    for(int i=2;i<MAXN;i++)
    {
        if(p[i]==false)//未被筛去，是素数
        {
            prime.push_back(i);
            for(int j=i*i;j<MAXN;j+=i)
                p[j]=true;
        }
    }
}
int nFac[MAXN]={0};//记录n!的质因数分解后的结果，n!存在质因数i，则nFac[i]=指数
int aFac[MAXN]={0};//记录a的质因数分解的结果，a存在质因数i，则aFac[i]=指数
//对n!质因子分解
//对n!质因子分解(确实是n!)
//prime={2,3,5,7,11,13,17......}
//以10!为例， 10! = 2*3*4*5*6*7*8*9*10 = 2^8 * 3^4 * 5^2 * 7.
void getnFac(int n){
    for(int i=0;prime[i]<=n;i++){//这里必须是n啊不能写成sqrt(n)，因为是阶乘，很可能会有大于sqrt(n)的因数
        int pow=0;
        int tempn=n;
        while(n!=0){
            pow+=n/prime[i];
            n/=prime[i];
        }
        nFac[prime[i]]=pow;
        n=tempn;//还原n
    }
}
//对a质因子分解
int getaFac(int a){
    int ans=INF;
    int sqr=sqrt((double)a);//这里求单个数的质因数就可以使用sqrt了
    for(int i=0;prime[i]<=sqr;i++){//与上面的计算方法不同
        while(a%prime[i]==0){
            aFac[prime[i]]++;
            a=a/prime[i];
        }
        //prime[i]是a的质因子
        if(aFac[prime[i]]>0){
            //prime[i]不是n!的质因子
            if(nFac[prime[i]]==0)
                ans=0;
            //取相同质因子的指数相除最小的
            else if(nFac[prime[i]]/aFac[prime[i]]<ans)
                ans=nFac[prime[i]]/aFac[prime[i]];
        }
        if(a<=1) //不存在大于根号a的因数
            break;
    }
    if(a!=1){
        //剩下一个大于根号a的数是a的质因子
        aFac[a]++;
        //剩下一个大于根号a的数不是n!的质因子
        if(nFac[a]==0)
            ans=0;
        //取相同质因子的指数相减最小的
        else if(nFac[a]/aFac[a]<ans)
            ans=nFac[a]/aFac[a];
    }
    return ans;
}
int main(){
    int n,a;
    scanf("%d%d",&n,&a);
    getPrime();
    getnFac(n);
    int ans=getaFac(a);
    printf("%d",ans);
    return 0;
}
```



**推荐：**

评论区精简的写法（我稍加修改了）：

**评论区的count[i]中的i是素数表里的下标，而我改成了i就代表素数i。 此外，我将a的上界改成了sqrt(a)，那么就需要额外判断大于sqrt(a)的质因数了。**

```
#include <cstdio>
#include <iostream>
#include <cmath>
using namespace std;

const int N=1010;

int prime[N];
int primesize=0;
bool mark[N];

void init(){
    for(int i=0;i<N;i++)
        mark[i]=false;
    //其实mark[0]和mark[1]是多少根本不重要，因为用不上
    for(int i=2;i<N;i++){
        if(mark[i]) continue;
        else{
            prime[primesize++]=i;
            for(int j=i*i;j<N;j+=i)
                mark[j]=true;
        }
    }
}
int main(){
    init();
    int a,n;
    while(scanf("%d%d",&n,&a)!=EOF){
        int count1[N]={0};
        int count2[N]={0};
        for(int i=0;i<primesize && prime[i]<=n;i++){//求n!的质因数
            int t=n;
            while(t){
                count1[prime[i]]+=t/prime[i];
                t/=prime[i];
            }
//            cout<<prime[i]<<"^"<<count1[prime[i]]<<" ";
        }
        int ans=1<<31-1;
        double bound = sqrt(a);
        for(int i=0;i<primesize && prime[i]<=bound;i++){//求a的质因数
            while(a%prime[i]==0){
                count2[prime[i]]++;
                a/=prime[i];
            }
            if(count2[prime[i]]==0) continue;
            if(count1[prime[i]]/count2[prime[i]]<ans)
                ans=count1[prime[i]]/count2[prime[i]];
            if(a<=1) break; //全部分解完毕
        }
        if(a>1){//存在大于bound的质因数
            count2[a]++;
            if(count1[a]/count2[a]<ans)
                ans=count1[a]/count2[a];
        }
        printf("%d\n",ans);
    }
    return 0;
}
```



## 快速幂

### <font color=purple>求root(N,k)</font>

http://t.cn/AipAw4B1

我裂开了，这题我不会

https://www.nowcoder.com/questionTerminal/9324a1458c564c4b9c4bfc3867a2aa66?f=discussion

**<font color=blue>法1:</font>**

数学推导

<img src="/Users/yy/Downloads/typora图片/root数学推导.png" alt="root数学推导" style="zoom: 67%;" />	

通过数学公式推导： $N^r = N\%(k-1)$

由此得到最终的结果值为 $N\%（k-1）$,当值为0时由于值域限制>0，结果就为k-1。

问题就转为求 $N\%（k-1）$

再使用**快速幂取模**

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <cmath>
using namespace std;

long long fastE(long long x, long long y, int k){
    long long ans = 1;
    while(y!=0){
        if(y%2==1){
            ans*= x;
            ans%=k;
        }
        y>>=1;
        x*=x;
        x%=k;
    }
    return ans;
}

int main(){
    long long x,y;
    int k;
    while(cin>>x>>y>>k){
        long long ans = fastE(x,y,k-1);
        if(ans ==0){
            ans = k-1;
        }
        cout<<ans<<endl;
    }
    return 0;
}
```



**<font color=blue>法2:</font>**（来自评论区）

https://blog.csdn.net/merlini_/article/details/50651349

> 对于root(N, k)中的N，我们可以把N看作关于k的多项式，也就是N = a0 + a1*k + a2*k^2 + … + an* k^n，而我们要求的root函数就是这个多项式的系数和，也就是a0 + a1 + a2 + ... + an。下面我们考虑root(N^2, k)。此时N^2 = (a0 + a1*k + a2*k^2 + … + an* k^n)^2，而这个多项式展开后的系数和是(a0 + a1 + a2 + … + an)^2，这个结果刚好就是先对N取root函数再平方的结果。实际上，我们很容易就能看出，多项式先乘方再取系数和(先乘再去掉k)与先取系数和再乘方(先去掉k再乘)，结果是一样的(因为有没有k并不影响系数间的相乘，也不影响相乘之后的求和)，于是乎，我们可以得到以下的递推公式：
>
> 
>
>         root(x, y, k) = root((root(x, y / 2, k))^2, 1, k)， y为偶数
>     
>         root(x, y, k) = root((root(x, y / 2, k))^2 * root(x, 1, k), 1, k)， y为非1的奇数
>     
>         root(x, 1, k) = x % k + x / k % k + ...(大于k的话再重复求root)
>
> 
>
>         有了递推关系之后，我们就可以直接写出一个O(log n)的递归解法了。




```
#include <iostream>
 
using namespace std;
 
int root(int x, int y, int k) {
    if (y == 1) {
        if (x < k)
            return x;
        else {
            while (x >= k) {
                int sum = 0;
                while (x > 0) {
                    sum += x % k;
                    x /= k;
                }
                x = sum;
            }
            return x;
        }
    }
    else {
        int result = root(x, y / 2, k);
        result *= result;
        if (y % 2 == 1)
            result *= root(x, 1, k);
        return root(result, 1, k);
    }
}
 
int main() {
    int x, y, k;
    while (cin >> x >> y >> k) {
        cout << root(x, y, k) << endl;
    }
    return 0;
}
```



## 矩阵与矩阵快速幂

### 矩阵幂

http://t.cn/Aip4T3HX

放个板子吧

```
#include <iostream>
#include <cstdio>
using namespace std;
 
struct Matrix{
    int matrix[10][10];
    int row,col;
    Matrix(int r, int c): row(r),col(c){}
};
 
void printMatrix(Matrix x){
    for(int i=0; i<x.row; i++){
        for(int j=0; j<x.col; j++){
            if(j!=0)
                cout<<" ";
            cout<<x.matrix[i][j];
        }
        cout<<endl;
    }
    return ;
}
 
Matrix Multiply(Matrix x, Matrix y){
    Matrix ans(x.row, y.col);
    //矩阵一开始需要初始化！！！！！！！！！！！
    for(int i=0; i<ans.row; i++)
        for(int j=0; j<ans.col; j++){
            ans.matrix[i][j]=0;
            for(int k=0; k<x.col; k++)
                ans.matrix[i][j]+=x.matrix[i][k] * y.matrix[k][j];
        }
     
    return ans;
}
 
 
 
Matrix FastE(Matrix x, int k){
    Matrix ans(x.row, x.col);
    //初始化单位矩阵
    for(int i=0; i<ans.row; i++){
        for(int j=0; j<ans.col; j++){
            if(i==j)
                ans.matrix[i][j]=1;
            else
                ans.matrix[i][j]=0;
        }
    }
    while(k!=0){
        if(k%2==1){
            ans = Multiply(ans, x);
        }
        k/=2;
        x = Multiply(x,x);
    }
    return ans;
}
 
 
int main(){
    int n,k;
    while(cin>>n>>k){
        Matrix x(n,n);
        for(int i=0 ; i<n; i++)
            for(int j=0; j<n; j++)
                cin>>x.matrix[i][j];
//        printMatrix(x);
        Matrix ans = FastE(x,k);
        printMatrix(ans);
    }
    return 0;
}
```



## 高精度整数


