[TOC]

# 贪心策略

## 简单贪心

### 代理服务器

http://t.cn/E9emuS9

分析：


​    题目里说：系统在同一时刻只能使用一个代理服务器
​    每次切换服务器的时候表明 当前服务器需要访问和它ip相同的服务器
​    为了使切换次数尽可能的少，我们需要使一个服务器访问的尽可能的多
​    即 发生重名的事件尽可能的出现在后面

**注：题目所给的需要访问的ip是有顺序的**

1.“若没有符合要求的安排方式，则输出-1。”这种情况是只有一个代理服务器，然后在需要访问的服务器的ip正好有和代理服务器ip相同的。那么这样无法访问

2.一般情况下，要使切换次数尽可能的少，那就需要选一个代理服务器，它能访问最多的ip



<font color=gray>例如，（为了简便用一个字母替代ip）</font>

<font color=gray>有代理服务器ip：B，C，E</font>

<font color=gray>需要访问的ip： A，B，C，D，E，F</font>

<font color=gray>那么如果先选择使用B，一次最多只能访问第一个ip</font>

<font color=gray>先使用C，一次最多可访问A，B两个ip</font>

<font color=gray>先使用E的话，最多可访问A，B，C，D共四个ip</font>

当检测完所以的代理服务器之后，选择E，然后此时还有没访问的ip，所以需要进行代理服务器切换

此时还剩下E，F。 可以选择B，C任意一个代理服务器进行访问

```
#include <iostream>
#include <string>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <vector>
using namespace std;

int n,m;
vector<string>agency;
vector<string>server;

int main(){
    string ip;
    while(cin>>n){
        for(int i=0; i<n;i++){
            cin>>ip;
            agency.push_back(ip);
        }
        cin>>m;
        for(int i=0; i<m; i++){
            cin>>ip;
            server.push_back(ip);
        }
        if(n==1){
            int flag=0;
            for(int i=0; i<m; i++){
                if(server[i]==agency[0])
                    flag=1;
            }
            if(flag){
                cout<<-1<<endl;
                break;
            }
            cout<<m-1<<endl;
        }
        else{
            int start=0;//遍历访问服务器
            int times=0;//需要切换的次数
            while(start!=m){
                //由于至少有两个代理服务器，所以count最终不可能为0
                int count =0;//count表示当前代理服务器所能访问ip的最大数量
                for(int i=0; i<n; i++){
                    int j=start;
                    while(!(agency[i]==server[j]) && j<m)
                        j++;
                    if(j-start>count)
                        count=j-start;
                }
                times++;//当目前可用的代理服务器用完时，需要切换
                start+=count;//更新起点
            }
            cout<<times-1<<endl;
        }
    }
    return 0;
}

```



## 区间贪心

### Case of Fugitive

代码在书上，有空搬上来



### To Fill or Not to Fill

https://www.nowcoder.com/questionTerminal/f7eba38f7cd24c45982831e0f38518f9?toCommentId=5250277&ran=749

这道题写吐了我。。。

思路一开始想错了按价格升序， 后来才意识到应该按distance升序排列

过程思路在代码的注释中，只要把注释掉的代码取消注释，然后用例子输出一下就知道过程了

```
先按距离进行排序
设置sign=0
能否到达下一个加油站（默认我们先到第一个加油站，即初始化next=0）
      设置sign=1
      更新当前距离、剩余油量等参数，令当前站的下标为temp
      看看如果在此站 加满油 后能否到达比本站油价更低的
              如果有，看看当前剩余油够不够到,并令next=油价更低的站
                      如果能到的话，不用加了直接
                      如果不能到，加到足够撑到油价更低的站就行了
              如果没有更低的站
                      看看当前剩余的油能到终点，直接break
                      如果需要加一点才能到终点，加一点
                      如果不能到终点，加满，并令next=temp+1
如果sign=0，表示到不了下一个加油站了，按失败情况输出
```



```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

struct station{
    double pri;
    double dis;
    bool visited;
    int index;
};

station sta[500];

bool cmp(station x, station y){
    if(x.dis==y.dis){
        return x.pri<y.pri;
    }
    else return x.dis<y.dis;
}

int main(){
    int N;
    double Cmax,wholeDis, aveDis;
    while(cin>>Cmax){
        cin>>wholeDis>>aveDis>>N;
        for(int i=0;i<N; i++){
            cin>>sta[i].pri>>sta[i].dis;
            sta[i].visited=false;
            sta[i].index=i;
        }

        sort(sta,sta+N,cmp);

        double currentDis=0;//当前行驶距离
        double currentFuel=0;//当前油量
        double wholePri=0;//总费用
        double consume=-1;//和目标加油站相差的油量
        double cost=-1;//（临时变量用于解释）
        int temp=-1;//临时变量，当前加油站的编号
        int fail=0;//无法到达目的地
        int succeed=0;//可以到达目的地
        double dif=-1;//（临时变量用于解释）
        double finalDis=0;//最远行驶距离
        double tempPri=-1;//（临时变量用于解释）
        int next = 0;
//        for(int i=0; i<N; i++)
//            cout<<sta[i].pri<<" "<<sta[i].dis<<endl;

        while(true){
            if(succeed)
                break;
            int sign=0;//默认到不了更远的加油站
            for(int i=next; i<N; i++){
                if(currentDis+currentFuel*aveDis>=sta[i].dis) {//能顺利到达下个加油站
                    sign = 1;
                    sta[i].visited = true;
                    currentFuel -= (sta[i].dis - currentDis) / aveDis;//到达此加油站剩余的油量
                    currentDis = sta[i].dis;//更新当前位置
                    temp = i;
//                    cout << "当前位于加油站" << temp << "  当前位置:" << currentDis << "  当前油量:" << currentFuel << endl;

                    //计算下一个要去的加油站
                    double minPri = 99999999999;

                    int flag = 0;//默认能到达的加油站没有比它价格更小的
                    for (int j = temp + 1; j < N; j++) {
                        if (currentDis + Cmax * aveDis >= sta[j].dis && !sta[j].visited&&sta[j].pri < sta[i].pri) {//此加油站能到达的，比它价格更小的
                            next = j;
                            flag = 1;
                            break;
                        }
                    }
                    if (flag) {//加到够到目标站的就行了
                        if(currentDis + currentFuel*aveDis <sta[next].dis) {//如果当前的油不够到目标站的
                            consume = (sta[next].dis - currentDis) / aveDis;//需要的油量
                            dif = (consume - currentFuel);
                            cost = (consume - currentFuel) * sta[i].pri;
                            wholePri += (consume - currentFuel) * sta[i].pri;
                            currentFuel = consume;
                            flag = 0;
//                            cout << "下一站想去：" << next << "  目标位置:" << sta[next].dis << "  需要油量：" << consume << endl;
//                            cout << "加了" << dif << " 花费：" << cost << endl;
                            break;
                        }
                        else{
//                            cout<<"此加油站不加油"<<endl;
                            break;
                        }

                    } else {//没找到价格更低的，加到下个重点或者全都加满
                        if (currentDis + currentFuel * aveDis >= wholeDis) {//剩余油足够到达终点
                            succeed = 1;//不加了
                            break;
                        } else if (currentDis + Cmax * aveDis >= wholeDis) {//再加一些能到达终点
                            consume = (wholeDis - currentDis) / aveDis;
                            dif = (consume - currentFuel);
                            cost = (consume - currentFuel) * sta[i].pri;
                            wholePri += (consume - currentFuel) * sta[i].pri;
                            succeed = 1;
//                            cout << "加了" << dif << " 花费：" << cost << endl;
                            break;
                        } else {//加满
                            dif = (Cmax - currentFuel);
                            cost = (Cmax - currentFuel) * sta[i].pri;
                            wholePri += (Cmax - currentFuel) * sta[i].pri;
                            currentFuel = Cmax;
//                            cout << "加了" << dif << " 花费：" << cost << endl;
//                            cout << "####已加满油####" << endl;
                            next=temp+1;
                            break;
                        }
                    }
                }
            }

            if(sign==0){
                finalDis=currentDis+Cmax*aveDis;
                fail=1;
                break;
            }
        }
        if(succeed)
            printf("%.2lf\n",wholePri);

        if(fail)
            printf("The maximum travel distance = %.2lf\n",finalDis);
    }
    return 0;
}

```



# 递归与分治

## 递归策略

### 杨辉三角形（水题）

http://t.cn/Ai0KcLRI

**非递归**

```
#include <iostream>
#include <cstdio>
using namespace std;

int a[1000][1001];

int main(){
    int n;
    for(int i=0; i<1000;i++)
        for(int j=0; j<1000; j++)
            a[i][j]=0;
    while(cin>>n){
        a[1][1]=1;
        a[1][2]=1;
        for(int i=2; i<n; i++){
            for(int j=1; j<=i+1; j++){
                a[i][j]=a[i-1][j-1]+a[i-1][j];
            }
        }
        for(int i=1;i<=n-1;i++){
            for(int j=1; j<=i+1; j++){
                cout<<a[i][j]<<" ";
            }
            cout<<endl;
        }
    }
    return 0;
}

```

**递归**

```
#include <iostream>
#include <cstdio>
using namespace std;

int YH(int i, int j){
    if(j==1)
        return 1;
    else if(j==i+1)
        return 1;
    else return YH(i-1,j-1)+YH(i-1,j);
}

int main(){
    int n;
    while(cin>>n){
        for(int i=1;i<=n-1;i++){
            for(int j=1; j<=i+1; j++){
                cout<<YH(i,j)<<" ";
            }
            cout<<endl;
        }
    }
    return 0;
}
```



### 全排列

http://t.cn/Ai0K0hXZ

思路：

需要先进行字典排序

void permute(int start) 表示从start到结尾为后续串，0到start-1为前缀，后续串需要进行全排列

逐个扫描后续串，当遇到一个不在前缀中的字符时，加入到前缀中（严格来说不是加入，而是替换），然后递归调用permute(start+1)； 如果当前字符已经在前缀中，向后继续扫描。

**方法一：**（方法二更标准） 不使用bool数组，每次通过遍历前缀数组来看当前字符是否已在其中。

```
#include <iostream>
#include <cstring>
#include <string>
#include <cstdio>
#include <algorithm>
using namespace std;

string str;
char pre[7]={0};

void permute(int start){
    if(start==str.length()){
        for(int i=0; i<str.size(); i++)
            cout<<pre[i];
        cout<<endl;
    }
    else{
        char ch;
        int flag=0;
        for(int i=0; i<str.length();i++){
            ch=str[i];
            flag=0;//初始化当前字符不在pre中
            for(int j=0; j<start;j++){//在pre中寻找该字符
                if(pre[j]==ch){//我把j写成i了卡了半天！！！！！！！！！！
                    flag=1;//找到了
                    break;
                }
            }
            if(flag)
                continue;//继续下一个
            pre[start]=ch;
            permute(start+1);
            
        }
    }
}

int main(){
    while(cin>>str){
        sort(str.begin(),str.end());
        
        permute(0);//开始以start开始为后续串的全排列
        cout<<endl;
    }
}

```



**方法二：**简单易懂

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>

using namespace std;

string str;

char pre[7];
bool visited[7];

void permute(int start){
    if(start==str.length()){
        for(int i=0; i<str.length(); i++){
            cout<<pre[i];
        }
        cout<<endl;
    }
    else{
        for(int i=0; i<str.length(); i++){
            if(!visited[i]){
                char ch = str[i];
                visited[i]=true;
                pre[start] = ch;
                permute(start+1);
                visited[i]=false;
            }
        }
    }
}


int main(){
    while(cin>>str){
        for(int i=0; i<7; i++)
            visited[i] = false;
        sort(str.begin(), str.end());
        permute(0);
        cout<<endl;
    }
    return 0;
}
```





## 分治法

### 幂次方

**方法一：**

https://blog.csdn.net/qq_43510916/article/details/104112680

没注意我申请的是全局变量，低级错误卡了半天。

此方法和方法二思路差不多，就是都先表示成二进制。但是这个方法是从最高位开始的，还用到了快速幂，有些没必要了。不如从最低位开始，最后反转一下字符串就行了。

```
#include <iostream>
#include <cstdio>
using namespace std;
#define max 15

//快速幂
int FastE(int a, int b){
    int ans=1;
    while(b!=0){
        if(b%2==1)
            ans *=a;
        b/=2;//可以改成b>>=1
        a*=a;
    }
    return ans;
}

void powPrint(int n){
    int flag[max];//去特么的全局变量

    int num=0;//num为n的项的个数
    for(int i=0;i<max;i++)
        flag[i]=0;
    while(n!=0){
        for(int i=max-1; i>=0; i--){
            int temp=FastE(2,i);
            if(n>=temp){
                flag[i]=1;
                n-=temp;
                num++;
            }
        }
    }
    for(int i=max-1;i>=0;i--){
        if(flag[i]){
            if(num==0)
                break;
            if(i==0||i==2)
                cout<<2<<"("<<i<<")";
            else if(i==1)
                cout<<2;
            else {
                cout<<2<<"(";
                powPrint(i);
                cout<<")";
            }
            
            if(num!=1)
                cout<<"+";
            num--;
        }
    }
}

int main(){
    int n;
    while(cin>>n){
        powPrint(n);
        cout<<endl;
    }
    return 0;
}

```



**方法二：**

https://www.luogu.com.cn/record/34655968

这里是先把n转换成二进制，然后直接根据二进制中1的下标再递归表示。

比如 137 = 10001001，下标分别有7, 3, 0

然后再分别对7, 3, 0进行转二进制再下标表示...

直到下标为2或0时输出2(2) 或2(0)，或者为1时输出2。其他情况见代码

```
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdio>
using namespace std;


void powPrint(int n){
    //转换成二进制表示
    string str;
    while(n!=0){
        int temp = n%2;
        str+=temp+'0';
//        cout<<str<<endl;
        n>>=1;
    }
    reverse(str.begin(), str.end());
    int pos = 0;
    while(str[pos]==0){
        pos++;
    }
    str = str.substr(pos);
//    cout<<str<<endl;
    int num = count(str.begin(), str.end(), '1');

    for(int i=0; i<str.length(); i++){
        if(str[i]=='1'){
            if(num==0)
                break;
            if(i==str.length()-1){//2^0和2^2
                cout<<2<<"("<<str.length()-i-1<<")";
            }
            else if(i==str.length()-2){
                cout<<2;
            }
            else{
                cout<<2<<"(";
                powPrint(str.length()-i-1);
                cout<<")";
            }
            if(num!=1)
                cout<<"+";
            num--;
        }
    }
}

int main(){
    int n;
    while(cin>>n){
        powPrint(n);
    }
    return 0;
}


//2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)
```



# 搜索

## 宽度优先搜索

### Catch That Cow

http://poj.org/problem?id=3278

理解不难，但是，，容易超时。

一开始我是放在函数里运行的，不行。然后放在main里也不行

问题出在进入队列上面

我之前用的for循环(int i=0; i<3; i--)

然后i=1,2,3时分别对应三个状态，先声明一个location temp 并且赋值，再判断是否越界、是否已经访问。

这样会超时。

然后我改成了取消for循环变为三个if，并且先判断是否越界、已经访问，然后再入队。

```
else{
	if(l.num-1>=0 && !visited[l.num-1]){
		loc.push(location(l.num-1,l.layer+1));
		visited[l.num-1]=true;
	}
	if(l.num+1<=MAXN && !visited[l.num+1]){
		loc.push(location(l.num+1,l.layer+1));
		visited[l.num+1]=true;
	}
	if(l.num*2<=MAXN && !visited[l.num*2]){
		loc.push(location(l.num*2,l.layer+1));
		visited[l.num*2]=true;
	}
	loc.pop();
}
```

**完整代码：**

```
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;
#define MAXN 100001

int k;
struct location{
    int num;
    int layer;
    location(int n, int l): num(n), layer(l){}

};


bool visited[MAXN];


int main(){
    int n;
    while(cin>>n>>k){
        for(int i=0;i<MAXN; i++)
            visited[i]=false;

        queue<location>loc;
        location start(n,0);
        loc.push(start);
        visited[start.num] = true;

        while(!loc.empty()) {
            location l = loc.front();
//            cout<<"当前位置："<<l.num<<endl;

            if (l.num == k){
                cout << l.layer << endl;
                break;
            }
            else{
                if(l.num-1>=0 && !visited[l.num-1]){
                    loc.push(location(l.num-1,l.layer+1));
                    visited[l.num-1]=true;
                }
                if(l.num+1<=MAXN && !visited[l.num+1]){
                    loc.push(location(l.num+1,l.layer+1));
                    visited[l.num+1]=true;
                }
                if(l.num*2<=MAXN && !visited[l.num*2]){
                    loc.push(location(l.num*2,l.layer+1));
                    visited[l.num*2]=true;
                }
                loc.pop();
            }
        }
//        cout<<loc.empty()<<endl;

    }
    return 0;
}



```



### <font color=blue>Find The Multiple</font>

在POJ上超时，在vjudge上能过

https://vjudge.net/problem/POJ-1426

http://poj.org/problem?id=1426

并不难，但是一开始没想到队列，不知道怎么切换增加0和1

BFS和队列有很多联系！

```
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;

int n;
void BFS(long long x){
    queue<long long>longList;
    longList.push(x);

    while(!longList.empty()){
        long long num=longList.front();
//            cout<<"当前搜索："<<num<<endl;
        longList.pop();
        if(num%n==0){
            cout<<num<<endl;
            break;
        }
        else{
            longList.push(num*10);
            longList.push(num*10+1);
        }
    }
}


int main(){
    while(cin>>n&&n){
        BFS(1);
    }
    return 0;
}
```



### <font color=blue>玛雅人的秘密</font>

http://t.cn/Ai0lUhJj

第一次用map。一开始用的bool visited数组存储是否访问，然后用stoll将字符串转化为long long，结果数组越界了（不出所料）

然后使用map，挺好用的。

（这是改进后的版本，不知道直接用visited[i]==0判断没访问过对不对，[旧代码](https://www.nowcoder.com/profile/748608757/codeBookDetail?submissionId=64878765)用的map的迭代器，如果迭代器到达了map的末尾表示没访问过）

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <map>
#include <queue>
using namespace std;

struct node{
    string s;//字符串
    int times;//次数
    node(string str, int t):s(str), times(t){}
};

map<string, int>visited;
queue<node> q;
string str;

int main(){
    int n;
    while(cin>>n && n){
        cin>>str;
        //提前结束程序的几种情况（不包含0或不包含1或不包含至少两个2）
        if(count(str.begin(), str.end(), '0')==0 || count(str.begin(), str.end(), '1')==0 || count(str.begin(), str.end(), '2')<2){
            cout<<-1<<endl;
            continue;
        }
        
        //有解的情况
        visited.clear();//初始化map
        while(!q.empty())
            q.pop(); //队列初始化
        q.push(node(str, 0));
        int flag =0; //默认没有解
        while(!q.empty()){
            node a = q.front();
            q.pop();
            //检查是否含有2012，如果有就输出并结束
            if(a.s.find("2012")!=string::npos){
                flag=1;
                cout<<a.times<<endl;
                break;
            }
            else{
                for(int i=1; i<str.length(); i++){
                    string ss = a.s;
                    //交换相邻位置元素
                    char temp = ss[i];
                    ss[i] = ss[i-1];
                    ss[i-1] = temp;
                    if(!visited[ss]){//如果没有被访问，入队
                        visited[ss]=1;
                        q.push(node(ss, a.times+1));
                    }
                }
            }
        }
        if(!flag)//没有解
            cout<<-1<<endl;
    }
    return 0;
}
```



## 深度优先搜索

### A Knight's Journey

https://vjudge.net/problem/POJ-2488

http://poj.org/problem?id=2488

POJ里用G++能过，C++就超时...



注意输出结果要按照字典序排列，所以在设置方向的时候就不是随意设置的了。

需要使得Y尽可能的小，在Y相同的时候使X尽可能的小。



另外，递归函数里有一段这样的调用

```
DFS(nextx,nexty,num+1, ans+coY+coX)
```

<font color=red>不能</font>写成 num++; ans=ans+coY+coX; 然后再DFS(nextx,nexty,num, ans)

因为这样的状态返回的时候，num和ans已经改变的还原不回来

**完整代码：**

```
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
using namespace std;

int p,q;
bool visited[8][8];

//答案需要按照字典序！！！！！！
//X表示行，Y表示列
//所以应该让Y小的放在前面，Y相等时X小在前
int direction[8][2]={
        {-1,-2}, {1,-2}, {-2,-1}, {2,-1}, {-2,1}, {2,1}, {-1,2}, {1,2}
};


//坐标是列在前啊喂   (0,0)对应A,1,  (m,n)对应 'A'+m, '1'+n
bool DFS(int x, int y, int num, string ans){//从(x,y)开始DFS
//    cout<<ans<<"    num="<<num<<endl;
    if(num==p*q){
        cout<<ans<<endl<<endl;
        return true;
    }
    else{
        for(int i=0; i<8; i++){//在一个位置有8种走法
            int nextx= x+direction[i][0];
            int nexty= y+direction[i][1];
            if(nextx>=0 && nextx<p && nexty>=0 && nexty<q && !visited[nextx][nexty]){//如果没有越界也没有访问过
                visited[nextx][nexty]=true;

                char coX= nextx+'1';
                char coY= nexty+'A';

                //不能先令num++再调用DFS，因为这样会更改当前层的num，导致如果下一层走不通返回时num的值不一样！
                //同理ans也不能先更新
                //递归函数里的参数要用表达式的写法
                //ans是列在前
                if(DFS(nextx,nexty,num+1, ans+coY+coX)){//如果从(nextx,nexty)继续搜索，有解的话直接向上返回
                    return true;
                }
                visited[nextx][nexty]=false;//表示这个(nextx,nexty)无解，则取消它的访问
            }
        }
    }
    return false;
}


int main(){
    int n;
    cin>>n;
    int count=0;
    while(n--){
        cout<<"Scenario #"<<++count<<":"<<endl;
        cin>>p>>q;

        memset(visited,false,sizeof(visited));
        visited[0][0]=true;


        string ans="A1";//从A1开始搜是字典序最小的
        if(DFS(0,0,1,ans)){//从(0,0)即A1开始搜，如果有解则输出

        }
        else{
            cout<<"impossible"<<endl<<endl;
        }
    }
    return 0;
}
```



### Squre

http://acm.hdu.edu.cn/showproblem.php?pid=1518

 不难

能立刻排除掉的情况：总长度不能被4整除； 最长的棍子大于平均长度



给棍子降序排序，然后一个棍子一个棍子攒，攒够了平均长度换下一个棍子。

当三根棍子都到达平均长度时，就不用继续算了，直接返回true

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

const int MAXN= 20;

int sticks[MAXN];
int length;
int ave;
bool visited[MAXN];
int n;

bool cmp(int x, int y){
    return x>y;
}

bool DFS(int current, int num, int pos){//当前长度、第几个棍子(0,1,2,3)、sticks数组的下标
     if(num==3){//前三根都凑成平均了，最后一根一定是平均，不用找了
         return true;
     }
     else{
         for(int i=pos; i<n ;i++){//每次从pos下标开始找

             if(current+sticks[i]<=ave && !visited[i]){//如果小于等于平均长度并且这根棍子没有使用过，则继续搜索
//                  cout<<"当前长度："<<current<<"   当前序号："<<num<<"   正在搜索："<<sticks[i]<<endl;
                visited[i]=true;//标记棍子已使用
                if(current+sticks[i]==ave){//当前num的棍子的长度合适了
                    if(DFS(0,num+1,0))
                        return true;
                }
                else{
                    if(DFS(current+sticks[i],num,i+1)){//这里pos赋值为i+1是因为，棍子长度是按降序排列的，当前长度不够，要寻找更小的
                        return true;
                    }
                }
                visited[i]=false;//如果执行到这，说明上面并没有返回true，即无解，这时要取消标记
             }
         }
         return false;//for循环都循环完了还没找到，那就无解了
     }
}

int main(){
    int N;
    while(cin>>N){
        while(N--) {
            cin >> n;
            length = 0;
            ave=0;
            for (int i = 0; i < n; i++) {
                cin >> sticks[i];
                length += sticks[i];
            }
            if (length % 4 != 0) {
                cout << "no" << endl;
                continue;
            }
            sort(sticks, sticks + n, cmp);//将木棍从大到小排列
            ave = length / 4;
            if (sticks[0] > ave) {//如果最长的木棍比平均值大
                cout << "no" << endl;
                continue;
            }
            //开始搜索
            memset(visited, false, sizeof(visited));

            if (DFS(0, 0, 0)) {
                cout << "yes" << endl;
            } else {
                cout << "no" << endl;
            }
        }
    }
    return 0;
}
```



### <font color= purple>神奇的口袋</font>

我是个憨批吧这么简单我都没写出来

http://t.cn/Ai0u0GUz

我一开始是拿的上一题Square的板子，但是上一题适合求有没有解。

方法有动态规划、递归、回溯	

核心就是 从前到后，对于当前的物品，要么拿，要么不拿。



**回溯法**

```
#include<iostream>
#include<string.h>
using namespace std;
int ans = 0, n, a[100] = {0};
void dfs(int x,int num){  //X为当前体积，num为刚取的物品的下标（物品只有一件，要避免重复取）

    if (x > 40)return;
    if (x == 40)
        ans++;

    for (int i = num+1; i < n; i++){
        x += a[i];//拿起
        dfs(x, i);//并继续搜索
        x -= a[i];//放下（回溯）
    }

}

int main(){
    while (cin >> n){
        memset(a, 0, sizeof(a));
        ans = 0;
        for (int i = 0; i < n; i++)
            cin >> a[i];

        dfs(0, -1);
        cout << ans << endl;
    }
    return 0;
}
```



**递归法**
$$
count(i,sum) = count(i+1, sum-a[i]) + count(i+1, sum)
$$


```
#include <iostream>
#include <cstdio>
using namespace std;

int n;
int a[20];

int count(int i, int sum){//i是物品的下标，sum是剩余需要的体积
//    cout<<i<<"  "<<sum<<endl;
    if(sum==0)//sum==0要放在前面 因为可能出现 i==n且sum==0的情况，如果放在后面就return 0了
        return 1;
    if(sum<0||i==n)
        return 0;
    else{
        //count(i+1, sum-a[i])表示拿a[i]的情况，count(i+1, sum)表示不拿
        return count(i+1, sum-a[i])+count(i+1, sum);
    }
}

int main(){
    while(cin>>n){
        for(int i=0; i<n;i++){
            cin>>a[i];
        }

        cout<<count(0,40)<<endl;

    }
    return 0;
}
```



**动态规划**

dp\[i]\[j]表示现在有i件物品，凑成体积为j的方法数
$$
dp[i][j]=
\begin{cases}
dp[i-1][j]& \text{j<a[i]}\\
dp[i-1][j] + dp[i-1][j-a[i]]& \text{j $\geq$ a[i]}
\end{cases}
$$


```
/**
 * 递推式
 *
 * 初始化 d[i][0]=1 不管有几件商品，凑成体积为0时只有一种方法就是全不拿
 *
 * 当j<a[i]时，第i件物品没法拿，所以方法数就等于i-1件时的方法数
 * dp[i][j] = dp[i-1][j]
 *
 * 当i>=a[i]时，可以选择拿或不拿
 * 不拿的方法数为 有i-1件时的方法数
 * 拿的方法数为 有i-1件时凑成体积 j-a[i] 时的方法数
 * dp[i][j] = dp[i-1][j] + dp[i-1][j-a[i]]
 */
```

```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

int a[21];
int dp[21][41]; //dp[i][j]表示现在有i件物品，凑成体积为j的方法数

int main(){
    int n;
    while(cin>>n){
        //之前数组设小了啊啊啊啊啊啊啊啊啊啊啊
        for(int i=1; i<=n; i++)//下标从1开始 a[i]就是第i件物品的重量
            cin>>a[i];

        sort(a,a+n);

        for(int i=0; i<=n; i++){
            dp[i][0]=1;
        }

        for(int i=1; i<=n; i++){
            for(int j=1; j<=40; j++){
                if(j<a[i])
                    dp[i][j] = dp[i-1][j];
                else{
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-a[i]];
                }
            }
        }

        cout<<dp[n][40]<<endl;
    }
    return 0;
}
```



### 八皇后

http://t.cn/Ai0uOazs

题目输入第一行多余。

**方法一：**

```
#include <iostream>
#include <cstdio>
#include <vector>
#include <cmath>
using namespace std;

vector<string>vec;
bool judge(int row, int col, string a){//a[i-1]表示第i行的列数
    if(row==1)
        return true;
    for(int i=1; i<row; i++){
        if(col+'0'==a[i-1])//在同一列
            return false;
        if(abs(row-i) == abs(col+'0'-a[i-1]))//在对角线
            return false;
    }
    return true;
}

void DFS(int i, int j, string a){//在(i,j)处摆放，a为当前字符串
    if(judge(i,j,a)){//判断摆在(i,j)是否符合要求
        if(i==8){//如果符合要求并且i==8，即最后一行可以，则结果放入向量
            char ch=(j+'0');
            a+=ch;
            vec.push_back(a);
        }
        else{//否则继续搜索
            //对i+1行的各种情况进行搜索
            for(int col=1; col<=8;col++){
                if(col!=j){//保证和上一行不同列
                    char ch= j+'0';
                    DFS(i+1,col,a+ch);//在(i+1, col)处进行摆放
                }

            }
        }
    }
    else{
        return ;
    }

}
int main(){
    int num;
    string str;
    for(int col=1; col<=8; col++)//按顺序搜索八次，分别对应第一行放1～8
        DFS(1,col,str);
//    for(int i=0; i<=91;i++)
//        cout<<vec[i]<<endl;
    while(cin>>num){
        cout<<vec[num-1]<<endl;
    }
    return 0;
}
```



**方法二：**回溯+DFS+全排列（来自算法笔记P118）

全排列自动避免了在同一行或同一列的情况，所以只要保证不在同一对角线就行。

在放置时就检查，如果和前面已经放置的成对角线，则直接回溯。

```
#include <iostream>
#include <vector>
#include <cstdio>
#include <algorithm>
#include <cmath>
#include <cstring>
using namespace std;

vector<string>vs;

bool visited[9];

void solve(string s, int index){//当前字符串，当前排列下标
    if(index==8){
        vs.push_back(s);
        return ;
    }
    else{
        for(int i=1; i<=8; i++){//第index位依次放入1~8
            if(!visited[i]){
                bool flag = true;
                for(int j=0; j<index; j++){
                    if(abs(index-j) == abs(i+'0'-s[j])){//md这里坑死我了， i+'0'-s[j]千万不要写错
                        flag=false;
                        break;
                    }
                }
                if(flag){//如果flag不为true，下面的就不用执行了，直接回溯
                    s[index] = i+'0';
                    visited[i]=true;
                    solve(s, index+1);
                    visited[i]=false;
                }
            }
        }
    }

}


int main(){
    memset(visited, false, sizeof(visited));
    string s(8,' ');
    solve(s, 0);

    int num;

    cin>>num;
    cout<<vs[num-1]<<endl;


    return 0;
}
```



# 数据结构二

## 二叉树

注：二叉树的构建函数一般都是返回的构建完成的子树的根结点。

### 二叉树遍历（根据一种顺序来构建树，输入能判断空节点）

http://t.cn/AiKuUTlX

结构体要记清楚了，而且后面使用的时候都是用指针。

根据xx遍历创建树 和 遍历树 是差不多的。

```
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

string str;
int pos;

struct TreeNode{
    char data;
    TreeNode* leftChild;
    TreeNode* rightChild;
    //构造函数，记下来吧
    TreeNode(char c): data(c),leftChild(NULL),rightChild(NULL){}
};

void InOrder(TreeNode* root){//中序遍历
    if(root==NULL)
        return ;
    InOrder(root->leftChild);
    cout<<root->data<<" ";
    InOrder(root->rightChild);
}

TreeNode* createTree(){//通过前序遍历建立树
    //其实也就三部，和遍历类似：赋值根，递归建立左子树，递归建立右子树
    char c = str[pos++];
    if(c=='#'){
        return NULL;
    }
    TreeNode* root= new TreeNode(c);
    root->leftChild = createTree();
    root->rightChild = createTree();
    return root;
}

void deleteTree(TreeNode* root){//为了释放空间
    if(root==NULL)
        return;
    deleteTree(root->leftChild);
    root->leftChild=NULL;
    deleteTree(root->rightChild);
    root->rightChild=NULL;
    free(root);
}

int main(){
    while(cin>>str){
        pos=0;
        TreeNode* root = createTree();
        InOrder(root);
        cout<<endl;
        deleteTree(root);
    }
    return 0;
}
```



### 二叉树遍历（根据前序、中序构建树，输入不包含空结点）

http://t.cn/AiKgDfLU

分治+递归，每次取前序的第一位，在中序中找到它，并把中序以它为切割点分成两半

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
 
struct TreeNode{
    char data;
    TreeNode* leftChild;
    TreeNode* rightChild;
};
 
int search(string str, char ch){
    for(int i=0; i<str.length();i++){
        if(ch==str[i])
            return i;
    }
    return -1;
}
 
//分治+递归，每次取前序的第一位，在中序中找到它，并把中序以它为切割点分成两半
TreeNode* Create(string PreO, string InO){
    if(PreO.length()==0)
        return NULL;
    TreeNode* root = new TreeNode;
    char ch =PreO[0];//取当前前序第一个ch
    root->data = ch;//赋值
 
    int pos = search(InO, ch);//在中序遍历中找到这个ch，并返回位置
    int leftNumber = pos;//有i个节点在它左边
    int rightNumber = InO.length()-pos -1;//有InO.length()-pos-1个节点在它右边
    string leftInO = InO.substr(0,leftNumber);//从InO[0]到InO[pos-1]
    string rightInO = InO.substr(pos+1);//InO[pos+1]到结尾
    string leftPreO = PreO.substr(1,leftNumber);
    string rightPreO = PreO.substr(pos+1);
 
    root->leftChild = Create(leftPreO, leftInO);
    root->rightChild = Create(rightPreO, rightInO);
 
    return root;
}
 
//后序遍历
void PostOrder(TreeNode* root){
    if(root==NULL)
        return ;
    PostOrder(root->leftChild);
    PostOrder(root->rightChild);
    cout<<root->data;
    return ;
}
 
int main(){
    string pre,in;
    while(cin>>pre){
        cin>>in;
        TreeNode* root = new TreeNode;
        root = Create(pre,in);
        PostOrder(root);
        cout<<endl;
    }
    return 0;
}
```



### 二叉树排序

http://t.cn/Ai9PAkkv

（相似的题 http://t.cn/AiKD0L5V）

递归建树，如果数组值比当前比较结点（代码里的old）大，则看old的右子树，如果右子树为空则插入，否则old指向old自己的右子树。左子树同理。

每次都是从根节点开始比较，先放自己的代码，之后放书本代码。

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
using namespace std;

int n;
int pos;//当前数组下标
struct TreeNode{
    int data;
    TreeNode* leftChild;
    TreeNode* rightChild;
    TreeNode* father;
    TreeNode(int a):data(a),leftChild(NULL),rightChild(NULL),father(NULL){}
};

void Build(TreeNode* root,int* num, int pos){
    if(pos==n)//超出范围了
        return;
    TreeNode* old = root; //初始指向root，用来后面比较
    TreeNode* current = new TreeNode(num[pos]);//为当前数组元素创造结点
    while(true){
        if(current->data>old->data) {
            if (old->rightChild == NULL) {//插入old左子树
                old->rightChild = current;
                current->father = old;
                cout<<old->data<<endl;
                pos++;
                Build(root, num, pos);
                return;
            } else {//否则old指向它的右子树
                old = old->rightChild;
                continue;
            }
        }
        else {
            if (old->leftChild == NULL) {
                old->leftChild = current;
                current->father = old;
                cout<<old->data<<endl;
                pos++;
                Build(root, num, pos);
                return;
            } else {
                old = old->leftChild;
                continue;
            }
        }
    }
}


int main(){
    while(cin>>n){
        int num[100];
        for(int i=0;i<n;i++)
            cin>>num[i];
        TreeNode* root = new TreeNode(num[0]);
        pos=1;
        cout<<-1<<endl;
        Build(root,num,pos);

    }
    return 0;

}
```

书本是在main函数里面用for循环一个一个插入，而且在输入的时候就插入了，很不错。（不过我觉得没我的好理解）

```
#include<iostream>
#include<cstdio>
 
using namespace std;
 
struct TreeNode{
    int data;
    TreeNode* leftChild;
    TreeNode* rightChild;
    TreeNode(int x): data(x),leftChild(NULL),rightChild(NULL){}
};
 
TreeNode* Insert(TreeNode* root,int x,int father){//把这个当成返回一个已经构建好的子树的根结点
    if(root==NULL){
        root = new TreeNode(x);
        cout<<father<<endl;
    }
    else if(x<root->data){
        root->leftChild = Insert(root->leftChild,x,root->data);
    }
    else if(x>root->data){
        root->rightChild = Insert(root->rightChild,x,root->data);
    }
    return root;
}
 
int main(){
    int N;
    int temp;
    TreeNode* root = NULL;
    cin>>N;
    for(int i=0; i<N; i++){
        cin>>temp;
        root = Insert(root,temp,-1);
    }
    return 0;
}
```





## 优先队列

### 复数集合

http://t.cn/Ai98yYlt

优先队列如果不是系统类型（比如自己定义的结构体）的话，需要自己重载运算符。

还有就是使用结构体的构造函数，之前二叉树声明root时经常用new来返回指针。而普通的结构体不要用new

```
#include <iostream>
#include <queue>
#include <cstring>
#include <algorithm>
#include <string>
using namespace std;

struct Complex{
    int real;
    int imag;
    Complex(int a, int b): real(a), imag(b){}
    bool operator< (Complex c) const{//重载运算符
        return real*real + imag*imag < c.real*c.real + c.imag*c.imag;
    }
};

int main(){
    int n;
    while(cin>>n){
        string instruction;
        string ins;
        priority_queue<Complex> priQue;//定义优先队列
        
        for(int i=0; i<n; i++){
            cin>>instruction;
            if(instruction=="Pop"){
                if(priQue.empty())
                    cout<<"empty"<<endl;
                else{
                    Complex current = priQue.top();
                    priQue.pop();
                    cout<<current.real<<"+i"<<current.imag<<endl;
                    cout<<"SIZE = "<<priQue.size()<<endl;
                }
            }
            else{
                cin>>ins;
                int pos= ins.find('+');
                string realstr = ins.substr(0,pos+1);//截取+前面的子串
                string imagstr = ins.substr(pos+2);//截取i后面的子串
                int realnum = std::stoi(realstr);//string转int
                int imagnum = std::stoi(imagstr);
                Complex current = Complex(realnum,imagnum);//这里没有new了，之前二叉树用new是为了返回指针
                priQue.push(current);
                cout<<"SIZE = "<<priQue.size()<<endl;
            }
        }
        
    }
    return 0;
}
```





### 查找第K小数

http://t.cn/AiCu5hcK

题目不难，这里分别写出两种数据结构的解法。

优先队列：

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
using namespace std;

int main(){
    int n;
    while(cin>>n){
        priority_queue<int, vector<int>, greater<int>> que;
        for(int i=0; i<n;i++){
            int temp;
            cin>>temp;
            que.push(temp);
        }
        int k;
        cin>>k;
        int pre=-1;
        int cur;
        while(k){
            cur = que.top();
            que.pop();
            if(cur!=pre)//如果和前一个不一样，再减。
                k--;
            pre=cur;
        }
        cout<<cur<<endl;
    }
    return 0;
}
```



map：（来自评论区）

他这里是把每次的输入都放到key里，然后对应的value设成一样的1。

map自动按key排序。并且遇到相同的key时不会引起size的增加。

妙啊。

```
#include <iostream>
#include <map>
using namespace std;
int main()
{
    int n,i,k,tmp;
    while(cin>>n)
    {
        map<int,int> mmap;
        for(i=0;i<n;++i)
        {
            cin>>tmp;
            mmap[tmp]=1;
        }
        cin>>k;
        auto it=mmap.begin();
        for(;it!=mmap.end()&&k!=1;++it,--k){}
        cout << it->first << endl;
    }
    return 0;
}
```



set

set是一个内部自动有序且不含重复元素的容器。

```
#include <iostream>
#include <cstdio>
#include <set>
using namespace std;

int main(){
    int n;
    while(cin>>n){
        set<int> num;
        for(int i=0; i<n; i++){
            int data;
            cin>>data;
            num.insert(data);
        }
        int k;
        cin>>k;
        set<int>::iterator it = num.begin();
        for(; it!=num.end()&& k!=1; it++, k--){}
        cout<<*it<<endl;
    }
    return 0;
}
```





## 散列表

### 查找学生信息（基本题）

http://t.cn/AiCuVIuY

迭代器挺好用的

```
#include <iostream>
#include <map>
#include <cstdio>
#include <cstdlib>
using namespace std;

int main(){
    int N;
    while(cin>>N){
        map<string, string> stu;
        string num, info;
        for(int i=0; i<N; i++){
            cin>>num;//读取key
            getline(cin, info, '\n');//剩下的字符串通过getline接收
            stu.insert(pair<string, string>(num, info));//也可以直接用stu[num]=info赋值
        }
        int M;
        map<string, string>::iterator it;
        cin>>M;
        string key;
        while(M--){
            cin>>key;
            it = stu.find(key);
            if(it!=stu.end())//找到了。 注意，it->first之后自动有一个空格
                cout<<it->first<<it->second<<endl;
            else
                cout<<"No Answer!"<<endl;
        }
    }
    return 0;
}
```



### 子串计算

http://t.cn/AiCuJtI5

map内部自动按key的字典序排序

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <map>
#include <string>
using namespace std;

int main(){
    string str;
    cin>>str;
    map<string, int> myMap;
    string temp;
    for(int i=0; i<str.size(); i++){
        for(int j=i; j<str.size(); j++){
            temp = str.substr(i, j-i+1);
            myMap[temp]++;
        }
    }
    map<string, int>::iterator it;
    for(it= myMap.begin(); it!=myMap.end(); it++){
        if(it->second>1)
            cout<<it->first<<" "<<it->second<<endl;
    }
    return 0;
}
```



### 开门人和关门人

http://t.cn/AiCuM09f

第一遍我是用vector做的，类型是pair<string, string>，定一个cmp比较函数对vector排序一下输出。 

当时糊涂了以为时间不能按字典序排，就把id放在了第一个参数，也没用map。后来写着写着发现时间之间按string比较大小就能比出来。所以map更方便。

vector代码：

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <map>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

bool cmp1(pair<string, string>a, pair<string, string>b){//升序
    return a.second < b.second;
}

bool cmp2(pair<string, string>a, pair<string, string>b){//降序
    return a.second > b.second;
}


int main(){
    int n;
    while(cin>>n){
        vector<pair<string, string> > come;
        vector<pair<string, string> > leave;
        for(int i=0; i<n; i++){
            string id, cometime, leavetime;
            cin>>id>>cometime>>leavetime;
            come.emplace_back(pair<string, string> (id, cometime));
            leave.emplace_back(pair<string, string> (id, leavetime));
        }
        sort(come.begin(), come.end(), cmp1);
        sort(leave.begin(), leave.end(), cmp2);
        cout<<come[0].first<<" "<<leave[0].first<<endl;
    }
    return 0;
}
```



map代码：

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <map>
#include <string>
#include <algorithm>
using namespace std;


int main(){
    int n;
    while(cin>>n){
        map<string, string> come;
        map<string, string> leave;
        for(int i=0; i<n; i++){
            string id, cometime, leavetime;
            cin>>id>>cometime>>leavetime;
            come[cometime]=id;
            leave[leavetime]=id;
        }
        cout<<come.begin()->second<<" "<<leave.rbegin()->second<<endl;
    }
    return 0;
}
```



### 谁是你的潜在朋友

http://t.cn/AiCux4f7

这一题。。怎么说呢，很简单，但是起初用map做起来很别扭。放了4个for循环，主要是不知道怎么解决 读者-书-书的数量这三个的映射关系。

所以三个变量，用两个映射不就行了？

起初只想了一个map，还做了个count数组放在最后。

但是直接把count放在输入里就递增不就行了？

而且这道题读者编号是顺序的，map和数组没多大区别。

所以2个map或1map+1数组或2数组都可以。

2map：

```
#include<iostream>
#include<cstdio>
#include<map>
 
using namespace std;
 
int main(){
    int n,m;
    while(scanf("%d%d",&n,&m)!=EOF){
        map<int,int> book_num;//map<书编号,人数>
        map<int,int> stu_book;//map<读者号,书编号>
        for(int i=0;i<n;i++){//第i个读者
            int bookNumber;
            scanf("%d",&bookNumber);
            stu_book[i]=bookNumber;//第i个读者喜欢看的书编号为bookNumber；
            book_num[bookNumber]++;//同时把喜欢看书编号为bookNumber的人数+1
        }
        map<int,int>::iterator it;
        for(it=stu_book.begin();it!=stu_book.end();it++){//读者号从0~n-1
            int num=book_num[it->second]-1;//把自己减掉
            if(num==0){
                printf("BeiJu\n");
            }else{
                cout<<num<<endl;
            }
        }
    }
    return 0;
}
```

2数组：

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
 
using namespace std;
 
int main(){
    int n,m;
    cin>>n>>m;
    int reader[201]={0}, book[201]={0};
    for(int i=0;i<n;i++){
        int value;
        cin>>value;
        reader[i]=value;
        book[value]++;
    }
    int num;
    for(int i=0;i<n;i++){
        num = book[reader[i]];
        if(num==1)
            cout<<"BeiJu"<<endl;
        else
            cout<<num-1<<endl;
    }
    return 0;
}
```





# 图论

## 并查集

<font color=red>并查集真的好多地方都能用map啊</font>

### 畅通工程

http://t.cn/AiOvBHj9

并查集入门题。Find()函数包含了路径压缩。

并查集最常用来判断图是否为连通图，或用来求图的连通分量。

```
#include <iostream>
#include <cstdio>
using namespace std;

int MAXN = 1000;
int father[1000];
int height[1000];

int Find(int x){  //寻找节点x的根节点
    if (x!=father[x]){  //说明它不是一个树的根节点
        father[x] = Find(father[x]); //路径压缩
    }
    return father[x];
}

void Union(int x, int y){  //合并两棵树
    x = Find(x);
    y = Find(y);
    if(x==y)  //属于同一棵树，什么都不用做
        return;
    if(height[x]>height[y]){
        father[y] = x;  //y合入x
    }
    else if (height[x] < height[y]){
        father[x] = y;
    }
    else{
        father[y] = x;
        height[x]++;
    }
}


int main(){
    int N, M;
    while(cin>>N && N){
        cin>>M;
        //初始化
        for(int i=1; i<=N; i++){
            father[i] = i;
            height[i] = 0;
        }
        int x,y;
        while(M--){
            cin>>x>>y;
            Union(x, y);
        }
        int single = 0;
        for(int i=1; i<=N; i++){
            if(Find(i) == i)  //这棵树上只有自己一个（第一个节点除外）
                single++;
        }
        cout<<single-1<<endl;
    }
    return 0;
}
```



### <font color=blue>Is it A Tree?</font>

http://t.cn/AiO7FyDO

本来想用并查集做的，做着做着就变成暴力了。。。

通过率从1.x%到2.x%再到12.x%，特殊情况一个一个排除，最后ac了。

特殊情况有：只输入0 0； 输入有自环； 多父亲结点。



**我觉得两个方法可以合并一下，书本上的isTree()函数拿来用，但把数组全部替换成map。有空再说**



**暴力：**

```
#include <iostream>
#include <cstdio>
#include <map>
using namespace std;

int father[10000];
map<int, int>mymap;  //父子结点汇总
map<int, int>tail;  //子结点

void Union(int x, int y){  //合并两棵树
    father[y] = x;
}

int main(){
    int start, end;
    int count = 0;
    int Case = 1;
    bool flag = true;  //如果flag为false则确定不是一棵树（比如自环，多父亲结点等）
    bool noNode = true;  //如果最终为true，则表示输入只为 0 0
    //初始化
    for(int i=0; i<10000; i++){
        father[i] = i;
        mymap.clear();
        tail.clear();
    }
    while(cin>>start>>end){
        if(start==-1 && end==-1)//退出程序
            break;
        else if(start==0 && end==0){//一个测试的末尾，输出结果
            map<int, int>::iterator it;
            for(it=mymap.begin(); it!= mymap.end(); it++){//找出孤立节点
                if(father[it->first]==it->first)
                    count++;
            }
//            cout<<count<<endl;
            if((count==1 && flag) || noNode)  //正确的情况只有：孤立节点为1并且flag为true 以及 只输入0 0 的情况
                cout<<"Case "<<Case<<" is a tree."<<endl;
            else
                cout<<"Case "<<Case<<" is not a tree."<<endl;

            //初始化
            for(int i=0; i<10000; i++){
                father[i] = i;
                mymap.clear();
                tail.clear();
            }
            count =0;
            Case++;
            flag = true;
            noNode = true;
        }
        else{//正常输入
            noNode = false;  //只要有正常输入，不管是不是自环，都已经排除了只输入0 0 的情况
            if(start==end) {  //自环
                flag = false;
                continue;
            }
            mymap[start]=1;
            if(tail[end]==1)  //多父亲结点，立刻判断不是树
                flag = false;
            mymap[end]=1;
            tail[end]=1;
            Union(start, end); //合并，其实就一步
        }
    }
    return 0;
}
```

**并查集（书本）：**

```
#include <iostream>
#include <cstdio>
using namespace std;

const int MAXN=10000;

int father[MAXN];
int height[MAXN];
int inDegree[MAXN]; //入度
bool visit[MAXN];

void Initial(){
    for(int i=0; i<MAXN; i++){
        father[i] = i;
        height[i] = 0;
        inDegree[i] = 0;
        visit[i] = false;
    }
}

int Find(int x){
    if(x!=father[x])
        father[x] = Find(father[x]);
    return father[x];
}

void Union(int x, int y){
    x = Find(x);
    y = Find(y);
    if(x!=y){
        if(height[x]<height[y])
            father[x] = y;
        else if(height[y] < height[x])
            father[y] = x;
        else{
            father[y] = x;
            height[x]++;
        }
    }
    return ;
}

bool isTree(){
    bool flag = true; //初始化是个树
    int terminal = 0;  //父亲结点是自己的结点数
    int root = 0; //入度为0的个数
    for(int i=0; i<MAXN; i++){
        if(!visit[i])
            continue;
        if(father[i]==i)
            terminal++;
        if(inDegree[i]==0)
            root++;
        else if (inDegree[i]>1)
            flag = false;
    }

    if(terminal !=1 || root!=1)//不是树
        flag = false;
    if(terminal ==0 && root==0) //空集是树
        flag = true;
    return flag;
}

int main(){
    int x,y;
    int Case = 1;
    Initial();
    while(cin>>x>>y){
        if(x==-1 && y==-1)
            break;
        if(x==0 && y==0){//结束当前Case
            //输出结果
            if(isTree())
                cout<<"Case "<<Case<<" is a tree."<<endl;
            else
                cout<<"Case "<<Case<<" is not a tree."<<endl;
            Case++;
            //重新初始化
            Initial();
        }
        else{//正常输入
            Union(x,y);
            inDegree[y]++;
            visit[x] = true;
            visit[y] = true;
        }
    }
    return 0;
}
```



### 找出直系亲属

http://t.cn/AiOzTX5c

（别人的并查集解法我还没看）

自从学了map之后就不想用数组了。。。 

输入阶段给的输入数据三个字母，用map<char, string>分别存储第一个（孩子）和后两个（家长）。 

在判断关系时，先假设一个辈分比较大，DFS搜索。如果没有结果再假设另一个辈分大，再DFS。

```
#include <iostream>
#include <cstdio>
#include <map>
#include <cstring>
using namespace std;

map<char, string> parents;

int search(char a, char b, int level){//level表示当前的辈分级数，初始为0表示平辈
    int res;
    if(a==b)  //找到了
        return level;
    if(!a|| a=='-'){
        return -1;  //表示找到尽头了没找到
    }
    if(a!=b){
        res = search(parents[a][0], b, level+1);//先拿a的第一个家长和b比较
        if(res>0)
            return res;
        else
            res = search(parents[a][1], b, level+1);//拿a的第二个家长和b比较
        return res;
    }
}

int main(){
    int n,m;
    while(cin>>n>>m){
        parents.clear();
        string str;
        for(int i=0; i<n; i++){
            cin>>str;
            string parstr = str.substr(1,2);
            parents[str[0]] = parstr;
        }
        for(int j=0; j<m; j++){
            cin>>str;
            char a = str[0];
            char b = str[1];
            int res = search(a,b,0);  //假设b的辈分比a大
            if(res>0){//a的辈分小
                //输出结果
                string rank="";
                if(res==1) rank="child";  //b比a大一辈
                else if(res==2) rank="grandchild";//b比a大2辈
                else{
                    rank = "grandchild";
                    for(int base = 3; base<=res; base++)
                        rank = "great-"+rank;
                }
                cout<<rank<<endl;
                continue;
            }
            else  //假设a的辈分比b大
                res = search(b,a,0);
            if(res>0){//a的辈分大
                //输出结果
                string rank="";
                if(res==1) rank="parent";
                else if(res==2) rank="grandparent";
                else{
                    rank = "grandparent";
                    for(int base = 3; base<=res; base++)
                        rank = "great-"+rank;
                }
                cout<<rank<<endl;
            }
            //没有直系关系
            else cout<<"-"<<endl;
        }
    }
    return 0;
}
```



### <font color=orange>第一题__</font>

http://t.cn/AiOhkgMJ

并查集的板子题，map真tm好用。

<font color=red>但是我运行的时间和内存都很大，有空找找原因</font>

```
#include <iostream>
#include <cstdio>
#include <map>
using namespace std;

map<int, int> father;
map<int, int> height;

int Find(int x){
    if(father[x]==0){
        father[x] = x;
    }
    else if(father[x]!=x){
        father[x] = Find(father[x]);
    }

    return father[x];
}

void Union(int x, int y){
    x = Find(x);
    y = Find(y);
    if(x!=y){
        if(height[x]<height[y])
            father[x] = y;
        else if(height[y] < height[x])
            father[y] = x;
        else{
            father[y] = x;
            height[x]++;
        }
    }
    return ;
}

int main(){
    int i,j;
    while(cin>>i>>j &&i&&j){
        Union(i,j);
    }
    map<int, int>::iterator it;
    int count = 0;
    for(it=father.begin(); it!=father.end(); it++){
        if(it->first!=0) {
//            cout << it->first << "   " << it->second << endl;
            if (it->first == it->second)
                count++;
        }
    }
    cout<<count<<endl;
    return 0;
}
```





### <font color=red>Head of gangs</font>

头秃，这道题写了两天。

需要注意的地方是： 

1.  系统输入有问题，它输入的是单个字母作为一个人。所以代码里应该用空格划分 
2.  输入的k是帮派总权重的阈值，我一开始理解错了理解成了帮派头目的权重大于k才行。其实应该是帮派总权重大于k 
3.  我一开始是用一个临时头目来存储整个帮派的人数和总权重（所以只有临时头目对应的人数和总权重是真的，其他的都是假的）。然后等输入结束后再把这个头目更新。 

还有，判断key值是否有对应的value，别用初始值检测了，用下面这个：

https://blog.csdn.net/Leo_csdn_/article/details/85066264

```
#include <iostream>
#include <cstdio>
#include <map>
#include <cstring>
#include <algorithm>
using namespace std;

map<string, string> up;  //(个人, 临时头目)
map<string, int>weight;  //(个人, 个人权重)
map<string, int>cluster;  //(个人, 本帮派人数)  仅有临时头目对应的是真实的
map<string, int>clusterweight;  //(临时头目, 帮派权重)
map<string, int>chosen;  //(临时头目, 人数)
map<string, string>newHeader;  //(临时头目, 最终头目)
map<string, int>chosen2;//(最终头目, 人数)



//找到临时头目
string Find(string x){
    if(up.find(x)== up.end())
        up[x]= x;
    if(up[x]!=x){
        up[x] = Find(up[x]);//路径压缩
    }
    return up[x];
}

//这个合并的结果，每个帮派的根可能并不是权重最大的
void Union(string x, string y, int num){
    string fx = Find(x);
    string fy = Find(y);
    if(fx!=fy){  //来自不同的帮派
        if(weight[fx]<weight[fy]){
            up[fx]=fy;  //头目归属
            //帮派人数、总权重合并
            cluster[fy]+=cluster[fx];
            clusterweight[fy]+=clusterweight[fx];
            clusterweight[fy]+=num;
        }
        else{
            up[fy]=fx;
            cluster[fx]+=cluster[fy];
            clusterweight[fx]+=clusterweight[fy];
            clusterweight[fx]+=num;
        }
    }
    else{
        //同一个帮派只要增加总权重
        clusterweight[fx]+=num;
    }
}

int main(){
    int n,k;
    while(cin>>n>>k){
        //初始化
        up.clear();
        weight.clear();
        cluster.clear();
        chosen.clear();
        newHeader.clear();
        chosen2.clear();
        clusterweight.clear();

        getchar();  //结尾的换行符
        string str;
        string x, y, num;
        for(int i=0; i<n;i++){
            getline(cin, str, '\n');
            int pos = str.find(' ');  //第一个空格
            x = str.substr(0,pos);
            int pos2 = str.rfind(' ');  //反向查找第一个空格
            y = str.substr(pos+1, pos2-pos-1);
            num = str.substr(pos2+1);
            weight[x]+=std::stoi(num);  //string 转int
            weight[y]+=std::stoi(num);
            //如果是新来的，先初始化一下cluster
            if(cluster[x]==0) cluster[x]=1;
            if(cluster[y]==0) cluster[y]=1;
            Union(x,y,std::stoi(num));
        }
        map<string, string>::iterator it;
        //把所有的都压缩一遍
        for(it=up.begin(); it!=up.end(); it++){
            Find(it->first);
        }

//        for(it=up.begin(); it!=up.end(); it++) {
//            cout<<it->first<<" "<<it->second<<" "<<weight[it->first]<<" "<<cluster[it->second]<<clusterweight[it->second]<<endl;
//        }

        //到这一步，帮派已经划分完毕，先筛选人数和权重上符合条件的帮派，并把头目放到chosen里
        map<string, int>::iterator it2;
        for(it=up.begin(); it!=up.end(); it++){
            if(it->second == it->first && cluster[it->first] >2 && clusterweight[it->first] >k){//“头目”
                chosen[it->first] = cluster[it->first];
            }
        }

//        for(it2=chosen.begin(); it2!=chosen.end(); it2++){
//            cout<<it2->first<<" "<<it2->second<<" "<<weight[it2->first]<<endl;
//        }

        //更新头目，放到chosen2里
        for(it2=chosen.begin(); it2!=chosen.end(); it2++){
            string tempheader = it2->first;
            int clusternum = it2->second;
            newHeader[tempheader]=tempheader;  //初始化最终头目是临时头目
            //对于所有头目为临时头目的成员，选取个人权重最大的当作最终头目
            for(it=up.begin(); it!=up.end(); it++) {
                if (it->second == tempheader) {
                    if (weight[it->first] > weight[newHeader[tempheader]]) {
                        newHeader[tempheader] = it->first;
                    }
                }
            }
            chosen2.insert(pair<string, int>(newHeader[tempheader], clusternum));
        }

//        map<string, int>::iterator itt;
//        for(itt=chosen2.begin(); itt!=chosen2.end(); itt++){
//            cout<<itt->first<<" "<<itt->second<<endl;
//        }
        //输出
        cout<<chosen2.size()<<endl;
        map<string, int>::iterator itt;
        for(itt=chosen2.begin(); itt!=chosen2.end(); itt++){
            cout<<itt->first<<" "<<itt->second<<endl;
        }
    }
    return 0;
}
```



## 最小生成树

Kruskal算法步骤：

1. 初始时所有顶点属于孤立的集合
2. 按照<font color=red>边权递增顺序</font>遍历所有边，若遍历到的边的两个顶点仍分属不同的集合，则确定该边为最小生成树上的一条边并将该边两个顶点分属的集合合并
3. 遍历完所有边后，若原图连通，则被选取的边和所有顶点构成最小生成树；若原图不连通，最小生成树不存在。



### 还是畅通工程

并查集+Kruskal算法。 

我本来是用map.size()==n来判断是否全部连通的，但是在系统用例n=50那个过不去，而且系统的输入也没给全，不知道为啥。后来改成了cluster计数，每一次不同类的Union都cluster++，因为最后肯定只剩一类，所以只要cluster==n-1即可。

下面是<font color=blue>能过的</font>，用map+Kruskal

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <map>

using namespace std;

map<int, int>father;
struct edge{
    int v1;
    int v2;
    int distance;
};

int minLength = 0;  //结果
int cluster = 0;  //当前集群数目

int Find(int a){
    if(father.find(a)==father.end()){
        father[a] = a;
    }
    if(father[a]!=a){
        father[a] = Find(father[a]);
    }
    return father[a];
}

void Union(int a, int b, int num){
    a = Find(a);
    b = Find(b);

    if(a!=b){
        father[b] = a;
        minLength+=num;
        cluster++;
    }
}

bool cmp(edge a, edge b){
    return a.distance<b.distance;//根据distance升序
}

int main(){
    int n,m;
    while(cin>>n&&n){
        getchar();
        m = n*(n-1)/2;  //输入数
        father.clear();
        edge e[4550];

        minLength=0; //最小长度
        cluster = 0;
        for(int i=0; i<m; i++){
            cin>>e[i].v1>>e[i].v2>>e[i].distance;
        }
        sort(e, e+m, cmp);
        for(int i=0; i<m; i++){
            if(cluster==n-1)
                break;
            Union(e[i].v1, e[i].v2, e[i].distance);
        }
        cout<<minLength<<endl;
    }
    return 0;
}
```

下面是<font color=red>过不了的</font>：

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <map>

using namespace std;

map<int, int>visit;
struct edge{
    int v1;
    int v2;
    int distance;
};

bool cmp(edge a, edge b){
    return a.distance<b.distance;//根据distance升序
}

int main(){
    int n,m;
    while(cin>>n&&n){
        getchar();
        m = n*(n-1)/2;  //输入数
        visit.clear();
        edge e[4550];

        int minLength=0; //最小长度
        for(int i=0; i<m; i++){
            cin>>e[i].v1;
            cin>>e[i].v2;
            cin>>e[i].distance;
        }
        sort(e, e+m, cmp);
        int v1, v2, distance;
        for(int i=0; i<m; i++){
            if(visit.size()==n)
                break;
            v1 = e[i].v1;
            v2 = e[i].v2;
            distance = e[i].distance;
            if(visit[v1]!=1){
                visit[v1]=1;
                minLength+=distance;
                if(visit[v2]!=1){
                    visit[v2]=1;
                }
                continue;
            }
            else if(visit[v2]!=1){
                visit[v2]=1;
                minLength+=distance;
            }
        }
        cout<<minLength<<endl;
    }
    return 0;
}
```



### Freckles

http://t.cn/AiW3Hbqr

不难，练手。先计算每个结点间的距离，再kruskal。

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <map>
#include <cmath>
using namespace std;

map<int, int>father;
double cost;  //总代价
int cluster; //当前集群大小

struct Edge{
    int v1;
    int v2;
    double len;
};

struct Node{
    double x;
    double y;
};


int Find(int x){
    if(father.find(x)==father.end()){
        father[x]=x;
    }
    if(father[x]!=x){
        father[x]=Find(father[x]);
    }
    return father[x];
}

void Union(int x, int y, double len){
    x = Find(x);
    y = Find(y);
    if(x!=y){
        father[y] = x;
        cost+= len;
        cluster++;
    }
}

bool cmp(Edge x, Edge y){
    return x.len<y.len;
}

int main(){
    int n;
    while(cin>>n && n){
        cost = 0;
        cluster = 1;
        father.clear();
        Node node[101];
        Edge e[4551];
        //输入所有结点
        for(int i=0; i<n; i++){
            cin>>node[i].x>>node[i].y;
        }
        int k=0;
        //计算每个结点间的距离，放在边中
        for(int i=0; i<n; i++){
            for(int j=i+1; j<n; j++){
                e[k].v1 = i;
                e[k].v2 = j;
                double xdis = (node[i].x-node[j].x)*(node[i].x-node[j].x);
                double ydis = (node[i].y-node[j].y)*(node[i].y-node[j].y);
                e[k].len = sqrt(xdis+ydis);
                k++;
            }
        }
        //排序
        sort(e, e+k, cmp);
        for(int i=0; i<k; i++){
            if(cluster==n)
                break;
            Union(e[i].v1, e[i].v2, e[i].len);
        }
        //保留两位小数
        printf("%.2f\n",cost);
    }
    return 0;

}
```



## 最短路径

### <font color=red>畅通工程续</font>

**可以当作板子。**

https://vjudge.net/problem/HDU-1874

对书上的代码<font color=red>改进了一下</font>

设置了visit，松弛的时候，**如果末端结点在始端之前加入集合，那这条边不用松弛**。（即dis[v] > dis[u]+d一定不成立）

（事实证明我加了个visit是多余的，但是我觉得这样好理解）

```
#include <iostream>
#include <cstdio>
#include <vector>
#include <cstring>
#include <queue>
#include <climits>
#include <algorithm>
#include <map>
using namespace std;

const int MAXN = 200;
const int INF  = INT_MAX;

map<int, int> visit;

struct Edge{
    int to;  //终点
    int length;  //长度
    Edge(int t, int l ): to(t), length(l){}
};

struct Point{
    int number; //当前结点编号
    int distance;  //源点到该点的距离
    Point(int n, int d): number(n), distance(d){}
    bool operator< (const Point& p) const{
        return distance > p.distance;  //距离小的优先级高
    }
};

vector<Edge> graph[MAXN];  //每个结点维护一个元素类型为Edge的vector向量，用于存放与该点相连的边
int dis[MAXN];  //源点到各点的距离

void Dijkstra(int s){
    priority_queue<Point> pq;  //优先队列，元素类型为Point，运算符已重载，距离小的结点优先级高
    dis[s]=0; //源点到自己的距离为0
    pq.push(Point(s, dis[s]));  //先把自己放进去
    while(!pq.empty()){
        Point temp = pq.top();
        pq.pop();
        int u = temp.number;
        if(visit.find(u)!=visit.end())  // 如果已经在集合里，则跳过
            continue;
        visit[u]=1;
        dis[u] = temp.distance;

        for(int i=0; i<graph[u].size(); i++){
            int v = graph[u][i].to;
            int d = graph[u][i].length;
            if(dis[v] > dis[u]+d){  //如果dis(s,v) < dis(s,u) + dis(u,v)
                dis[v] = dis[u] + d;
                pq.push(Point(v, dis[v]));  //把结点v放进去
            }
        }
    }
}


int main(){
    int n, m;
    while(cin>>n>>m && n && m){
        visit.clear();
        memset(graph, 0, sizeof(graph)); //初始化所有临接表
        fill(dis, dis+n, INF);
        while(m--){
            int from, to, length;
            cin>>from>>to>>length;
            graph[from].push_back(Edge(to, length));
            graph[to].push_back(Edge(from, length));
        }
        int s, t;
        cin>>s>>t;
        Dijkstra(s);
        if(dis[t]==INF){
            dis[t]=-1;
        }
        cout<<dis[t]<<endl;
    }
    return 0;
}
```



### <font color=blue>最短路径问题</font>

http://t.cn/AilPbME2

Dijkstra算法。上面“畅通工程（续）”的拓展版。 	


畅通工程（续）只考虑最短路径，所以用Dijksra+优先队列，每次取最近的结点加入集合，并松弛每条边。 	

本题引入了代价（花费），但问题不大，只要再开个cost数组就行。 	

需要注意的是，两个结点可能有多条边相连，所以对每条边的信息用结构体存储是比较合适的。

```
#include <iostream>
#include <map>
#include <cstdio>
#include <queue>
#include <algorithm>
#include <vector>
#include <climits>
#include <cstring>
using namespace std;

const int MAXN = 1001;
const int INF = INT_MAX;

map<int, int>visit;  //visit
struct Edge{
    int to;  //目的点
    int length; //长度
    int price; //花费
    Edge(int t, int l, int p): to(t), length(l), price(p) {}
};

struct Point{
    int number; //点的编号
    int distance; //距离源点的总距离
    int pay;  //源点到此点的总代价
    Point(int n, int d, int p): number(n), distance(d), pay(p){}
    //距离小的优先，距离一样则花费小的优先
    bool operator< (const Point& p) const{
        if (distance != p.distance)
            return distance > p.distance;  //距离小的优先级高
        else{
            return pay > p.pay; //距离一样的，花费小的优先
        }
    }
};


vector<Edge>graph[MAXN];
int dis[MAXN];//到源点距离
int cost[MAXN];//到源点代价

void Dijkstra(int s){
    priority_queue<Point> pq;  //优先队列
    dis[s]=0; cost[s]=0;
    pq.push(Point(s, dis[s], cost[s]));
    while(!pq.empty()){
        Point temp = pq.top();
        pq.pop();
        int u = temp.number;
        if(visit.find(u)!=visit.end()){  //如果被访问过（已被加入集合），直接跳过
            continue;
        }
        visit[u]=1;
        dis[u]=temp.distance;
        cost[u]= temp.pay;
//        cout<<u<<" ########## "<<dis[u]<<" "<<cost[u]<<endl;
        //松弛当前结点所连接的所有边
        for(int i=0; i<graph[u].size(); i++){
            int v = graph[u][i].to;
            int d = graph[u][i].length;
            int p = graph[u][i].price;
//            cout<<"("<<u<<","<<v<<")"<<" "<<d<<" "<<p<<" disV: "<<dis[v]<<" dis[u]+d: " <<dis[u]+d<<endl;
            if(dis[v]>dis[u]+d){//有更短的路
                dis[v] = dis[u]+d;
                cost[v] = cost[u]+p;  //这里别忘了更新
                pq.push(Point(v, dis[v], cost[v]));
            }
            else if(dis[v]==dis[u]+d && cost[v] > cost[u]+p){//长度相同但代价更小
                cost[v] = cost[u]+p;
                pq.push(Point(v, dis[v], cost[v]));
            }
        }
    }
}

int main(){
    int n,m;
    while(cin>>n>>m && n &&m){
        visit.clear();
        memset(graph, 0, sizeof(graph)); //初始化所有临接表
        fill(dis, dis+MAXN, INF);//初始化到所有点距离为INF
        fill(cost, cost+MAXN, INF);//初始化到所有点代价为INF
        int a,b,d,p; //点a，点b，长度d，花费p
        int s,t; //起点，终点
        for(int i=0; i<m; i++){
            cin>>a>>b>>d>>p;
            graph[a].push_back(Edge(b,d,p));
            graph[b].push_back(Edge(a,d,p));
        }
        cin>>s>>t;
        Dijkstra(s);
        if(dis[t]==INF){
            dis[t]=-1;
            cost[t]=-1;
        }
        cout<<dis[t]<<" "<<cost[t]<<endl;
    }
    return 0;
}
```



### <font color=red>最短路径</font>

http://t.cn/AilPKHTx

<font color=red>评论区说还有用最小生成树的方法，有时间去看看</font>

这道题数字太大了，一般的快速幂也不行。只能用字符串快速幂。

评论区的代码加了点注释。

这道题的特殊数据值，字符串加法很有亮点。

```
#include<iostream>
#include<algorithm>
#include<queue>
#include<cstring>
#include<vector>
using namespace std;
const int MAXN = 300;
struct Edge{
    int to;
    string  length;
    Edge(int t, string l): to(t), length(l) {}
    bool operator < (Edge c) const{
        return length < c.length;
    }
};

struct Point{
    int number;
    string distance;
    Point(int n, string d) : number(n), distance(d) {}
    bool operator<(Point c)const{
        return distance > c.distance;
    }
};

string dis[MAXN];       //源点到其他点的距离
int cost[MAXN];
vector<Edge> graph[MAXN];
priority_queue<Point> pq;     //用于筛选最短距离的点

//二进制表示2^u
string chart(int u){
    string s;
    s.insert(0, 502, '0');//这里使用固定长度，则接下来运算的时候就不用再对齐了
    s[s.size()-1-u] = '1';
    return s;
}


string adds(string a, string b){ //字符串加法
    string s;
    for (int i = 0; i < a.size(); i++)
        //因为每条路用二进制表示只有1位是1，且各路都不相同，所以只要不是往返走一条路，就不会出现某位>=1的情况
        //而我们知道，不可能存在往返
        s.append(1, (a[i] - '0' + b[i] - '0')+'0');
    return s;
}

int atois(string s){   //快速幂取模
    int ans=0;
    int front = 1;
//    cout<<s<<endl;
    for (int i = s.size()-1; i>=0; i--){
        if (s[i] == '1'){
            ans += front;
            ans = ans % 100000;
        }
        front = (front * 2) % 100000;
    }
    return ans;
}


void Dijkstra(int start){     //最短路径
    dis[start][0] = '0';
    pq.push(Point(start,dis[start]));
    while (!pq.empty()){
        int u = pq.top().number;
        pq.pop();
        
        for (int i =0 ; i < graph[u].size(); i++){
            int v = graph[u][i].to;
            string newLength = adds(dis[u], graph[u][i].length);

            if (dis[v] > newLength ){
//                cout<<newLength<<endl;
                dis[v] = newLength;
                pq.push(Point(graph[u][i].to, dis[graph[u][i].to]));
            }
        }
    }
}

void Initial(){
    for(int i = 0; i < MAXN; i++)
        dis[i] = chart(501);  // 1000...000
    dis[0][0] = '0';
}

int main(){
    int n, m;
    int a, b;
    while (cin>>n>>m){
        Initial();
        for (int i = 0; i < m; i++){
            cin>>a>>b;
            graph[a].push_back(Edge(b,chart(i)));
            graph[b].push_back(Edge(a,chart(i)));
        }
        Dijkstra(0);
        for (int i = 1; i < n; i++){
            if (dis[i] == chart(501))
                cout << "-1" << endl;
            else
                cout << atois(dis[i])<<endl;
        }
    }
}
```



### I Wanna Go Home

先使用Dijkstra计算相同阵营的城市间的最短路径（源点分别是1，2），结果分别在数组t1[], t2[]中

然后G[i][j]在此前已经输入，这里令i全为阵营1里的城市，j全为阵营2里的城市

则需要求的是 t1[i] + G[i][j] + t2[j]的最小值

```
#include <iostream>
#include <cstdio>
#include <vector>
#include <cstring>
#include <queue>
#include <climits>
#include <algorithm>
#include <map>
using namespace std;

const int MAXN = 601;
const int INF  = INT_MAX;

map<int, int> visit;
map<int, int> side1;
map<int, int> side2;
int camp[MAXN]; //阵营，取值为1或2
int G[MAXN][MAXN];  //代价图，G[i][j]表示城市i到城市j的时间代价
int t1[MAXN];  //城市1到同阵营的最短时间
int t2[MAXN];  //城市2到同阵营的最短时间
int n, m;
int minTime;  //最小时间


struct Point{
    int number;  //节点编号
    int dis;  // 到源点的距离（时间）
    Point(int n, int d): number(n), dis(d){}
    bool operator< (const Point& p) const{
        return dis > p.dis;
    }
};

void Dijkstra(int t[], int side){ //计算阵营为side的最短时间
    priority_queue<Point> pq;  //优先队列
    t[side] = 0;
    pq.push(Point(side, t[side]));  //源点入队
    while(!pq.empty()){
        Point temp = pq.top();
        pq.pop();
        //其实可以取消visit，因为先加入集合的点不会被后面的点松弛
        if(visit[temp.number])
            continue;
        int u = temp.number;
        t[u] = temp.dis;
        visit[u] =1;
        for(int i=1; i<=n ;i++){
            if(G[u][i]!=INT_MAX && camp[i]==side){//如果有路并且是同一阵营
                int roadTime = G[u][i];
                if(t[i] > t[u]+roadTime){
                    t[i] = t[u]+roadTime;
                    pq.push(Point(i,t[i]));
                }
            }
        }
    }
}

int main(){
    while(cin>>n>>m && n && m){
        //初始化各参数
        minTime = INT_MAX;
        memset(camp, 0, sizeof(camp));//初始化阵营全为0
        visit.clear();
        side1.clear();
        side2.clear();
        fill(t1, t1+MAXN, INT_MAX);
        fill(t2, t2+MAXN, INT_MAX);
        //初始化代价图
        for(int i=0; i<MAXN; i++){
            for(int j=0; j<MAXN; j++){
                if(i==j)
                    G[i][j]=0;
                else
                    G[i][j]=INT_MAX;
            }
        }
        //输入数据
        for(int i=0; i<m;i++){
            int v1, v2, roadTime;
            cin>>v1>>v2>>roadTime;
            if(roadTime<G[v1][v2]){
                G[v1][v2] = roadTime;
                G[v2][v1] = roadTime;
            }
        }
        //站队
        for(int i=1; i<=n; i++){
            cin>>camp[i];
            if(camp[i]==1)
                side1[i]=1;
            else side2[i]=1;
        }
        //计算1和2到其阵营的最短路径
        Dijkstra(t1, 1);
        Dijkstra(t2, 2);

        //找出最小的 t1[i] + G[i][j] + t2[j]
        map<int, int>::iterator it1;
        map<int, int>::iterator it2;
        for(it1=side1.begin(); it1!=side1.end(); it1++){
            if(t1[it1->first]==INT_MAX)
                continue;
            for(it2=side2.begin(); it2!=side2.end(); it2++){
                if(t2[it2->first]==INT_MAX)
                    continue;
                if(G[it1->first][it2->first]!=INT_MAX){
                    int curTime = t1[it1->first]+ G[it1->first][it2->first]+t2[it2->first];
                    if(minTime> curTime)
                        minTime = curTime;
                }
            }
        }
        if(minTime == INT_MAX)
            minTime = -1;
        cout<<minTime<<endl;
    }
    return 0;
}
```



## 拓扑排序

## 关键路径



# 动态规划

## 递推求解

### N阶楼梯上楼问题

 http://t.cn/Aij9Fr3V 

斐波那契水题，但是评论区好像有非斐波那契解法。

```
#include <iostream>
#include <cstdio>
using namespace std;

const int MAXN= 91;
long long dp[MAXN];
int main(){
    dp[0]=1;
    dp[1]=1;
    for(int i=2; i<MAXN; i++){
        dp[i] = dp[i-1] + dp[i-2];
    }
    int n;
    while(cin>>n && n){
        cout<<dp[n]<<endl;
    }
    return 0;
}
```

​	

## 最大连续子序列和

### 最大序列和

 http://t.cn/AiYSlQMU 

状态转移方程 
$$
dp[i] = \max(A[i], dp[i-1]+A[i])
$$

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
using namespace std;
const int MAXN = 1000001;

long long arr[MAXN];
long long dp[MAXN];
int n;

long long maxSubsequence(){
    long long maxSum = arr[0];
    for(int i=0; i<n; i++){
        if(i==0)
            dp[i]=arr[0];
        else{
            dp[i] = max(arr[i], dp[i-1]+arr[i]);
        }
        maxSum = max(maxSum, dp[i]);
    }
    return maxSum;
}

int main(){
    while(cin>>n){
        memset(arr, 0, sizeof(arr));
        memset(dp, 0, sizeof(dp));
        for(int i=0; i<n; i++){
            cin>>arr[i];
        }
        long long answer = maxSubsequence();
        cout<<answer<<endl;
    }
    return 0;
}
```

### 最大子矩阵

https://www.nowcoder.com/questionTerminal/a5a0b05f0505406ca837a3a76a5419b3 

假设原二维矩阵中最大子矩阵所在的行是从i到j，那么只会出现下面这两种情况：

1. 当 i == j 时，求最大子矩阵和就转换成了求第i行元素的最大连续子序列和
2. 当 i != j 时，把从第i行到第j行的所有行的元素加起来，得到只有一行的一维数组，这个一维数组的最大连续子序列和便是最大子矩阵和。

只需要从小到大枚举并依次遍历i和j，接着输出所有子矩阵中的最大值。

事先用一个辅助二维矩阵记录原始矩阵从上到下加起来的累加矩阵，在求第i行到第j行的一维数组只需要相减就行。

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <climits>
using namespace std;
const int MAXN = 100;
 
int arr[MAXN][MAXN];    //数据
int sum[MAXN][MAXN];  //前n行的和
int temp[MAXN];
int dp[MAXN];
 
//最大连续子串序列和
int MaxSubSequence(int n){
    int maxSum = INT_MIN;
    for(int i=0; i<n; i++){
        if(i==0){
            dp[i] = temp[i];
        }
        else{
            dp[i] = max(temp[i], dp[i-1]+ temp[i]);
        }
        maxSum = max(maxSum, dp[i]);
    }
    return maxSum;
}
 
//最大子矩阵
int MaxSubMatrix(int n){
    int maxSum = INT_MIN;
    for(int i=0; i<n; i++){
        for(int j=i; j<n; j++){
            if(j==i){
                for(int k=0; k<n; k++){
                    temp[k] = arr[i][k];
                }
            }
            else{
                for(int k=0; k<n; k++){
                    temp[k] = sum[j][k] - sum[i-1][k];
                }
            }
            maxSum = max(maxSum, MaxSubSequence(n));
        }
    }
    return maxSum;
}
 
int main(int argc, char** argv) {
    int n;
    while(cin>>n){
        memset(arr, 0, sizeof(arr));
        memset(sum, 0, sizeof(sum));
        memset(temp, 0, sizeof(temp));
        memset(dp, 0, sizeof(dp));
        int result = 0;
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                cin>>arr[i][j];
                if(i==0){
                    sum[i][j] =  arr[i][j];
                }
                else{
                    sum[i][j] = sum[i-1][j] + arr[i][j];
                }
            }
        }
        result = MaxSubMatrix(n);
        cout<<result<<endl;
    }
     
    return 0;
}

```



### 最大连续子序列

http://t.cn/AiYoUkjP 

把以前的int dp[]换成结构体类型的数组。

结构体的参数为 当前值num，首字符下标firstI，末尾字符下标lastI

在计算当前和的时候根据不同情况选择放弃前面的和或是借用前面的和。

等dp计算完了，再求最大的dp[i].num，赋值给最大和，此时的dp[i].firstI和dp[i].lastI就是对应的下标。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <climits>
#include <cstring>
using namespace std;

const int MAXN = 10000;
struct node{
    int num;  //数值
    int firstI;  //首字符下标
    int lastI;  //末尾下标
};

int n;
int arr[MAXN];
node dp[MAXN];
int firstIndex;  //最终首字符下标
int lastIndex;  //最终末尾下标

int MaxSubSequence(){
    int maxSum = INT_MIN;
    for(int i=0; i<n; i++){
        //初始化
        if(i==0){
            dp[i].num = arr[i];
            dp[i].firstI = i;
            dp[i].lastI = i;
        }
        else{
            //计算dp
            int tempSum = dp[i-1].num + arr[i];
            if(arr[i]> tempSum){//放弃前面的和
                //将firstI和lastI 都赋值成自己下标
                dp[i].num = arr[i];
                dp[i].firstI = i;
                dp[i].lastI = i;
            }
            else{ //继承前面的firstI，并将lastI更新成自己的下标
                dp[i].num = tempSum;
                dp[i].firstI = dp[i-1].firstI;
                dp[i].lastI = i;
            }
        }
    }
    //找出最大的和，并对全局变量firstIndex和lastIndex赋值
    for(int i=0; i<n; i++){
        if(maxSum < dp[i].num){
            firstIndex = dp[i].firstI;
            lastIndex = dp[i].lastI;
            maxSum = dp[i].num;
        }
    }
    return maxSum;
}

int main(){
    while(cin>>n && n){
        int maxSum;
        int neg = 0;  //负数数量
        memset(arr, 0, sizeof(arr));
        for(int i=0; i<n; i++){
            cin>>arr[i];
            if(arr[i]<0)
                neg++;
        }
        if(neg == n){  //如果全为负数
            maxSum = 0;
            firstIndex = 0;
            lastIndex = n-1;
        }
        else
            maxSum = MaxSubSequence();
        cout<<maxSum<<" "<<arr[firstIndex]<<" "<<arr[lastIndex]<<endl;
    }
    return 0;
}
```



## 最长递增子序列(LIS)

问题描述的是在一个已知序列$\{A_1, A_2, ···, A_n\}$中，取出若干元素（不必连续）组成一个新的序列$\{A_x, ···, A_y\}$，新序列中的各个数之间依旧保持原序列中的先后顺序。 

若对该子序列中的任意下标$x<y$有$A_x < A_y$，则称该子序列为原序列的一个递增子序列。最长递增子序列问题就是求给定序列的所有递增子序列中最长的那个子序列长度。



首先设置一个数组dp[]，令dp[i]表示以A[i]作为末尾的最长递增子序列的长度。则只有以下两种情况

- A[i]之前的元素都比A[i]大，即最长递增子序列只有A[i]本身，即dp[i] = 1
- A[i]之前的元素A[j]比A[i]小，此时只需将A[i]添加到以A[j]作为末尾的递增子序列，便能构成一个新的递增子序列。dp[i] = dp[j] +1。 **于是将i之前的元素逐一遍历，便可以获得以A[i]作为末尾的最长递增子序列的长度dp[i]**

从这两种情况可以得到状态转移方程
$$
dp[i] = \max \{1, dp[j]+1 \quad | \quad j<i \quad \text{&&} \quad A_j < A_i \}
$$
**dp记得初始化为1**



### 最大上升子序列和

http://t.cn/AiYNAGD3

不同于最长递增子序列，但差不多。 水题。这里dp应初始化自身数据。

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>

using namespace std;
const int MAXN = 1001;
int num[MAXN];
int dp[MAXN];

int main(){
    int n;
    while(cin>>n && n ){
        memset(num, 0, sizeof(num));
        int maxnum = 0;
        
        for(int i=0; i<n; i++){
            cin>>num[i];
            dp[i] = num[i];  //这里应该是初始化为自己，我之前没注意直接初始化为0了
            //或者说，在这里只要初始化dp[0]为自己，然后下面的递推式 改成dp[i] = max (num[i], dp[j]+num[i])
        }
        for(int i=0; i<n; i++){
            for(int j=0; j<i; j++){
                if(num[j]<num[i])
                    dp[i] = max(dp[i], dp[j]+num[i]);
            }
            if(maxnum<dp[i])
                maxnum = dp[i];
        }
        cout<<maxnum<<endl;
    }
    return 0;
}
```



## 最长公共子序列

设字符串S1长度为n，S2长度为m。

首先设置一个二维数组dp\[][]，令dp\[i][j]表示以S1\[i]作为末尾和以S2\[j]作为末尾的最长公共子序列的长度，则最后需要求的是dp\[n][m]。

dp\[i][j]表示以S1\[i]作为末尾和以S2\[j]作为末尾的最长公共子序列的长度，根据S1\[i]和S2\[j]的关系可分为两种情况：

- S1\[i] = S2\[j]，此时必定存在一个最长公共子串以S1\[i] 和 S2\[j]结尾，其他部分等价于S1中前i-1个字符和S2中前j-1个字符的最长公共子串，于是这个子串长度比dp\[i-1][j-1]多1，即dp\[i][j] = dp\[i-1][j-1]+1
- S1\[i] != S2\[j]，此时最长公共子串长度为S1中前i-1个字符和S2中前j个字符的LCS长度与S1中前i个字符和S2中前j-1个字符的LCS长度的较大者，即在两种情况下得到的LCS都不会因为其中有一个字符串又增加了一个字符长度而发生改变， 也就是dp\[i][j] = max\{dp\[i-1][j], dp\[i][j-1]}

从这两种情况可以得到状态转移方程：
$$
dp[i][j] =
\begin{cases}
 dp[i-1][j-1]+1\quad \quad\quad\quad\quad\quad\quad  S1[i] = S2[j]\\
	\max \{dp[i-1][j], dp[i][j-1]\} \quad \quad \quad S1[i]!=S2[j]
\end{cases}
$$
而对于边界情况，如果两个字符串中的其中一个为空串，那么公共字符串的长度必定为0，于是可以轻松地得到：
$$
dp[i][0] = 0 \quad (0<=i<=n)\\
dp[0][j] = 0 \quad (0<=j<=m)
$$

**需要注意的是，字符串最好从下标1而非0开始输入，因为这样处理有利于边界情况的分析和初始化。**

### Coincidence

http://t.cn/AiY03RO5

```
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;

string s1;
string s2;
int dp[101][101];

int main(){
    while(cin>>s1>>s2){
        int m = s1.length();
        int n = s2.length();
        s1 = ' '+s1;
        s2 = ' '+s2;
        for(int i=0; i<=m; i++){
            for(int j=0; j<=n; j++){
                if(i==0 || j==0){//当某串长度为0时肯定公共子串也为0了
                    dp[i][j]=0;
                    continue;
                }
                if(s1[i]==s2[j]){
                    dp[i][j] = dp[i-1][j-1]+1;
                }
                else{
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        cout<<dp[m][n]<<endl;
    }
    return 0;
}

```



## 背包问题

**<font color=gold>0-1背包</font>**

令dp\[i][j]表示当前i个物品装进容量为j的背包能获得的最大价值。 则dp\[m][n]的值就是0-1背包问题的解。
只考虑第i件物品时，可将情况分为是否放入第i件物品两种：



- 对于容量为j的背包，如果不放入第i件物品，那么这个问题就转换成将前i-1个物品放入容量为j的背包的问题，即dp\[i][j] = dp\[i-1][j]
- 对于容量为j的背包，如果放入第i件物品，那么当前背包的容量就变成了j-w\[i]，并得到这个物品的价值v\[i]。之后这个问题就转化成将前i-1个物品放入容量为j-w\[i]的背包的问题，即dp\[i][j] = dp\[i-1][j-w\[i]] + v\[i]

而从这两种情况可以得到状态转移方程：
$$
dp[i][j] = \max (dp[i-1][j], dp[i-1][j-w[i]]+v[i])
$$
**转移时要注意j-w\[i]的值是否为非负值，若为负则代表背包当前容量无法放入第i件物品，不能进行转移。**

对于边界情况：
$$
dp[i][0] = 0 \quad (0<=i<=n)\\
dp[0][j] = 0 \quad (0<=j<=m)
$$



一维数组形式：
$$
dp[j] = \max(dp[j], dp[j-w[i]]+v[i])
$$


<font color=red>注意：使用一维数组时，j应该按倒序来。</font>因为需要保证在确定dp[j]的值时，dp[j-w[i]]的值尚未被修改，从而完成正确的状态转移。



### 点菜问题

http://t.cn/AiYOrkXr

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cmath>
using namespace std;

int dp[101][1001];
int w[101];//菜的价格
int v[101]; //菜的可口程度

int main(){
    int c, n;
    while(cin>>c>>n){
        for(int i=1; i<=n; i++){
            cin>>w[i]>>v[i];
        }
        for(int i=0; i<=n; i++){
            for(int j=0; j<=c; j++){
                if(i==0 || j==0){
                    dp[i][j]=0;
                    continue;
                }
                if(j<w[i]){//如果当前背包容量不能放下第i件物品
                    dp[i][j] = dp[i-1][j];
                }
                else{
                    dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i]);
                }
            }
        }
        cout<<dp[n][c]<<endl;
    }
    return 0;
}
```



### <font color=orange>最小邮票数</font>

http://t.cn/AiYlwchD

动态规划，这一题做起来好别扭啊。 还可以用DFS（留着，后面补）



这里dp\[i]\[j]表示目前有i张邮票，当总值为j时所需的最小数目。 

题目给了n个邮票，总值为m，则我们要求的便是dp\[n][m] 

由于是找最小值，所以要反着来。 

规定一个正确答案永远取不到的值，比如 n + 100，设为upper 

**为了方便初始化，n从1开始，即设置一个数组value[i]， 1<= i <=n，表示第i个邮票的面值** 

初始化dp\[i]\[0]=0 表示当总值为0时根本不用取，0就是最小的。 再初始化dp\[0]\[j]= upper（注意这两个初始化不能颠倒，否则dp\[0][0]就变成最大值了） 

状态转移方程就是 

```
dp[i][j] = min(dp[i-1][j], dp[i-1][j-value[i]]+1); 
```

在最后输出时，如果无解的话，dp肯定要大于upper的。所以对于 dp\[n][m]>=upper，输出0表示无解 

其他情况下直接输出dp\[n]\[m]

完整代码：

```
#include <iostream>
#include <cstdio>
#include <cmath>
#include <algorithm>
#include <climits>
#include <cstring>
using namespace std;

int value[21];
int dp[21][101];  //dp[i][j]表示总值为j时，给定i张邮票所需要的最少邮票
// dp[i][j] = min(dp[i-1][j], dp[i-1][j-value[i]]+1)
bool cmp(int a, int b){
    return a>b;
}

int main(){
    int m, n;
    while(cin>>m>>n && m && n){
        for(int i=1; i<=n; i++){
            cin>>value[i];
        }

        int upper = n +100;//随便挑的一个最大值，只要比n大就行。保证正确答案永远取不到这个值
        for(int i= 0; i<=n; i++){
            for(int j=0; j<=m; j++){
                //下面这一对if else的顺序不能调换！
                if (j==0){//如果目标总值为0，不需要拿邮票，就是最小值0
                    dp[i][j]=0;
                    continue;
                }
                else if(i==0){//如果没有给邮票，那要达到目标总值肯定无解，定为需要无限张邮票
                    dp[i][j]=upper;
                    continue;
                }

                if(j<value[i]){//装不下
                    dp[i][j] = dp[i-1][j];
                }
                else{
                    //要么和前面一样，要么拿当前这张
                    dp[i][j] = min(dp[i-1][j], dp[i-1][j-value[i]]+1);
                }
            }
        }

//        for(int i=0; i<=n; i++){
//            for(int j=0; j<=m; j++){
//                cout<<dp[i][j]<<" ";
//            }
//            cout<<endl;
//        }

        if(dp[n][m]>=upper)//正确答案取不到的值，即无解
            cout<<0<<endl;
        else
            cout<<dp[n][m]<<endl;
    }
    return 0;
}
```





**<font color=red>多重背包</font>**





### 珍惜现在，感恩生活

http://acm.hdu.edu.cn/showproblem.php?pid=2191

关于第一位从0还是从1开始，，我也不知道啥时候适合。感觉1可以更容易理解，但是还没碰到必须为1的场景。

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

int p[101];//输入价格
int h[101];//输入重量
int k[101];//输入数量

int weight[2001];  //重量
int price[2001]; //价格
int dp[101];



int main(){
    int c;
    cin>>c;
    while(c--){
        memset(p, 0, sizeof(p));
        memset(h, 0, sizeof(h));
        memset(k, 0, sizeof(k));
        memset(weight, 0, sizeof(weight));
        memset(price, 0, sizeof(price));
        memset(dp, 0, sizeof(dp));

        int n, m;//经费，大米种类数
        cin>>n>>m;

        int number =0; //用于拆分
        for(int i=0; i<m; i++){
            cin>>p[i]>>h[i]>>k[i];  //价格、重量、数量
            for(int j=1; j<=k[i]; j*=2){
                weight[number] = j*h[i];
                price[number] = j*p[i];
                number++;
                k[i]-=j;
            }
            if(k[i]>0){//还剩下没有拆分完的
                weight[number] = k[i]*h[i];
                price[number] = k[i]*p[i];
                number++;
            }
        }

        //此前已经将dp全都初始化为0了，这里就不用再初始化了

        for(int i=0;i<number;i++){
            for(int j=n; j>=price[i]; j--){// 0-1背包问题要倒序
                dp[j] = max(dp[j], dp[j-price[i]]+weight[i]);
            }
        }

        cout<<dp[n]<<endl;

    }
    return 0;
}
```




## 其他问题

### 放苹果

http://t.cn/AiQsyOnq

评论区大神解析：

> 设dp(m,n) 为m个苹果，n个盘子的放法数目，则先对n作讨论，
> 当n>m：必定有n-m个盘子永远空着，去掉它们对摆放苹果方法数目不产生影响。即if(n>m) dp(m,n) = dp(m,m)
> 当n<=m：不同的放法可以分成两类：
> 1、有至少一个盘子空着，即相当于f(m,n) = f(m,n-1);  
> 2、所有盘子都有苹果，相当于可以从每个盘子中拿掉一个苹果，不影响不同放法的数目，即dp(m,n) = dp(m-n,n).
> 而总的放苹果的放法数目等于两者的和，即 f(m,n) =f(m,n-1)+f(m-n,n) 


```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

int dp[11][11];

int main(){

    memset(dp, 0, sizeof(dp));
    int M,N;
    cin>>M>>N;

    for(int j=1; j<=N; j++)
        dp[0][j]=1; //当苹果个数为0，只要有盘子，都只有一种放法
    for(int i=0; i<=M; i++)
        dp[i][0]=0; //当没有盘子时，没有解

    for(int i=1; i<=M; i++){
        for(int j=1; j<=N; j++){
            if(i<j){//必定有j-i个盘子永远空着
                dp[i][j] = dp[i][i];
            }
            else{
                /*至少有一个空盘时，可以去掉1个空盘，dp[i][j] = dp[i][j-1]
                    * 当只有1个空盘时，和n-1个盘子满盘摆放相同
                    * 有大于1个空盘时，比如n个盘子存在x个空盘，和n-1个盘子存在x-1个空盘一样，所以dp[i][j-1]该考虑的都考虑到了
                    */
                /* 当不存在空盘时，每个盘子至少有1个苹果
                    * 那就各自都去掉一个苹果，摆放和n个盘子放m-n个苹果一样
                    * 即 dp[i][j] = dp[i-j][j]
                    */
                dp[i][j] = dp[i][j-1] + dp[i-j][j];
            }
        }
    }
    cout<<dp[M][N]<<endl;
    
    return 0;
}
```



### 整数拆分

http://t.cn/AiQsUM0Q



又是来自评论区大神的思路：

> 链接：https://www.nowcoder.com/questionTerminal/376537f4609a49d296901db5139639ec?f=discussion
> 来源：牛客网
>
> 记f(n)为n的划分数，我们有递推公式：
>
> **f(2m + 1) = f(2m)，**
>
> **f(2m) = f(2m - 1) + f(m)，**
> 初始条件：f(1) = 1。
>
> 证明:
>
> **证明的要点是考虑划分中是否有1。**
>
> 记:
>
> A(n) = n的所有划分组成的集合，
> B(n) = n的所有**含有1**的划分组成的集合，
> C(n) = n的所有不含1的划分组成的集合，
> 则有: A(n) = B(n)∪C(n)。
>
> 又记:
>
> f(n) = A(n)中元素的个数，
> g(n) = B(n)中元素的个数，
> h(n) = C(n)中元素的个数，
> 易知: f(n) = g(n) + h(n)。
>
> 以上记号的具体例子见文末。
>
> 我们先来证明: f(2m + 1) = f(2m)，
>
> 首先，2m + 1 的每个划分中至少有一个1，去掉这个1，就得到 2m 的一个划分，故 f(2m + 1)≤f(2m)。
> 其次，2m 的每个划分加上个1，就构成了 2m + 1 的一个划分，故 f(2m)≤f(2m + 1)。
> 综上，f(2m + 1) = f(2m)。
>
> 接着我们要证明: f(2m) = f(2m - 1) + f(m)，
>
> 把 B(2m) 中的划分中的1去掉一个，就得到 A(2m - 1) 中的一个划分，故 g(2m)≤f(2m - 1)。
> 把 A(2m - 1) 中的划分加上一个1，就得到 B(2m) 中的一个划分，故 f(2m - 1)≤g(2m)。
> 综上，g(2m) = f(2m - 1)。
>
> 把 C(2m) 中的划分的元素都除以2，就得到 A(m) 中的一个划分，故 h(2m)≤f(m)。
>
> 把 A(m) 中的划分的元素都乘2，就得到 C(2m) 中的一个划分，故 f(m)≤h(2m)。
> 综上，h(2m) = f(m)。
>
> 所以: f(2m) = g(2m) + h(2m) = f(2m - 1) + f(m)。 



```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

int dp[1000001];

int main(){
    int n;
    cin>>n;
    dp[1]=1;
    dp[2]=2;
    
    for(int i=3; i<=n; i++){
        if(i%2==1){
            dp[i]=dp[i-1];
        }
        else{
            dp[i]=(dp[i-1]+dp[i/2])%1000000000;
        }
    }
    
    cout<<dp[n]<<endl;
}
```

