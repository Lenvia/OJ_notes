[TOC]

# 暴力

## 枚举

#### 反序数

```
int Reverse (int x){
		int revx =0;
		while(x!=0){
			revx *= 10;
			revx += x%10;
			x /=10;
		}
		return revx;
}
```



#### 百鸡问题

http://t.cn/E9ldhru

```
#include <iostream>
using namespace std;


int main(){
    int n;
    cin>>n;
    for(int x=0;x<= n/5; x++){
        for(int y=0; y<=100-x ;y++){
                    if(5*x+3*y+(100-x-y)/3 <=n)
                        printf("%d %d %d\n",x,y,100-x-y);
        }
    }

    return 0;
}
```

这里本来我用的无脑三层循环，这题不好处理的是z的价格是1/3，我一开始以为需要用到double，但是好像直接z/3不影响

参考评论区解法，将y变量和z变量分别用前面的变量表示。同时，我缩小了x的上限为n/5



#### Old Bill

http://t.cn/E9jqijR

```
#include <iostream>
using namespace std;

int main(){
    int N;
    int a,b,c,d,e;
    while(cin>>N>>b>>c>>d){
        int sum,flag=0;

        for(int a=9;a>=1;a--){
            for(int e=9;e>=0;e--){
                sum = 10000*a+1000*b+100*c+10*d+e;
                if(sum%N==0){
                    printf("%d %d %d\n",a,e,sum/N);
                    flag=1;
                    break;
                }
            }
            if(flag)
                break;
        }
        if(flag==0)
            cout<<0<<endl;
    }
    return 0;
    
}
```

注意点：

​	五位价格，说明a最小为1而不是0

​	求最大火鸡单价，因为给定了N，所以从最大火鸡总价开始，即a和e从9开始减，只要遇到合适的直接输出并break

​	如果无解的话需要输出0，这个需要添加flag判断



## 模拟

### 图形排版

#### 叠框

P12

题目是输出一圈一圈交错的框，用平凡输出逻辑比较混乱。

答案用的是二维数组，先根据规律赋值，以每个圈的左上角和右下角坐标表示整个圈，并求出每一圈的长度。

等赋值结束后直接遍历数组输出就行了。

<font color=blue>即并不是在输出时使用得到的规律，而用另一种更容易的方法完成排版</font>

<font color=red>当图形对位置要求比较灵活时，可以考虑二维数组</font>





```
/**
参考高赞的回答，适当的加了一些解释
题解思路:通过dfs找到每一个子图的左上角的起始点，然后在每一个元图像上面作画。
*/
#include <iostream>
#include <math.h>
 
using namespace std;
 
char str[6][6];
char map[3001][3001];
int n;
 
int IntPow(int x,int n){//自定义指数运算
    int ans=1;
    for(int i=1;i<=n;i++)
        ans*=x;
    return ans;
}
 
//在以(x,y)为左上角顶点的区域中填充级别为level的块
void dfs(int x,int y,int level){//x,y为子图形的左上角起始点
    if(level==1){//搜索到了基础图形级别，直接把输入的二维数组复制过去
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                map[x+i][y+j]=str[i][j];
            }
        }
        return;
    }
    int Size = IntPow(n,level-1);
    //每次调用dfs(...,...,level-1)只能填充一块，所以要用二层循环，把所有相同规模的块填充，组成一个大块
    for(int i=0;i<n;i++){//搜索每一个位置对应的缩放的位置
        for(int j=0;j<n;j++){
            //这一句很有意义，输入str里该位置不为空，则在投影后对应区域(以(x+i*Size,y+j*Size)为左上角顶点的区域）需要填充本单位
            if(str[i][j]!=' ')
                dfs(x+i*Size,y+j*Size,level-1);//一共两层循环，对于每组i,j，全执行完毕后是把本单位扩大投影到比本单位高一级的单位
        }
    }
}

int main()
{
//    int m;
    while(cin >> n){
        if(n==0)break;
        getchar();
        for (int i = 0; i < n; i++){
            cin.getline(str[i],6);
        }
        int m;//level
        cin >> m;
        int size = (int)pow(n*1.0, m);//size=n^m
        for (int i = 0; i<size; i++){
            for (int j = 0; j<size; j++)
                map[i][j] = ' ';
            map[i][size] = '\0';
        }
        dfs(0,0,m);
        for(int i=0;i<size;i++){
            cout<<map[i]<<endl;
        }
    }
    return 0;
}
 

```



#### Hellow World for U

题目大概三个步骤

1.划分每个数组的长度

2.按长度赋值（可以省略/优化）

3.在二维数组中填充（记得在每次测试前先初始化一下）

```
#include <iostream>
#include <cstring>

#include <stdio.h>

using namespace std;

int num1,num2,num3,sum;//各数组的长度

void curve(int sum){
    for(num2=3; num2<=sum; num2++){
        num1=num3=(int)(sum+2-num2)/2;
//        cout<<"*"<<num1<<"*"<<num2<<"*"<<num3<<"*"<<endl;
        if(num1+num2+num3-2==sum)
            if(num1<=num2)
                break;
    }
}

int main() {
    
    char n1[27];
    char n2[27];
    char n3[27];
    char str[80];
    char map[27][27];
    
    
    while(gets(str)&& strlen(str)>0){
        
        //每次测试都要初始化一下
        for(int i=0;i<27;i++)
            for(int j=0;j<27;j++)
                map[i][j]=' ';
        
        sum = strlen(str);
    //    cout<<sum<<endl;
        //划分长度
        curve(sum);
    //    cout<<num1<<" "<<num2<<" "<<num3<<endl;
        
        //赋值
        for(int i=0;i<num1;i++)
            n1[i]=str[i];
        for(int i=0;i<num2;i++)
            n2[i]=str[num1+i-1];
        for(int i=0;i<num3;i++)
            n3[i]=str[num1+num2+i-2];
        
        //显示各数组
    //    for(int i=0;i<num1;i++)
    //        cout<<n1[i]<<" ";
    //    cout<<endl;
    //    for(int i=0;i<num2;i++)
    //        cout<<n2[i]<<" ";
    //    cout<<endl;
    //    for(int i=0;i<num3;i++)
    //        cout<<n3[i]<<" ";
    //    cout<<endl;
        
        //构造U型图
        for(int i=0;i<num1;i++)
            map[i][0]=n1[i];
        for(int j=0;j<num2;j++)
            map[num1-1][j]=n2[j];
        for(int i=num3-1;i>=0;i--)
            map[i][num2-1]=n3[num3-i-1];

    //    cout<<endl;
    //    cout<<endl;
        for(int i=0;i<num1;i++){
            for(int j=0;j<num2;j++)
                cout<<map[i][j];
            cout<<endl;
        }
    }
    
    return 0;
}

```

优化后代码：

```
//优化版（运行时间：4ms）
#include <iostream>
#include <cstring>
#include <stdio.h>

using namespace std;

int main() {
    char n3[27];
    char str[80];
    char map[27][27];
    int num1,num2,num3,sum;
    
    while(gets(str)&& strlen(str)>0){
        //每次测试都要初始化一下
        for(int i=0;i<27;i++)
            for(int j=0;j<27;j++)
                map[i][j]=' ';
        sum = strlen(str);
        //划分长度
        for(num2=3; num2<=sum; num2++){
            num1=num3=(int)(sum+2-num2)/2;
            if(num1+num2+num3-2==sum)
                if(num1<=num2)
                    break;
        }
        
        //赋值（因为n3要倒着输出为了方便这里先赋值）
        for(int i=0;i<num3;i++)
            n3[i]=str[num1+num2+i-2];
        
        //构造U型图
        for(int i=0;i<num1;i++)
            map[i][0]=str[i];
        for(int j=0;j<num2;j++)
            map[num1-1][j]=str[num1+j-1];
        for(int i=num3-1;i>=0;i--)
            map[i][num2-1]=n3[num3-i-1];
        //输出
        for(int i=0;i<num1;i++){
            for(int j=0;j<num2;j++)
                cout<<map[i][j];
            cout<<endl;
        }
    }
    return 0;
}
```



### 日期问题

预处理 很关键。

#### 日期累加

http://t.cn/E9Yw0Cr

这一题综合了 **今年的第几天？**http://t.cn/E9jXK5A 和**打印日期**http://t.cn/E9YP2a8 

```
#include <iostream>
#include <cstdio>
using namespace std;
 
int daytab[2][13]={
    {0,31,28,31,30,31,30,31,31,30,31,30,31},
    {0,31,29,31,30,31,30,31,31,30,31,30,31}
};

int daynum[2]={365,366};

int isLeapYear(int year){
    if((year%4==0 && year%100!=0) || year%400==0)
        return 1;
    else return 0;
}

int main(){
    int n;
    cin>>n;
    while(n--){
        int year,month,day,number;
        int rmonth=0;//结果月份
        int rday=0;//结果日期
        cin>>year>>month>>day>>number;
        int row=isLeapYear(year);
        for(int j=0; j<month; j++){
            number+=daytab[row][j];
        }
        number+=day;
        //到现在目标日期是相对于当前year的第number天
        //先确定目标年份
        while(number>daynum[row]){
            number -=daynum[row];
            year++;
            row = isLeapYear(year);
        }
        //现在就变成了一年内给定天数打印日期
        for(;rmonth<=12;rmonth++){
            if(number-daytab[row][rmonth]>0){
                number -=daytab[row][rmonth];
                continue;
            }
            rday=number;
            break;
        }
        printf("%04d-%02d-%02d\n",year,rmonth,rday);
    }
}
```



### 其他模拟

#### 手机键盘

http://t.cn/E9ulcIc

我的解法是直接switch各种情况，赋值当前字母所在组currentGroup和按压次数press

之后如果currentGroup和上一字母所在组lastGroup相等，则再+2。

看了论坛里大佬的解法：

```
#include<iostream>
#include<string>
using namespace std;
int main()
{
    int key[26] = {1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,4,1,2,3,1,2,3,4};
    string str;
    while(cin>>str)
    {
        int count = key[str[0]-'a'];
        for(int i=1;i<str.size();++i)
        {
            count += key[str[i]-'a'];
            if(key[str[i]-'a']-key[str[i-1]-'a']==str[i]-str[i-1])//判断是否在同一个按键上
                count+=2;
        }
        cout<<count<<endl;
    }
}
```

**用key顺序记录26个字母按键次数，**
**然后判断两个字母是否在同一个按键上，如果在同一个按键上，那么下标差（字母间距）就等于按键次数差。**



#### <font color=purple>路径打印</font>

http://t.cn/E9dvHs4

这个我题目没太看懂

待完善。



#### <font color = blue>坠落的蚂蚁</font>

思想很不错，值得细品。

待完善。

https://www.nowcoder.com/questionTerminal/fdd6698014c340178a8b1f28ea5fadf8?toCommentId=5234233

```
#include <iostream>
#include<algorithm>
using namespace std;

int main(){
    int N;
    while(cin>>N){
        //下面呢9个变量的解释分别是
        //输入位置、输入方向、蚂蚁A的位置、排序后左边最接近foucs的下标、排序后右边最接近focus的下标
        //向右运动蚂蚁总数、向左运动蚂蚁总数、排序后在左边并且向右运动数量、排序后在右边并且向左运动数量
        int loc,dir,focus,index1,index2,numL,numR,num1,num2;
        //用来存放向右运动和向左运动的所有蚂蚁的位置
        int left[100],right[100];
        for(int i=0;i<100;i++){
            left[i]=0;right[i]=0;//初始化
        }
        numL=0;numR=0;index1=0;index2=0;num1=0;num2=0;//初始化
        while(N--){
            cin>>loc>>dir;
            if(dir==0)
                focus=loc;//找到蚂蚁A的位置
            if(dir==1){//向右运动，放到left里
                left[numL]=loc;
                numL++;
            }
            if(dir==-1){//向左运动，放到right里
                right[numR]=loc;
                numR++;
            }
        }
        sort(left,left+numL);//排序
        sort(right,right+numR);
        
        for(int i=0;i<numL;i++){
           if(left[i]<focus){//找到在focus左边并且向右运动的最接近focus的下标index1
               num1++;
               index1=i;
               continue;
           }
            break;
        }
        for(int i=numR-1;i>=0;i--){//找到在focus右边并且向左运动的最接近focus的下标index2
           if(right[i]>focus){
               num2++;
                index2=i;
                continue;
           }
            break;
        }
       
        if(num1==num2)//不会掉落的条件是 在focus左边向右运动的数量==在focus右边向左运动的数量
            cout<<"Cannot fall!"<<endl;
        if(num1<num2)//这个语言不太好表达，可以自己举个例子，在纸上画一画 排序后的数组元素哪些用不到，哪些用得到
            cout<<right[index2+num1]<<endl;
        if(num1>num2)
            cout<<100-left[index1-num2]<<endl;
        
    }
    return 0;
}

```



# 排序与查找

## 排序

### 成绩排序

http://t.cn/E9d3ysv

```
#include <iostream>
#include <algorithm>
#include <cstdio>

using namespace std;

struct Student{
    int number;
    int score;
};

bool cmp(Student x, Student y){
    if(x.score==y.score)
        return x.number<y.number;
    else return x.score<y.score;
}

Student stu[100];

int main(){
    int N;
    while(cin>>N){
        for(int i=0;i<N;i++)
            cin>>stu[i].number>>stu[i].score;
        
        sort(stu,stu+N,cmp);
        for(int i=0;i<N;i++)
            cout<<stu[i].number<<" "<<stu[i].score<<endl;
    }
    return 0;
}
```

这里需要定义结构体数组，直接使用std里的sort函数。

sort(first, last, comp) 第三个参数为排序方式，可以不填写，不填写默认为升序。

在本题中，comp为我自定义的bool cmp(Studenx, Student y)函数。分数一样时按照学号升序，不一样时按照分数升序。

**排序规则：当比较函数的返回值为true时，表示的是比较函数的一个参数将会排在第二个参数前面。**

进阶：http://t.cn/E9gyHM1



### 奥运排序

http://t.cn/E9gYpyl

这个坑好多啊。

我是直接创建个结构体，记录国家号、金牌数、奖牌数、金牌比例、奖牌比例以及 四个排名和 最终排名、最终方法。

四个排名分别在四次排序 先后赋值。最终使用循环检查结构体，给最终排名赋值。

遇到的坑：

1.并列第几并不影响后面不并列的名次

2.人口数可能为0，这样金牌/奖牌比例可能为 0 或 无穷大

3.金牌为0，人口为0的时候 金牌比例是0而不是无穷大

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#define MAXGOAL 99999
using namespace std;

struct country{
    int id;//国家号
    int gold;//金牌总数
    int medal;//奖牌总数
    int people;//人口数
    double ratioG;//金牌人口比例
    double ratioM;//奖牌人口比例
    int rankG=-1;//按金牌排名的位置
    int rankM=-1;//按奖牌
    int rankGR=-1;//按金牌人口比例
    int rankMR=-1;//按奖牌人口比例
    int finalRank=-1;
    int finalNum=-1;
};
bool cmp0(country c1, country c2){
    return c1.id<c2.id;
}
bool cmp1(country c1, country c2){
    return c1.gold>c2.gold;
}
bool cmp2(country c1, country c2){
    return c1.medal>c2.medal;
}
bool cmp3(country c1, country c2){
    return c1.ratioG>c2.ratioG;
}
bool cmp4(country c1, country c2){
    return c1.ratioM>c2.ratioM;
}

country con[10];//输入的数据
int testId[10];//用于排名的id
country testCon[10];//用于排名的国家

int main(){
    int N,M;
    while(cin>>N){
        cin>>M;
        for(int i=0;i<N;i++){
            cin>>con[i].gold>>con[i].medal>>con[i].people;//输入金牌、奖牌、人口
            con[i].id=i;//国家号
            if(con[i].people==0){//人口数可能为0，这里注意，为0后 同为无穷大默认相等
                //金牌数和奖牌数也可能为0 啊啊啊啊啊啊 
                if(con[i].gold==0)
                    con[i].ratioG=0;
                else 
                    con[i].ratioG=MAXGOAL;
                if(con[i].medal==0)
                    con[i].ratioM=0;
                else 
                    con[i].ratioM=MAXGOAL;
            }
            else{
                con[i].ratioG=(con[i].gold*1.0)/(con[i].people*1.0);
                con[i].ratioM=(con[i].medal*1.0)/(con[i].people*1.0);
            }
        }
        for(int i=0;i<M;i++)
            cin>>testId[i];//输入需要排序的国家号
        for(int i=0;i<M;i++)
            testCon[i]=con[testId[i]];//放到另一个数组里
        //现在是要对testCon里的进行排序
        sort(testCon,testCon+M,cmp1);//按金牌总数排名，赋值rankG
        for(int i=0;i<M;i++){
            if(i==0)
                testCon[i].rankG=1;
            else{
                if(testCon[i].gold==testCon[i-1].gold)
                    testCon[i].rankG=testCon[i-1].rankG;
                else testCon[i].rankG=i+1;//注意，例子，如果出现金牌总数为 100,90,90,80.则排名为1,2,2,4.而不是1,2,2,3
            }
        }
        sort(testCon,testCon+M,cmp2);//按奖牌总数排名，赋值rankM
        for(int i=0;i<M;i++){
            if(i==0)
                testCon[i].rankM=1;
            else{
                if(testCon[i].medal==testCon[i-1].medal)
                    testCon[i].rankM=testCon[i-1].rankM;
                else testCon[i].rankM=i+1;
            }
        }
        sort(testCon,testCon+M,cmp3);//按金牌人口比例排名，赋值rankGR
        for(int i=0;i<M;i++){
            if(i==0)
                testCon[i].rankGR=1;
            else{
                if(testCon[i].ratioG==testCon[i-1].ratioG)
                    testCon[i].rankGR=testCon[i-1].rankGR;
                else testCon[i].rankGR=i+1;
            }
        }
        sort(testCon,testCon+M,cmp4);//按奖牌人口比例排名，并为finalRank赋值默认为rankMR，finkalNum默认为4
        for(int i=0;i<M;i++){
            if(i==0)
                testCon[i].rankMR=1;
            else{
                if(testCon[i].ratioM==testCon[i-1].ratioM)
                    testCon[i].rankMR=testCon[i-1].rankMR;
                else testCon[i].rankMR=i+1;
            }
            testCon[i].finalRank=testCon[i].rankMR;
            testCon[i].finalNum=4;
        }
        sort(testCon,testCon+M,cmp0);//按id排序并输出
        for(int i=0;i<M;i++){
            if(testCon[i].finalRank>=testCon[i].rankGR){
                testCon[i].finalRank=testCon[i].rankGR;
                testCon[i].finalNum=3;
            }
            if(testCon[i].finalRank>=testCon[i].rankM){
                testCon[i].finalRank=testCon[i].rankM;
                testCon[i].finalNum=2;
            }
            if(testCon[i].finalRank>=testCon[i].rankG){
                testCon[i].finalRank=testCon[i].rankG;
                testCon[i].finalNum=1;
            }
        }
        for(int i=0;i<M;i++){
            cout<<testCon[i].finalRank<<":"<<testCon[i].finalNum<<endl;
        }
        cout<<endl;
    }
}
```



## 查找

### 查找（名字就叫查找）

http://t.cn/E9g8aaR

使用的二分查找

**注意：在int middle = (left+right)/2 中，如果left和right非常接近整型最大值的情况，则相加会出现溢出。因此要用代码 int middle = left + (right-left)/2 代替。**

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#define MAXN 100
using namespace std;

int a[MAXN];
//二分查找
bool BinarySearch(int n, int target){
    int left=0;
    int right=n-1;
    while(left<=right){
        int middle= (left+right)/2;
        if(a[middle]<target)
            left=middle+1;
        else if(a[middle]>target)
            right=middle-1;
        else return true;
    }
    return false;
}

int main(){
    int n,m;
    while(cin>>n){
        for(int i=0;i<n;i++)
            cin>>a[i];
        sort(a,a+n);
        cin>>m;
        for(int i=0;i<m;i++){
            int target;
            cin>>target;
            if(BinarySearch(n,target))
                cout<<"YES"<<endl;
            else cout<<"NO"<<endl;
        }
    }
    return 0;
}
```



### 找最小数

http://t.cn/E9gekWa

我刚开始很傻逼的想用二维数组，并且用sort给二维数组排序。

后来想到结构体（结构体太香了），对结构体数组排序后直接输出第一个结构体的x和y就行了。

评论区大神直接在输入的时候就开始筛选了

```
if(t.x<min.x || (t.x == min.x&&t.y < min.y))
	min = t;
```

下面是完整的两种代码

```
//#include <iostream>
//#include <cstdio>
//#include <algorithm>
//using namespace std;
//
//struct num{
//    int x;
//    int y;
//};
//
//bool cmp(num p, num q){
//    if(p.x==q.x)
//        return p.y<q.y;
//    else return p.x<q.x;
//}
//
//num a[1000];
//
//int main(){
//    int n;
//    while(cin>>n){
//        for(int i=0;i<n;i++)
//            cin>>a[i].x>>a[i].y;
//        sort(a,a+n,cmp);
//        cout<<a[0].x<<" "<<a[0].y<<endl;
//    }
//    return 0;
//}

//论坛大佬进阶版
//链接：https://www.nowcoder.com/questionTerminal/ba91786c4759403992896d859e87a6cd
//来源：牛客网

#include <stdio.h>
#define INT_MAX 0x7fffffff
struct s{
    int x,y;
};
int main(){
    int n;
    while(~scanf("%d",&n)){
        s min,t;
        min.x=INT_MAX;
        min.y=INT_MAX;
        while(n--){
            scanf("%d %d",&t.x,&t.y);
            if(t.x<min.x || (t.x == min.x&&t.y < min.y))
                min = t;
        }
        printf("%d %d\n",min.x,min.y);
    }
}

```



### 打印极值点下标

（示例有坑，第一行的组数是多余的）水题

http://t.cn/E9ehDw4

```
#include <iostream>
#include <cstdio>
#include <algorithm>

using namespace std;
int a[80];
int index[80];
int main(){
    int k;
    int num=0;
    while(cin>>k){
        //输入数据
        for(int i=0;i<k;i++)
            cin>>a[i];
        //判断开头、结尾、其他；并用新数组存放下标（方便输出格式）
        for(int i=0;i<k;i++){
            if(i==0){
                if(a[i]!=a[i+1]){
                    index[num]=i;
                    num++;
                }
            }
            else if(i==k-1){
                if(a[i]!=a[i-1]){
                    index[num]=i;
                    num++;
                }
            }
            else{
                if((a[i]<a[i-1] && a[i]<a[i+1]) || (a[i]>a[i-1] && a[i]>a[i+1])){
                    index[num]=i;
                    num++;
                }
            }
        }
        //输出结果
        for(int i=0;i<num;i++){
            if(i==0)
                cout<<index[i];
            else
                cout<<" "<<index[i];
        }

        cout<<endl;
    }
    return 0;
}
```





### 找位置

http://t.cn/E9eh4jY

我借助了string方法里的find(ch,pos)来获取同一个字符的所有位置 

通过 postion = str.find(ch, postion+1)可以获取下一个位置 

代码还有改进的地方，比如舍弃flag数组，检查过的直接更改为符号'*'就行了

关于find()的使用 https://www.cnblogs.com/wkfvawl/p/9429128.html

```
#include<cstring>
#include<cstdio>
#include<iostream>
using namespace std;

int flag[100];//指示是否已经被输出过
int out[100];
int main(){
    string str;
    while(cin>>str){
        char ch; int position; int num;//当前字符、位置、数量
        for(int i=0;i<str.length();i++)
            flag[i]=1;
        for(int i=0;i<str.length();i++){
            if(flag[i]){//只检查flag为1的字符
                num=0;//初始化数量
                ch=str[i];//获取当前字符
                position=i;//当前字符的第一个位置一定是它当前的下标（原因在下面）
                while(position!=-1){
                    flag[position]=0;//置flag为0，即将被输出
                    out[num]=position;//将位置存进另一数组
                    num++;
                    position=str.find(ch,position+1);//不断地使用find来获取当前字符的下一个位置
                }
                if(num>1){
                    for(int i=0;i<num;i++){
                        if(i==0)
                            cout<<ch<<":"<<out[i];
                        else
                            cout<<","<<ch<<":"<<out[i];
                    }
                    cout<<endl;
                }
            }
        }
    }
    return 0;
}
```





# 字符串

## 字符串处理

### 统计字符

http://t.cn/Ai8fvq4I

有几个注意点：

1.字符串含有空格要用getline自定义读入

2.find函数的使用

3.或者直接使用自带的count函数

4.也可以使用数组计数，初始化全为0，遇到一个对应位置+1

```
#include <iostream>
#include <string>
#include <cstdio>
using namespace std;

int main(){
    string chs;
    while(getline(cin,chs,'\n') && chs!="#"){
        string str;
        getline(cin,str,'\n');
        for(int i=0;i<chs.length();i++){
            //也可以直接用自带的count(str.begin(),str.end(),chs[i])来计数
            int pos=str.find(chs[i],0);
            int num=0;
            while(pos!=string::npos){
                num++;
                pos=str.find(chs[i],pos+1);
            }
            cout<<chs[i]<<" "<<num<<endl;
        }
    }
    return 0;
}
```



### <font color=blue>浮点数加法</font>

http://t.cn/Ai8I4v0j

分别取整数部分和小数部分分别相加。

先对齐，再相加，注意进位。

```
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
using namespace std;

int carry;

string addInt(string s1, string s2){
    //位数对齐
    if(s1.length()<s2.length())
        s1.insert(0,s2.length()-s1.length(),'0');
    if(s2.length()<s1.length())
        s2.insert(0,s1.length()-s2.length(),'0');
    int flag=0;//进位
    for(int i=s1.length()-1; i>=0; i--){
        int temp;
        temp=(s1[i]-'0')+(s2[i]-'0')+flag;
        if(temp>=10){
            flag=1;
            temp-=10;
        }
        else flag=0;
        
        s1[i]=temp+'0';
        if(i==0 && flag==1)
            s1.insert(0,1,'1');
    }
    return s1;
}

string addDec(string s1, string s2){
    //位数对齐
    if(s1.length()<s2.length())
        s1.insert(s1.length(),s2.length()-s1.length(),'0');
    if(s2.length()<s1.length())
        s2.insert(s2.length(),s1.length()-s2.length(),'0');
    int flag=0;//进位
    for(int i=s1.length()-1; i>=0; i--){
        int temp;
        temp=(s1[i]-'0')+(s2[i]-'0')+flag;
        if(temp>=10){
            flag=1;
            temp-=10;
        }
        else flag=0;
        
        s1[i]=temp+'0';
        if(i==0 && flag==1)
            carry=1;//小数进位
    }
    return s1;
    
}


int main(){
    string f1,f2,s;
    while(cin>>f1){
        cin>>f2;
        carry=0;
        int pos1,pos2;
        string int0, int1, int2, dec0,dec1,dec2;
        //定位小数点的位置
        pos1=f1.find('.',0);
        pos2=f2.find('.',0);
        //取整数部分
        int1= f1.substr(0,pos1);
        int2= f2.substr(0,pos2);
        //取小数部分
        dec1= f1.substr(pos1+1,f1.length()-pos1+1);
        dec2= f2.substr(pos2+1,f2.length()-pos2+1);
        //整数部分加法
        int0 = addInt(int1,int2);
        //小数部分加法
        dec0 = addDec(dec1,dec2);
        //如果小数部分有进位
        if(carry)
            int0 = addInt(int0,"1");
        //cout<<int0<<endl<<dec0<<endl;
        s=int0+'.'+dec0;
        cout<<s<<endl;
    }
    return 0;
}

```

评论区更简洁的方法

链接：https://www.nowcoder.com/questionTerminal/ddec753f446e4ba4944e35378ba635c8
来源：牛客网

```
#include<iostream>
#include<string>
/** \brief
整体来说，分为整数的相加和小数的相加，
整数部分分别存在z1和z2中，小数部分分别存在x1和x2中
剩下的就是字符串的相加了
 */
 
using namespace std;
int main(){
    string s1,s2,z1,z2,x1,x2;
    cin>>s1>>s2;
    z1=string(s1,0,s1.find(".",0));//取整数部分
    x1=string(s1,s1.find(".",0)+1,s1.length()-s1.find(".",0));//取小数部分
    z2=string(s2,0,s2.find(".",0));
    x2=string(s2,s2.find(".",0)+1,s2.length()-s2.find(".",0));
    //cout<<z1<<endl<<x1<<endl<<z2<<endl<<x2;
    if(z1.length()<z2.length())//总是使z1最长
        z1.swap(z2);
    if(x1.length()<x2.length())//总是使x1最长
        x1.swap(x2);
    int f=0;                    //标志位，进位时使用
    for(int i=x2.length()-1;i>=0;i--){  //先加小数部分，因为小数部分可能向整数部分进位
        int a=x1[i]-'0'+x2[i]-'0'+f;    //对应位相加，注意从最短数的最后一位相加
        x1[i]=a%10+'0';                 //更新该位值
        f=a/10;                         //更新进位标志
    }
    int l=z1.length()-1;                //整数部分相加
    for(int i=z2.length()-1;i>=0;i--){  //注意从最短数最后一位相加
        int a=z1[l]-'0'+z2[i]-'0'+f;
        z1[l]=a%10+'0';
        f=a/10;
        l--;                //调整最长位标志
    }
    while(l>=0){            //继续更新最长位，到起始值位置
        int a=z1[l]-'0'+f;
        z1[l]=a%10+'0';
        f=a/10;
        l--;
    }
    cout<<z1<<'.'<<x1;      //输出对应整数和小数
}
```



## 字符串匹配

主要是KMP算法，在不同情况下做调整。

https://www.cnblogs.com/yjiyjige/p/3263858.html

详见《题目无关》——KMP算法



# 数据结构一

## 向量



## 队列

## 栈

### 括号匹配问题

P75

```
#include <iostream>
#include <stack>
#include <cstdio>
using namespace std;

/**
 设置一个左括号栈，用来存放左括号在原数组中的下标。
 每当遇到一个右括号，若栈里有左括号，则左括号出栈。
 所以可以先默认遇到左括号时，印上一个'$'，当它出栈的时候在赋值为' '。
 
 左括号不匹配：当遍历完整个字符串后栈里还剩左括号，则剩下的都不匹配
 右括号不匹配：扫描到右括号但是栈空。
 */
int main(){
    string str;
    while(getline(cin,str,'\n')){
        stack<int>left;//存放左括号的位置
        string s(str.length(),' ');//初始化
        for(int i=0;i<str.length();i++){
            if(str[i]=='('){
                left.push(i);
                s[i]='$';
            }
            else if(str[i]==')'){

                if(left.empty())
                    s[i]='?';//左括号栈空则表明当前右括号不能匹配
                else{//匹配到了，左括号原本的位置变为空格，然后出栈
                    s[left.top()]=' ';
                    left.pop();
                }
            }
        }
        cout<<str<<endl;
        cout<<s<<endl;
    }
    return 0;
}

```



### <font color=red>简单计算器</font>

http://t.cn/AiKoGS94

在什么时候进栈的地方有难度。还得设置优先级判断，还得在字符串和栈底添加符号。

1.将运算符栈占地的特殊运算符#的优先级设为最低，于是后续遇到的任何越酸腐的优先级都会比它高，能够顺利入栈。

2.将表达式尾部的特殊运算符\$的优先级设为次低，于是当遍历到表达式尾部时，若运算符栈中尚有可以运算的符号，则可继续进行运算；若运算符中只剩下特殊符号#，则也可保证\$能够顺利入栈，并且让程序正确的退出。

3.isdigit()函数在头文件cctype中，该函数能够用来检查字符是否为十进制数字字符。

```
#include <iostream>
#include <stack>
#include <cstdio>
#include <cctype>
#include <string>
using namespace std;

int pri (char ch){//返回字符优先级
    int p=-1;
    if(ch=='#')
        p=0;
    else if(ch=='$')
        p=1;
    else if(ch=='+'||ch=='-')
        p=2;
    else
        p=3;
    return p;
}

double getNumber(string s, int& index){//返回字符串当前下标到下一个空格间的数字
    double ans=0;
    while(isdigit(s[index])){
        ans*=10;
        ans+=s[index]-'0';
        index++;
    }
    return ans;
}

double cal (double x, double y, char ch){//返回字符优先级
    double result=0;
    if(ch=='+')
        result=x+y;
    else if(ch=='-')
        result=x-y;
    else if(ch=='*')
        result=x*y;
    else if(ch=='/')
        result=x/y;
    return result;
}
       
int main(){
    string str;
    while(getline(cin,str,'\n') && str!="0"){     
        int index=0;
        stack<double>num;
        stack<char>op;
        str+='$';//因为遇到符号才会计算，添加'$'是为了保证末尾的计算，否则无法触发计算。
        op.push('#');
        while(index<str.length()){
            if(str[index]==' '){
                index++;
            }
            else if(isdigit(str[index])){
                num.push(getNumber(str, index));
            }
            else{
                if(pri(str[index])>pri(op.top())){//如果当前字符比栈顶字符的优先级高，则进栈
                    op.push(str[index]);
                    index++;
                }
                else{//如果当前字符比栈顶字符的优先级低或相等，则计算栈里的
                    //数字的顺序别弄反了
                    double y = num.top();
                    num.pop();
                    double x = num.top();
                    num.pop();
                    char ch = op.top();
                    num.push(cal(x,y,ch));//结果再放入栈
                    op.pop();
                }
            }
        }
        printf("%.2f\n",num.top());
    }
    return 0;
}

```



### <font color=blue>计算表达式（和上一题很相似，稍微简单一点）</font>

http://t.cn/AiKKJjJ5

我的代码：（使用栈）

https://www.nowcoder.com/profile/748608757/codeBookDetail?submissionId=64392525

**评论区不用栈的代码：**

将减法转变为加法，遇到加号或减号，将下一个数字存到数组的下一位。

遇到乘号或除号，直接在数组当前位进行运算

妙啊。

```
#include<cstdio>
#include<iostream>
using namespace std;
int main(){
   double t;
     double a[1000];
    while(scanf("%lf",&t)!=EOF){
        double sum=0;
        char ch;int i=0;a[0]=t;
        while(scanf("%c",&ch)!=EOF&&ch!='\n'){
            double tem;
            scanf("%lf",&tem);
            if(ch=='+') 
                a[++i]=tem;
            else if(ch=='-')
                a[++i]=-tem;
            else if(ch=='*')
                a[i]*=tem;
            else if(ch=='/')
                a[i]/=tem;
        }
        for(int j=0;j<=i;j++)
            sum+=a[j];
        cout<<sum<<endl;
    }
}
```



# 数学问题

## 进制转换

### 二进制数（小型十进制转二进制）

http://t.cn/AiCuKTOv

x%2是最低位的，x/2可让高数位向低数位移动。
$$
x\%2=(b_0*2^0+b_1*2^1+b_2*2^2+...+b_n*2^n)\%2\\
x\%2=b_0
$$

$$
x/2=(b_0*2^0+b_1*2^1+b_2*2^2+...+b_n*2^n)/2\\
x/2=b_1*2^0+b_2*2^1+b_3*2^2+...+b_n*2^{n-1}
$$

不断进行求模和整除运算，便可依次求得被移动到最低数位的值；以此类推，便可得到所有数位上的值。

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <string>
#include <cstring>

using namespace std;

string convert(int num){
    string s;
    while(num){
        s+=num%2+'0';
        num/=2;
    }
    reverse(s.begin(),s.end());
    while(s[0]=='0'){
        s=s.substr(1);//截取s[1]到结尾
    }
    return s;
}

int main(){
    int num;
    string bi;
    while(cin>>num){
        bi=convert(num);
        cout<<bi<<endl;
    }
    return 0;
}
```

书上使用向量的版本：

```
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;

int main(){
    unsigned int n;
    while(cin>>n && n){
        vector<int> binary;
        while(n){
            binary.push_back(n%2);
            n/=2;
        }
        for(int i=binary.size()-1; i>=0; i--)
            cout<<binary[i];
        cout<<endl;
    }
    return 0;
}

```

### 进制转换（大型十进制转二进制）

http://t.cn/AiCuoPRO

**把字符串<font color=red>从高到低</font>逐位除以除数。如果某位不能整除，那么就保留它除以除数的余数，余数乘以10后和低一位一起进行处理**

```
#include <iostream>
#include <cstdio>
#include <vector>
#include <algorithm>
using namespace std;

//字符串除法
string Divide(string str, int x){
    int remainder=0;
    for(int i=0; i<str.length(); i++){
        int current= str[i]-'0'+remainder*10;
        str[i]=current/x + '0';
        remainder = current %x;
    }
    int pos=0;
    while(str[pos]=='0')
        pos++;
    str=str.substr(pos);
    return str;
}


int main(){
    string str;
    while(cin>>str){
        vector<int>binary;
        while(str.size()!=0){
            int last = str[str.size()-1]-'0';
            binary.push_back(last%2);
            str = Divide(str,2);
        }
        for(int i=binary.size()-1; i>=0; i--)
            cout<<binary[i];
        cout<<endl;
    }
    return 0;
}

```



### （大数）十进制转八进制

**如果是其他进制(<10)，只要改改数字就行**

基本都差不多，但是进栈不是用最后一位去模了，而是应该获取除法过程中的余数

http://t.cn/AiCu0lHe

```
#include <iostream>
#include <string>
#include <algorithm>
#include <vector>
#include <cstdio>
#include <cstring>
using namespace std;

//string Divide(string str, int x){
//    int remain=0;
//    for(int i=0; i<str.length(); i++){
//        int current = str[i]-'0'+ remain*10;
//        str[i] = current/ x +'0';
//        remain = current %x;
//    }
//    int pos=0;
//    while(str[pos]=='0')
//        pos++;
//    str= str.substr(pos);
//    return str;
//}


int main(){
    string str;
    while(cin>>str){
        vector<int>oct;
        while(str.size()!=0){
            int remain=0;
            for(int i=0; i<str.length(); i++){
                int current = str[i]-'0'+ remain*10;
                str[i] = current/ 8 +'0';
                remain = current %8;
            }
            int pos=0;
            while(str[pos]=='0')
                pos++;
            str=str.substr(pos);
            oct.push_back(remain);
        }
        for(int i=oct.size()-1; i>=0; i--){
            cout<<oct[i];
        }
        cout<<endl;
    }
    return 0;
}

```

### <font color=blue>进制转换（十六进制转十进制）</font>

http://t.cn/AiCuig9B

按理说可以实现不同进制的转换，可能需要小的修改。（十六进制转10进制没问题）

```
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;

int char2int(char ch){
    if(ch>='0' && ch <='9')
        return ch-'0';
    else
        return ch-'A'+10;
}
char int2char(int x){
    if(x>=0 && x<=9)
        return x+'0';
    else
        return x-10+'A';
}

int main(){
    string str;
    while(cin>>str){
        vector<int>ans;
        int n=16;//当前进制
        int m=10;//目标进制
        str=str.substr(2);//去掉前面的0x两个字符
        while(str.size()!=0){
            int remain=0;
            for(int i=0; i<str.length(); i++){
                int current = char2int(str[i])+ remain*n;
                str[i] = int2char(current/ m);
                remain = current %m;
            }
            int pos=0;
            while(str[pos]=='0')
                pos++;
            str=str.substr(pos);
            ans.push_back(remain);
        }
        for(int i=ans.size()-1; i>=0; i--){
            cout<<ans[i];
        }
        cout<<endl;
    }
    return 0;
}

```

评论区各种大神的进制转换：

https://www.nowcoder.com/questionTerminal/deb19498bc644f53a6a99905ef5ee01d?toCommentId=5240895



### 又一版A+B（大数加法+进制转换）

http://t.cn/AiCuOSWv

```
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;

//大数加法
string addStr(string s1, string s2){
    string s;
    if(s1.length()<s2.length())
        s1.swap(s2);
    s2.insert(0,s1.length()-s2.length(),'0');//对齐
    int flag=0;
    int temp=0;
    for(int i=s1.length()-1; i>=0;i--){
        
//        cout<<s1<<" "<<s2<<endl;
        temp= s1[i]-'0'+s2[i]-'0'+flag;
//        cout<<temp<<"  ";
        if(temp>=10){
            flag=1;
            temp%=10;
        }
        else
            flag=0;//这一步不能忘！
        s+=(temp+'0');
    }
    if(flag)//如果还有进位
        s+='1';
    reverse(s.begin(),s.end());
    return s;
}

int main(){
    int m;
    string A,B,s;
    while(cin>>m && m){
        cin>>A>>B;
        s=addStr(A,B);//大数加法
        
        vector<int>ans;
//        cout<<s<<endl;
        while(s.size()!=0){
            int remain=0;
            for(int i=0; i<s.length(); i++){
                int current = s[i]-'0'+ remain*10;
                s[i] = current/ m +'0';
                remain = current %m;
            }
            int pos=0;
            while(s[pos]=='0')
                pos++;
            s=s.substr(pos);
            ans.push_back(remain);
        }
        for(int i=ans.size()-1; i>=0; i--){
            cout<<ans[i];
        }
        cout<<endl;
    }
    return 0;
}

```



### <font color=red>十六以内任意进制转换</font>

http://t.cn/AiCu6ne4

改进的地方是把向量类型设置为了char，然后每次进栈的是 int2char(remain)

```
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;

int char2int(char ch){
    if(ch>='0' && ch <='9')
        return ch-'0';
    else if(ch>='A' && ch <='Z')
        return ch-'A'+10;
    else
        return ch-'a'+10;
}
char int2char(int x){
    if(x>=0 && x<=9)
        return x+'0';
    else
        return x-10+'A';
}

int main(){
    string str;
    int a,b;//原始进制，目标进制
    while(cin>>a>>str>>b){
        vector<char>ans;
        while(str.size()!=0){
            int remain=0;
            for(int i=0; i<str.length(); i++){
                int current = char2int(str[i])+ remain*a;
                str[i] = int2char(current/ b);
                remain = current %b;
            }
            int pos=0;
            while(str[pos]=='0')
                pos++;
            str=str.substr(pos);
            ans.push_back(int2char(remain));
        }
        for(int i=ans.size()-1; i>=0; i--){
            cout<<ans[i];
        }
        cout<<endl;
    }
    return 0;
}
```



## 最大公约数与最小公倍数

### 最大公约数

http://t.cn/AiCuWLTS

```
#include <iostream>
#include <algorithm>
using namespace std;

//非递归
int gcd(int a, int b){
    int r,temp=0;
    if(a < b){
        temp = a;
        a = b;
        b = temp;
    }
    while(a%b!=0){
        r=a%b;
        a=b;
        b=r;
    }
    return b;
}
//递归
int gcd2(int a, int b){
    if(b==0)
        return a;
    else{
        return gcd2(b, a%b);
    }
}

int main(){
    int a,b;
    while(cin>>a>>b){
        cout<<gcd(a,b)<<endl;
    }
    return 0;
}
```

### 最小公倍数

```
#include <iostream>
#include <algorithm>
using namespace std;

//非递归
int gcd(int a, int b){
    int r,temp=0;
    if(a < b){
        temp = a;
        a = b;
        b = temp;
    }
    while(a%b!=0){
        r=a%b;
        a=b;
        b=r;
    }
    return b;
}

int main(){
    int a,b;
    while(cin>>a>>b){
        cout<<a*b/gcd(a,b)<<endl;
    }
    return 0;
}
```



## 质数

### 素数（求两个整数之间的所有素数）

http://t.cn/AiCulqtW

**若一个数不是素数，则必存在一个小于它的素数为其因数。**

**<font color=blue>素数筛法：</font>**（推荐看下一题的）

找到一个素数，就将它的所有倍数均标记成非素数；若它未被任何小于它的素数标记为非素数，则确定为素数。

（我写的很乱逻辑，所以用书上的）

**initial()这个函数可以背一下，也可以把向量换成数组（可以参考下一题的initial()）**

MAXN不能过大，否则 **for(int j=i*i; j<MAXN; j+=i)** 会越界

```
#include <iostream>
#include <cmath>
#include <vector>
using namespace std;

const int MAXN =10001;
vector<int>prime;
bool isPrime[MAXN];

void initial(){
    for(int i=0; i<MAXN; i++)
        isPrime[i]=true;
    isPrime[0]=false;
    isPrime[1]=true;
    for(int i=2; i<MAXN; i++){
        if(!isPrime[i])
            continue;
        prime.push_back(i);
        for(int j=i*i; j<MAXN; j+=i)//这里很细节
            isPrime[j]=false;
    }
        return ;
}

int main(){
    initial();
    int n;
    while(cin>>n&& n){
        int sign=0;//默认无符合条件的输出
        int flag=1;//第一个数前面不带空格
        for(int i=0; i<prime.size() && prime[i]<n; i++){//注意这里判断的条件
            if(prime[i]%10==1){
                sign=1;
                if(flag){
                    cout<<prime[i];
                    flag=0;
                }
                else
                    cout<<" "<<prime[i];
            }
        }
        cout<<endl;
    }
    return 0;
}

```



### <font color=red>Prime Number</font>

http://t.cn/AiCulrSh

MAXC是题目要求最大的数量（即第几个素数）

MAXN设会导致内存溢出（第10000个素数是十万多一点）

我设置的1,000,000消耗的内存是1500K，耗时10ms；

可以设置为110,000，消耗内存512K，耗时5ms。

注意 double bound = sqrt(MAXN);  必须为double类型，否则会损失精度导致错误

**bound的设置很关键**

```
#include <iostream>
#include <algorithm>
#include <cstdio>
#include <cmath>
 
using namespace std;
 
const int MAXN=110000;
const int MAXC=10000;
 
bool isPrime[MAXN];
int num[MAXC];//用来存储素数，如果用vector会耗时一点
 
void initial(int& count){
    //经评论区大哥提醒这里bound应为double
    //如果是int，MAXN开根号可能会损失精度，在if(i>=bound)处直接跳过而少清理一个合数
    double bound = sqrt(MAXN);
    count=0;
    for(int i=0; i<MAXN; i++)
        isPrime[i]=true;
    isPrime[0]=false;
    isPrime[1]=true;
     
    for(int i=2; i<MAXN && count<MAXC; i++){//添加了count的条件
        if(!isPrime[i])
            continue;
        num[count]=i;
        count++;
        //***********防止越界**************
        if(i>=bound)
            continue;
        //********************************
        for(int j=i*i; j<MAXN; j+=i)
            isPrime[j]=false;
    }
        return ;
}
 
int main(){
    int k;
    int count=0;
    initial(count);
//    for(int i=0; i<count; i++)
//        cout<<i<<" "<<num[i]<<endl;
//    cout<<endl;
    while(cin>>k){
        cout<<num[k-1]<<endl;
    }
    return 0;
}

```



## 分解质因数

### 质因数的个数

我是先在初始化函数initial()中算出一定范围内的所有素数并存储在数组中

然后再用输入的数不断遍历刚才的数组，得到结果。

（但是我一想不用初始化直接除以的话好像也没问题，因为当除数是合数时，它一定可以表示成素数的积，所以当前被除数一定不能被这个除数整除，所以就直接找下一个了，好像挺节省时间的（方法在这段代码的下一段）。）

```
#include <iostream>
#include <cmath>
using namespace std;
 
const int MAXN=100000+1;//MAXN应该取上限的 开根号 +1
const int MAXC=10000;
 
bool isPrime[MAXN];
int num[MAXC];//用来存储素数，如果用vector会耗时一点
int mount=0;
 
void initial(){
    int bound = sqrt(MAXN);
    int count=0;
    for(int i=0; i<MAXN; i++)
        isPrime[i]=true;
    isPrime[0]=false;
    isPrime[1]=true;
     
    for(int i=2; i<MAXN && count<MAXC; i++){//添加了count的条件
        if(!isPrime[i])
            continue;
        num[count]=i;
        count++;
        //***********防止越界**************
        if(i>=bound)
            continue;
        //********************************
        for(int j=i*i; j<MAXN; j+=i)
            isPrime[j]=false;
    }
    mount=count;
        return ;
}
 
int getPriNum(int x){
    int q=0;
    for(int i=0;i<mount && num[i]<=sqrt(x);){//注意这里 没有i++
        if(x%num[i]==0){
//                cout<<num[i];
            q++;
            x/=num[i];
//            cout<<" "<<x<<endl;
            i=0;//每次找到合适的后都重置i
        }
        else i++;//i++在这
    }
    if(x>1)
        q++;//表示当前x就是质数 
    return q;
}
 
int main(){
    int n;
    initial();
    while(cin>>n){
        cout<<getPriNum(n)<<endl;
    }
    return 0;
}
```

**评论区大佬的方法：**

```
#include <iostream>
#include <cmath>
using namespace std;
int main(){
    //这题的关键：
    //1、是sqrt,可以极大减少复杂度，若是到方根N仍大于1，则必还有且只还有1个质因数
    //2、每次瞬间整除都可帮助减少遍历范围
    long M=100;
    while(cin>>M){
        long count=0;
            for(long j=2;j<=sqrt(M);j++){
             while(M%j==0)
             {
                 M=M/j;
                 count++;
             }
             if(M<=1)break;
            }
        if(M>1)count++;
        cout<<count<<endl;
    }  
    return 0;
}
```



### 约数的个数

http://t.cn/Aip7dTUp

约数是对称的啊！！！一定要对称计算，否则超时！

还有sqrt运算耗时，应该事先赋值到bound上再带入循环

```
#include <iostream>
#include <cmath>
using namespace std;

int main(){
    int n;
    while(cin>>n){
        while(n--){
            int temp,num=0;
            cin>>temp;
            if(temp!=1){
                int i;
                int bound=sqrt(temp);
                for(i=1; i<bound; i++)
                    if(temp%i==0)
                        num+=2;
                if(i*i==temp)
                    num++;
            }
            else num=1;
            cout<<num<<endl;
        }
    }
    return 0;
}
```



### <font color=red>整除问题</font>

http://t.cn/Aip7eHBD

这一题 **不能** 暴力（先计算阶乘再分解），因为阶乘会溢出！！！

具体细节见"题目无关.md"中的<font color=red>阶乘的质因数分解</font>

（我没做出来，但我看懂了评论区大神的代码）

```
#include <cstdio>
#include <vector>
#include <cmath>
#include <algorithm>
using namespace std;
const int MAXN=1010;
const int INF=(1<<31)-1;
//素数筛
bool p[MAXN]={false};//未被筛选
vector<int> prime;
void getPrime(){
    p[0]=p[1]=true;//被筛去，不是素数
    for(int i=2;i<MAXN;i++){
        if(p[i]==false){//未被筛去，是素数
            prime.push_back(i);
            for(int j=i+i;j<MAXN;j+=i)
                p[j]=true;
        }
    }
}
int nFac[MAXN]={0};//记录n!的质因数分解后的结果，n!存在质因数i，则aFac[i]=指数
int aFac[MAXN]={0};//记录a的质因数分解的结果，a存在质因数i，则aFac[i]=指数
//对n!质因子分解（确实是n!）
//prime={2,3,5,7,11,13,17......}
//以10!为例， 10! = 2*3*4*5*6*7*8*9*10 = 2^8 * 3^4 * 5^2 * 7.
void getnFac(int n){
    for(int i=0;prime[i]<=n;i++){//对每一个质因数的指数进行计算
        int pow=0;
        int tempn=n;//n=10, i=0, prime[i]=2时
        while(n!=0){
            pow+=n/prime[i];// pow=5,7,8,8
            n/=prime[i];//n=5,2,1,0
        }
        nFac[prime[i]]=pow;//nFac[2]=9
        n=tempn;//还原n
    }
}
//对a质因子分解
int getaFac(int a){
    int ans=INF;
    int sqr=sqrt((double)a);
    for(int i=0;prime[i]<=sqr;i++){
        //注意，这里不是把a展开完再判断，而是从最小的质因数开始边算边判断，如果存在着nFac[prime[i]]<aFac[prime[i]]，则中断了
        while(a%prime[i]==0){
            aFac[prime[i]]++;
            a/=prime[i];
        }
        //prime[i]是a的质因子
        if(aFac[prime[i]]>0){
            //prime[i]不是n!的质因子
            if(nFac[prime[i]]==0)//其实这个可以合并到下面的，不过这样写会节省点比较的时间
                ans=0;
            //取相同质因子的指数相除最小的
            else if(nFac[prime[i]]/aFac[prime[i]]<ans)
                ans=nFac[prime[i]]/aFac[prime[i]];
        }
        if(a==1)//已经被完全分解
            break;
    }
    if(a!=1){
        //剩下一个大于根号a的数（即a本身就是质数）是a的质因子，例如：a=47
        aFac[a]++;
        //剩下一个大于根号a的数不是n!的质因子
        if(nFac[a]==0)
            ans=0;
        //取相同质因子的指数相减最小的
        else if(nFac[a]/aFac[a]<ans)
            ans=nFac[a]/aFac[a];
    }
    return ans;
}
int main(){
    int n,a;
    scanf("%d%d",&n,&a);
    getPrime();
    getnFac(n);
    int ans=getaFac(a);
    printf("%d",ans);
    return 0;
}

```

评论区精简的写法：

```
#include<stdio.h>
#define N 1010
int prime[N];
int primesize;
bool mark[N];
void init(){
    for(int i=0;i<N;i++)
        mark[i]=false;
    for(int i=2;i<N;i++){
        if(mark[i]==true) continue;
        else{
            prime[primesize++]=i;
            for(int j=i*i;j<N;j+=i)
                mark[j]=true;
        }
    }
}
int main(){
    init();
    int a,n;
    while(scanf("%d%d",&n,&a)!=EOF){
        int count1[N]={0};
        int count2[N]={0};
        for(int i=0;i<primesize;i++){//下面是不是应该加一个 if(prime[i]>n) break;  ?
            int t=n;
            while(t){
                count1[i]+=t/prime[i];
                t/=prime[i];
            }
        }
        int ans=233333333;
        for(int i=0;i<primesize;i++){//这里也是，应不应该加一个if(prime[i]>a) break;
            while(a%prime[i]==0){
                count2[i]++;
                a/=prime[i];
            }
            if(count2[i]==0) continue;
            if(count1[i]/count2[i]<ans)
                ans=count1[i]/count2[i];
        }
        printf("%d\n",ans);
    }
    return 0;
}
```



## 快速幂

### <font color=purple>求root(N,k)</font>

http://t.cn/AipAw4B1

我裂开了，这题我不会

https://www.nowcoder.com/questionTerminal/9324a1458c564c4b9c4bfc3867a2aa66?f=discussion

**<font color=blue>法1:</font>**

数学推导

<img src="/Users/yy/Downloads/typora图片/root数学推导.png" alt="root数学推导" style="zoom: 67%;" />	

通过数学公式推导： $N^r = N\%(k-1)$

由此得到最终的结果值为 $N\%（k-1）$,当值为0时由于值域限制>0，结果就为k-1。

问题就转为求 $N\%（k-1）$

再使用**快速幂取模**



**<font color=blue>法2:</font>**（来自评论区）

关键在于等式
$$
root(x*y,k) = root(root(x,k)*root(y,k),k)
$$
所以有如下例 $root(x^{111},k) = root(root(x^{100},k)*root(x^{10},k)*root(x,k),k)$
其中 $root(x^{100},k) = root(root(x^{10})*root(x^{10}),k)$
$root(x^{10},k) = root(root(x,k)*root(x,k),k) $
（次数为二进制表示）
过程类似二分求幂 只是穿上了root的外套 

```
#include <stdio.h>
 
int root(int N,int k)
{
    if(N >= k)
    {
        int num = 0;
        while(N != 0)
        {
            num += N%k;
            N /= k;
        }
        return root(num,k);
    }
    else
        return N;
}
void get(int x,int y,int k)  // root(x*y,k) = root(root(x,k)*root(y,k),k)
{
    int tmp = root(x,k);
    int rtn = 1;
    while(y>0)
    {
        if(y%2 == 1)
        {
            rtn = root(rtn*tmp,k);
        }
        tmp = root(tmp*tmp,k);
        y/=2;
    }
    printf("%d\n",rtn);
}
int main()
{
    int x,y,k;
    while(scanf("%d%d%d",&x,&y,&k) != EOF)
    {
        get(x,y,k);
    }
}
```



## 矩阵与矩阵快速幂

### 矩阵幂

http://t.cn/Aip4T3HX

放个板子吧

```
#include <iostream>
#include <cstdio>
using namespace std;
 
struct Matrix{
    int matrix[10][10];
    int row,col;
    Matrix(int r, int c): row(r),col(c){}
};
 
void printMatrix(Matrix x){
    for(int i=0; i<x.row; i++){
        for(int j=0; j<x.col; j++){
            if(j!=0)
                cout<<" ";
            cout<<x.matrix[i][j];
        }
        cout<<endl;
    }
    return ;
}
 
Matrix Multiply(Matrix x, Matrix y){
    Matrix ans(x.row, y.col);
    //矩阵一开始需要初始化！！！！！！！！！！！
    for(int i=0; i<ans.row; i++)
        for(int j=0; j<ans.col; j++){
            ans.matrix[i][j]=0;
            for(int k=0; k<x.col; k++)
                ans.matrix[i][j]+=x.matrix[i][k] * y.matrix[k][j];
        }
     
    return ans;
}
 
 
 
Matrix FastE(Matrix x, int k){
    Matrix ans(x.row, x.col);
    //初始化单位矩阵
    for(int i=0; i<ans.row; i++){
        for(int j=0; j<ans.col; j++){
            if(i==j)
                ans.matrix[i][j]=1;
            else
                ans.matrix[i][j]=0;
        }
    }
    while(k!=0){
        if(k%2==1){
            ans = Multiply(ans, x);
        }
        k/=2;
        x = Multiply(x,x);
    }
    return ans;
}
 
 
int main(){
    int n,k;
    while(cin>>n>>k){
        Matrix x(n,n);
        for(int i=0 ; i<n; i++)
            for(int j=0; j<n; j++)
                cin>>x.matrix[i][j];
//        printMatrix(x);
        Matrix ans = FastE(x,k);
        printMatrix(ans);
    }
    return 0;
}
```



## 高精度整数



# 贪心策略

## 简单贪心

### 代理服务器

http://t.cn/E9emuS9

分析：


​    题目里说：系统在同一时刻只能使用一个代理服务器
​    每次切换服务器的时候表明 当前服务器需要访问和它ip相同的服务器
​    为了使切换次数尽可能的少，我们需要使一个服务器访问的尽可能的多
​    即 发生重名的事件尽可能的出现在后面

**注：题目所给的需要访问的ip是有顺序的**

1.“若没有符合要求的安排方式，则输出-1。”这种情况是只有一个代理服务器，然后在需要访问的服务器的ip正好有和代理服务器ip相同的。那么这样无法访问

2.一般情况下，要使切换次数尽可能的少，那就需要选一个代理服务器，它能访问最多的ip



<font color=gray>例如，（为了简便用一个字母替代ip）</font>

<font color=gray>有代理服务器ip：B，C，E</font>

<font color=gray>需要访问的ip： A，B，C，D，E，F</font>

<font color=gray>那么如果先选择使用B，一次最多只能访问第一个ip</font>

<font color=gray>先使用C，一次最多可访问A，B两个ip</font>

<font color=gray>先使用E的话，最多可访问A，B，C，D共四个ip</font>

当检测完所以的代理服务器之后，选择E，然后此时还有没访问的ip，所以需要进行代理服务器切换

此时还剩下E，F。 可以选择B，C任意一个代理服务器进行访问

```
#include <iostream>
#include <string>
#include <cstring>
#include <algorithm>
#include <cstdio>
#include <vector>
using namespace std;

int n,m;
vector<string>agency;
vector<string>server;

int main(){
    string ip;
    while(cin>>n){
        for(int i=0; i<n;i++){
            cin>>ip;
            agency.push_back(ip);
        }
        cin>>m;
        for(int i=0; i<m; i++){
            cin>>ip;
            server.push_back(ip);
        }
        if(n==1){
            int flag=0;
            for(int i=0; i<m; i++){
                if(server[i]==agency[0])
                    flag=1;
            }
            if(flag){
                cout<<-1<<endl;
                break;
            }
            cout<<m-1<<endl;
        }
        else{
            int start=0;//遍历访问服务器
            int times=0;//需要切换的次数
            while(start!=m){
                //由于至少有两个代理服务器，所以count最终不可能为0
                int count =0;//count表示当前代理服务器所能访问ip的最大数量
                for(int i=0; i<n; i++){
                    int j=start;
                    while(!(agency[i]==server[j]) && j<m)
                        j++;
                    if(j-start>count)
                        count=j-start;
                }
                times++;//当目前可用的代理服务器用完时，需要切换
                start+=count;//更新起点
            }
            cout<<times-1<<endl;
        }
    }
    return 0;
}

```



## 区间贪心

### Case of Fugitive

代码在书上，有空搬上来



### To Fill or Not to Fill

https://www.nowcoder.com/questionTerminal/f7eba38f7cd24c45982831e0f38518f9?toCommentId=5250277&ran=749

这道题写吐了我。。。

思路一开始想错了按价格升序， 后来才意识到应该按distance升序排列

过程思路在代码的注释中，只要把注释掉的代码取消注释，然后用例子输出一下就知道过程了

```
先按距离进行排序
设置sign=0
能否到达下一个加油站（默认我们先到第一个加油站，即初始化next=0）
      设置sign=1
      更新当前距离、剩余油量等参数，令当前站的下标为temp
      看看如果在此站 加满油 后能否到达比本站油价更低的
              如果有，看看当前剩余油够不够到,并令next=油价更低的站
                      如果能到的话，不用加了直接
                      如果不能到，加到足够撑到油价更低的站就行了
              如果没有更低的站
                      看看当前剩余的油能到终点，直接break
                      如果需要加一点才能到终点，加一点
                      如果不能到终点，加满，并令next=temp+1
如果sign=0，表示到不了下一个加油站了，按失败情况输出
```



```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

struct station{
    double pri;
    double dis;
    bool visited;
    int index;
};

station sta[500];

bool cmp(station x, station y){
    if(x.dis==y.dis){
        return x.pri<y.pri;
    }
    else return x.dis<y.dis;
}

int main(){
    int N;
    double Cmax,wholeDis, aveDis;
    while(cin>>Cmax){
        cin>>wholeDis>>aveDis>>N;
        for(int i=0;i<N; i++){
            cin>>sta[i].pri>>sta[i].dis;
            sta[i].visited=false;
            sta[i].index=i;
        }

        sort(sta,sta+N,cmp);

        double currentDis=0;//当前行驶距离
        double currentFuel=0;//当前油量
        double wholePri=0;//总费用
        double consume=-1;//和目标加油站相差的油量
        double cost=-1;//（临时变量用于解释）
        int temp=-1;//临时变量，当前加油站的编号
        int fail=0;//无法到达目的地
        int succeed=0;//可以到达目的地
        double dif=-1;//（临时变量用于解释）
        double finalDis=0;//最远行驶距离
        double tempPri=-1;//（临时变量用于解释）
        int next = 0;
//        for(int i=0; i<N; i++)
//            cout<<sta[i].pri<<" "<<sta[i].dis<<endl;

        while(true){
            if(succeed)
                break;
            int sign=0;//默认到不了更远的加油站
            for(int i=next; i<N; i++){
                if(currentDis+currentFuel*aveDis>=sta[i].dis) {//能顺利到达下个加油站
                    sign = 1;
                    sta[i].visited = true;
                    currentFuel -= (sta[i].dis - currentDis) / aveDis;//到达此加油站剩余的油量
                    currentDis = sta[i].dis;//更新当前位置
                    temp = i;
//                    cout << "当前位于加油站" << temp << "  当前位置:" << currentDis << "  当前油量:" << currentFuel << endl;

                    //计算下一个要去的加油站
                    double minPri = 99999999999;

                    int flag = 0;//默认能到达的加油站没有比它价格更小的
                    for (int j = temp + 1; j < N; j++) {
                        if (currentDis + Cmax * aveDis >= sta[j].dis && !sta[j].visited&&sta[j].pri < sta[i].pri) {//此加油站能到达的，比它价格更小的
                            next = j;
                            flag = 1;
                            break;
                        }
                    }
                    if (flag) {//加到够到目标站的就行了
                        if(currentDis + currentFuel*aveDis <sta[next].dis) {//如果当前的油不够到目标站的
                            consume = (sta[next].dis - currentDis) / aveDis;//需要的油量
                            dif = (consume - currentFuel);
                            cost = (consume - currentFuel) * sta[i].pri;
                            wholePri += (consume - currentFuel) * sta[i].pri;
                            currentFuel = consume;
                            flag = 0;
//                            cout << "下一站想去：" << next << "  目标位置:" << sta[next].dis << "  需要油量：" << consume << endl;
//                            cout << "加了" << dif << " 花费：" << cost << endl;
                            break;
                        }
                        else{
//                            cout<<"此加油站不加油"<<endl;
                            break;
                        }

                    } else {//没找到价格更低的，加到下个重点或者全都加满
                        if (currentDis + currentFuel * aveDis >= wholeDis) {//剩余油足够到达终点
                            succeed = 1;//不加了
                            break;
                        } else if (currentDis + Cmax * aveDis >= wholeDis) {//再加一些能到达终点
                            consume = (wholeDis - currentDis) / aveDis;
                            dif = (consume - currentFuel);
                            cost = (consume - currentFuel) * sta[i].pri;
                            wholePri += (consume - currentFuel) * sta[i].pri;
                            succeed = 1;
//                            cout << "加了" << dif << " 花费：" << cost << endl;
                            break;
                        } else {//加满
                            dif = (Cmax - currentFuel);
                            cost = (Cmax - currentFuel) * sta[i].pri;
                            wholePri += (Cmax - currentFuel) * sta[i].pri;
                            currentFuel = Cmax;
//                            cout << "加了" << dif << " 花费：" << cost << endl;
//                            cout << "####已加满油####" << endl;
                            next=temp+1;
                            break;
                        }
                    }
                }
            }

            if(sign==0){
                finalDis=currentDis+Cmax*aveDis;
                fail=1;
                break;
            }
        }
        if(succeed)
            printf("%.2lf\n",wholePri);

        if(fail)
            printf("The maximum travel distance = %.2lf\n",finalDis);
    }
    return 0;
}

```



# 递归与分治

## 递归策略

### 杨辉三角形（水题）

http://t.cn/Ai0KcLRI

**非递归**

```
#include <iostream>
#include <cstdio>
using namespace std;

int a[1000][1001];

int main(){
    int n;
    for(int i=0; i<1000;i++)
        for(int j=0; j<1000; j++)
            a[i][j]=0;
    while(cin>>n){
        a[1][1]=1;
        a[1][2]=1;
        for(int i=2; i<n; i++){
            for(int j=1; j<=i+1; j++){
                a[i][j]=a[i-1][j-1]+a[i-1][j];
            }
        }
        for(int i=1;i<=n-1;i++){
            for(int j=1; j<=i+1; j++){
                cout<<a[i][j]<<" ";
            }
            cout<<endl;
        }
    }
    return 0;
}

```

**递归**

```
#include <iostream>
#include <cstdio>
using namespace std;

int YH(int i, int j){
    if(j==1)
        return 1;
    else if(j==i+1)
        return 1;
    else return YH(i-1,j-1)+YH(i-1,j);
}

int main(){
    int n;
    while(cin>>n){
        for(int i=1;i<=n-1;i++){
            for(int j=1; j<=i+1; j++){
                cout<<YH(i,j)<<" ";
            }
            cout<<endl;
        }
    }
    return 0;
}
```



### 全排列

http://t.cn/Ai0K0hXZ

思路：

需要先进性字典排序

void permute(int start) 表示从start到结尾为后续串，0到start-1为前缀，后续串需要进行全排列

逐个扫描后续串，当遇到一个不在前缀中的字符时，加入到前缀中（严格来说不是加入，而是替换），然后递归调用permute(start+1)； 如果当前字符已经在前缀中，向后继续扫描

```
#include <iostream>
#include <cstring>
#include <string>
#include <cstdio>
#include <algorithm>
using namespace std;

string str;
char pre[7]={0};

void permute(int start){
    if(start==str.length()){
        for(int i=0; i<str.size(); i++)
            cout<<pre[i];
        cout<<endl;
    }
    else{
        char ch;
        int flag=0;
        for(int i=0; i<str.length();i++){
            ch=str[i];
            flag=0;//初始化当前字符不在pre中
            for(int j=0; j<start;j++){//在pre中寻找该字符
                if(pre[j]==ch){//我把j写成i了卡了半天！！！！！！！！！！！！！！！！！！！！！！1
                    flag=1;//找到了
                    break;
                }
            }
            if(flag)
                continue;//继续下一个
            pre[start]=ch;
            permute(start+1);
            
        }
    }
}

int main(){
    while(cin>>str){
        sort(str.begin(),str.end());
        
        permute(0);//开始以start开始为后续串的全排列
        cout<<endl;
    }
}

```



## 分治法

### 幂次方

https://blog.csdn.net/qq_43510916/article/details/104112680

没注意我申请的是全局变量，低级错误卡了半天

```
#include <iostream>
#include <cstdio>
using namespace std;
#define max 15

//快速幂
int FastE(int a, int b){
    int ans=1;
    while(b!=0){
        if(b%2==1)
            ans *=a;
        b/=2;//可以改成b>>=1
        a*=a;
    }
    return ans;
}

void powPrint(int n){
    int flag[max];//去特么的全局变量

    int num=0;//num为n的项的个数
    for(int i=0;i<max;i++)
        flag[i]=0;
    while(n!=0){
        for(int i=max-1; i>=0; i--){
            int temp=FastE(2,i);
            if(n>=temp){
                flag[i]=1;
                n-=temp;
                num++;
            }
        }
    }
    for(int i=max-1;i>=0;i--){
        if(flag[i]){
            if(num==0)
                break;
            if(i==0||i==2)
                cout<<2<<"("<<i<<")";
            else if(i==1)
                cout<<2;
            else {
                cout<<2<<"(";
                powPrint(i);
                cout<<")";
            }
            
            if(num!=1)
                cout<<"+";
            num--;
        }
    }
}

int main(){
    int n;
    while(cin>>n){
        powPrint(n);
        cout<<endl;
    }
    return 0;
}

```





# 搜索

## 宽度优先搜索

### Catch That Cow

http://poj.org/problem?id=3278

理解不难，但是，，容易超时。

一开始我是放在函数里运行的，不行。然后放在main里也不行

问题出在进入队列上面

我之前用的for循环(int i=0; i<3; i--)

然后i=1,2,3时分别对应三个状态，先声明一个location temp 并且赋值，再判断是否越界、是否已经访问。

这样会超时。

然后我改成了取消for循环变为三个if，并且先判断是否越界、已经访问，然后再入队。

```
else{
	if(l.num-1>=0 && !visited[l.num-1]){
		loc.push(location(l.num-1,l.layer+1));
		visited[l.num-1]=true;
	}
	if(l.num+1<=MAXN && !visited[l.num+1]){
		loc.push(location(l.num+1,l.layer+1));
		visited[l.num+1]=true;
	}
	if(l.num*2<=MAXN && !visited[l.num*2]){
		loc.push(location(l.num*2,l.layer+1));
		visited[l.num*2]=true;
	}
	loc.pop();
}
```

**完整代码：**

```
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;
#define MAXN 100001

int k;
struct location{
    int num;
    int layer;
    location(int n, int l): num(n), layer(l){}

};


bool visited[MAXN];


int main(){
    int n;
    while(cin>>n>>k){
        for(int i=0;i<MAXN; i++)
            visited[i]=false;

        queue<location>loc;
        location start(n,0);
        loc.push(start);
        visited[start.num] = true;

        while(!loc.empty()) {
            location l = loc.front();
//            cout<<"当前位置："<<l.num<<endl;

            if (l.num == k){
                cout << l.layer << endl;
                break;
            }
            else{
                if(l.num-1>=0 && !visited[l.num-1]){
                    loc.push(location(l.num-1,l.layer+1));
                    visited[l.num-1]=true;
                }
                if(l.num+1<=MAXN && !visited[l.num+1]){
                    loc.push(location(l.num+1,l.layer+1));
                    visited[l.num+1]=true;
                }
                if(l.num*2<=MAXN && !visited[l.num*2]){
                    loc.push(location(l.num*2,l.layer+1));
                    visited[l.num*2]=true;
                }
                loc.pop();
            }
        }
//        cout<<loc.empty()<<endl;

    }
    return 0;
}



```



### <font color=blue>Find The Multiple</font>

在POJ上超时，在vjudge上能过

https://vjudge.net/problem/POJ-1426

http://poj.org/problem?id=1426

并不难，但是一开始没想到队列，不知道怎么切换增加0和1

BFS和队列有很多联系！

```
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;

int n;
void BFS(long long x){
    queue<long long>longList;
    longList.push(x);

    while(!longList.empty()){
        long long num=longList.front();
//            cout<<"当前搜索："<<num<<endl;
        longList.pop();
        if(num%n==0){
            cout<<num<<endl;
            break;
        }
        else{
            longList.push(num*10);
            longList.push(num*10+1);
        }
    }
}


int main(){
    while(cin>>n&&n){
        BFS(1);
    }
    return 0;
}
```



### <font color=blue>玛雅人的秘密</font>

http://t.cn/Ai0lUhJj

第一次用map。一开始用的bool visited数组存储是否访问，然后用stoll将字符串转化为long long，结果数组越界了（不出所料）

然后使用map，挺好用的。

```
#include <iostream>
#include <queue>
#include <cstdio>
#include <string>
#include <cstring>
#include <map>
using namespace std;

struct node{
    string s;//字符串
    int times;//移动的次数
    node(string ss, int t):s(ss), times(t){}
};

string ans="2012";
int n;//字符串长度


void BFS(queue<node>q, map<string,int>mymap, int num){
    while(!q.empty()){
        node temp=q.front();
        q.pop();

        int pos=temp.s.find(ans);//寻找是否有目标子串
        if(pos!=string::npos){
            cout<<temp.times<<endl;
            break;
        }
        else{
            for(int i=0; i<n-1; i++){//交换操作
                string ss=temp.s;
                char t=ss[i];
                ss[i]=ss[i+1];
                ss[i+1]=t;
                
                map<string,int>::iterator it;
                it=mymap.find(ss);//查找这个是否已经搜索过
                if(it==mymap.end()){
                    q.push(node(ss,(temp.times+1)));//没有搜索过，进队
                    mymap.insert(pair<string,int>(ss,++num));//进入map
                }
            }
        }
    }
}

int main(){
    while(cin>>n){

        queue<node>q;//搜索队列
        map<string,int>mymap;//存储已经搜索过的字符串
        
        string str;
        cin>>str;
        int flag=0;
        int i;
        //如果字符串不包含0或1，或者不包含至少两个2
        for(i=0;i<3;i++){
            if(i==0){
                int pos=str.find('0');
                if(pos==string::npos){
                    cout<<-1<<endl;
                    break;
                }
            }
            if(i==1){
                int pos=str.find('1');
                if(pos==string::npos){
                    cout<<-1<<endl;
                    break;
                }
            }
            if(i==2){
                int pos=str.find('2');
                if(pos==string::npos){
                    cout<<-1<<endl;
                    break;
                }
                
                else{
                    pos++;
                    pos=str.find('2',pos);
                    if(pos==string::npos){
                    cout<<-1<<endl;
                    break;
                    }
                }
            }
        }
        if(i==3) flag=1;
        if(flag){
            int num=0;
            mymap.insert(pair<string,int>(str,0));
            q.push(node(str,0));
            BFS(q,mymap,num);
        }
        
    }
    return 0;
}

```



## 深度优先搜索

### A Knight's Journey

https://vjudge.net/problem/POJ-2488

http://poj.org/problem?id=2488

POJ里用G++能过，C++就超时...



注意输出结果要按照字典序排列，所以在设置方向的时候就不是随意设置的了。

需要使得Y尽可能的小，在Y相同的时候使X尽可能的小。



另外，递归函数里有一段这样的调用

```
DFS(nextx,nexty,num+1, ans+coY+coX)
```

不能写成 num++; ans=ans+coY+coX; 然后再DFS(nextx,nexty,num, ans)

因为这样的状态返回的时候，num和ans已经改变的还原不回来

**完整代码：**

```
#include <iostream>
#include <cstdio>
#include <string>
#include <cstring>
using namespace std;

int p,q;
bool visited[8][8];

//答案需要按照字典序！！！！！！
//X表示行，Y表示列
//所以应该让Y小的放在前面，Y相等时X小在前
int direction[8][2]={
        {-1,-2}, {1,-2}, {-2,-1}, {2,-1}, {-2,1}, {2,1}, {-1,2}, {1,2}
};


//坐标是列在前啊喂   (0,0)对应A,1,  (m,n)对应 'A'+m, '1'+n
bool DFS(int x, int y, int num, string ans){//从(x,y)开始DFS
//    cout<<ans<<"    num="<<num<<endl;
    if(num==p*q){
        cout<<ans<<endl<<endl;
        return true;
    }
    else{
        for(int i=0; i<8; i++){//在一个位置有8种走法
            int nextx= x+direction[i][0];
            int nexty= y+direction[i][1];
            if(nextx>=0 && nextx<p && nexty>=0 && nexty<q && !visited[nextx][nexty]){//如果没有越界也没有访问过
                visited[nextx][nexty]=true;

                char coX= nextx+'1';
                char coY= nexty+'A';

                //不能先令num++再调用DFS，因为这样会更改当前层的num，导致如果下一层走不通返回时num的值不一样！
                //同理ans也不能先更新
                //递归函数里的参数要用表达式的写法
                //ans是列在前
                if(DFS(nextx,nexty,num+1, ans+coY+coX)){//如果从(nextx,nexty)继续搜索，有解的话直接向上返回
                    return true;
                }
                visited[nextx][nexty]=false;//表示这个(nextx,nexty)无解，则取消它的访问
            }
        }
    }
    return false;
}


int main(){
    int n;
    cin>>n;
    int count=0;
    while(n--){
        cout<<"Scenario #"<<++count<<":"<<endl;
        cin>>p>>q;

        memset(visited,false,sizeof(visited));
        visited[0][0]=true;


        string ans="A1";//从A1开始搜是字典序最小的
        if(DFS(0,0,1,ans)){//从(0,0)即A1开始搜，如果有解则输出

        }
        else{
            cout<<"impossible"<<endl<<endl;
        }
    }
    return 0;
}
```



### Squre

http://acm.hdu.edu.cn/showproblem.php?pid=1518

 不难

能立刻排除掉的情况：总长度不能被4整除； 最长的棍子大于平均长度



给棍子降序排序，然后一个棍子一个棍子攒，攒够了平均长度换下一个棍子。

当三根棍子都到达平均长度时，就不用继续算了，直接返回true

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

const int MAXN= 20;

int sticks[MAXN];
int length;
int ave;
bool visited[MAXN];
int n;

bool cmp(int x, int y){
    return x>y;
}

bool DFS(int current, int num, int pos){//当前长度、第几个棍子(0,1,2,3)、sticks数组的下标
     if(num==3){//前三根都凑成平均了，最后一根一定是平均，不用找了
         return true;
     }
     else{
         for(int i=pos; i<n ;i++){//每次从pos下标开始找

             if(current+sticks[i]<=ave && !visited[i]){//如果小于等于平均长度并且这根棍子没有使用过，则继续搜索
//                  cout<<"当前长度："<<current<<"   当前序号："<<num<<"   正在搜索："<<sticks[i]<<endl;
                visited[i]=true;//标记棍子已使用
                if(current+sticks[i]==ave){//当前num的棍子的长度合适了
                    if(DFS(0,num+1,0))
                        return true;
                }
                else{
                    if(DFS(current+sticks[i],num,i+1)){//这里pos赋值为i+1是因为，棍子长度是按降序排列的，当前长度不够，要寻找更小的
                        return true;
                    }
                }
                visited[i]=false;//如果执行到这，说明上面并没有返回true，即无解，这时要取消标记
             }
         }
         return false;//for循环都循环完了还没找到，那就无解了
     }
}

int main(){
    int N;
    while(cin>>N){
        while(N--) {
            cin >> n;
            length = 0;
            ave=0;
            for (int i = 0; i < n; i++) {
                cin >> sticks[i];
                length += sticks[i];
            }
            if (length % 4 != 0) {
                cout << "no" << endl;
                continue;
            }
            sort(sticks, sticks + n, cmp);//将木棍从大到小排列
            ave = length / 4;
            if (sticks[0] > ave) {//如果最长的木棍比平均值大
                cout << "no" << endl;
                continue;
            }
            //开始搜索
            memset(visited, false, sizeof(visited));

            if (DFS(0, 0, 0)) {
                cout << "yes" << endl;
            } else {
                cout << "no" << endl;
            }
        }
    }
    return 0;
}
```



### <font color= purple>神奇的口袋</font>

我是个憨批吧这么简单我都没写出来

http://t.cn/Ai0u0GUz

我一开始是拿的上一题Square的板子，但是上一题适合求有没有解。

方法有动态规划、递归、回溯	

核心就是 从前到后，对于当前的物品，要么拿，要么不拿。



**回溯法**

```
#include<iostream>
#include<string.h>
using namespace std;
int ans = 0, n, a[100] = {0};
void dfs(int x,int num){  //X为当前体积，num为刚取的物品的下标（物品只有一件，要避免重复取）

    if (x > 40)return;
    if (x == 40)
        ans++;

    for (int i = num+1; i < n; i++){
        x += a[i];//拿起
        dfs(x, i);//并继续搜索
        x -= a[i];//放下（回溯）
    }

}

int main(){
    while (cin >> n){
        memset(a, 0, sizeof(a));
        ans = 0;
        for (int i = 0; i < n; i++)
            cin >> a[i];

        dfs(0, -1);
        cout << ans << endl;
    }
    return 0;
}
```



**递归法**
$$
count(i,sum) = count(i+1, sum-a[i]) + count(i+1, sum)
$$


```
#include <iostream>
#include <cstdio>
using namespace std;

int n;
int a[20];

int count(int i, int sum){//i是物品的下标，sum是剩余需要的体积
//    cout<<i<<"  "<<sum<<endl;
    if(sum==0)//sum==0要放在前面 因为可能出现 i==n且sum==0的情况，如果放在后面就return 0了
        return 1;
    if(sum<0||i==n)
        return 0;
    else{
        //count(i+1, sum-a[i])表示拿a[i]的情况，count(i+1, sum)表示不拿
        return count(i+1, sum-a[i])+count(i+1, sum);
    }
}

int main(){
    while(cin>>n){
        for(int i=0; i<n;i++){
            cin>>a[i];
        }

        cout<<count(0,40)<<endl;

    }
    return 0;
}
```



**动态规划**

dp\[i]\[j]表示现在有i件物品，凑成体积为j的方法数
$$
dp[i][j]=
\begin{cases}
dp[i-1][j]& \text{j<a[i]}\\
dp[i-1][j] + dp[i-1][j-a[i]]& \text{j $\geq$ a[i]}
\end{cases}
$$


```
/**
 * 递推式
 *
 * 初始化 d[i][0]=1 不管有几件商品，凑成体积为0时只有一种方法就是全不拿
 *
 * 当j<a[i]时，第i件物品没法拿，所以方法数就等于i-1件时的方法数
 * dp[i][j] = dp[i-1][j]
 *
 * 当i>=a[i]时，可以选择拿或不拿
 * 不拿的方法数为 有i-1件时的方法数
 * 拿的方法数为 有i-1件时凑成体积 j-a[i] 时的方法数
 * dp[i][j] = dp[i-1][j] + dp[i-1][j-a[i]]
 */
```

```
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

int a[21];
int dp[21][41]; //dp[i][j]表示现在有i件物品，凑成体积为j的方法数

int main(){
    int n;
    while(cin>>n){
        //之前数组设小了啊啊啊啊啊啊啊啊啊啊啊
        for(int i=1; i<=n; i++)//下标从1开始 a[i]就是第i件物品的重量
            cin>>a[i];

        sort(a,a+n);

        for(int i=0; i<=n; i++){
            dp[i][0]=1;
        }

        for(int i=1; i<=n; i++){
            for(int j=1; j<=40; j++){
                if(j<a[i])
                    dp[i][j] = dp[i-1][j];
                else{
                    dp[i][j] = dp[i-1][j] + dp[i-1][j-a[i]];
                }
            }
        }

        cout<<dp[n][40]<<endl;
    }
    return 0;
}
```



### 八皇后

http://t.cn/Ai0uOazs

```
#include <iostream>
#include <cstdio>
#include <vector>
using namespace std;

vector<string>vec;
bool judge(int row, int col, string a){//a[i-1]表示第i行的列数
    if(row==1)
        return true;
    for(int i=1; i<row; i++){
        if(col+'0'==a[i-1])//在同一列
            return false;
        if((row-i == col+'0'-a[i-1]) || (row+col)== (i+(a[i-1]-'0')))//在对角线
            return false;
    }
    return true;
}

void DFS(int i, int j, string a){//在(i,j)处摆放，a为当前字符串
    if(judge(i,j,a)){//判断摆在(i,j)是否符合要求
        if(i==8){//如果符合要求并且i==8，即最后一行可以，则结果放入向量
            char ch=(j+'0');
            a+=ch;
            vec.push_back(a);
        }
        else{//否则继续搜索
            //对i+1行的各种情况进行搜索
            for(int col=1; col<=8;col++){
                if(col!=j){
                    char ch= j+'0';
                    DFS(i+1,col,a+ch);//在(i+1, col)处进行摆放
                }

            }
        }
    }
    else{
        return ;
    }

}
int main(){
    int num;
    string str;
    for(int col=1; col<=8; col++)//按顺序搜索八次，分别对应第一行放1～8
        DFS(1,col,str);
//    for(int i=0; i<=91;i++)
//        cout<<vec[i]<<endl;
    while(cin>>num){
        cout<<vec[num-1]<<endl;
    }
    return 0;
}
```



# 数据结构二

## 二叉树

注：二叉树的构建函数一般都是返回的构建完成的子树的根结点。

### 二叉树遍历（根据一种顺序来构建树，输入能判断空节点）

http://t.cn/AiKuUTlX

结构体要记清楚了，而且后面使用的时候都是用指针。

根据xx遍历创建树 和 遍历树 是差不多的。

```
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

string str;
int pos;

struct TreeNode{
    char data;
    TreeNode* leftChild;
    TreeNode* rightChild;
    //构造函数，记下来吧
    TreeNode(char c): data(c),leftChild(NULL),rightChild(NULL){}
};

void InOrder(TreeNode* root){//中序遍历
    if(root==NULL)
        return ;
    InOrder(root->leftChild);
    cout<<root->data<<" ";
    InOrder(root->rightChild);
}

TreeNode* createTree(){//通过前序遍历建立树
    //其实也就三部，和遍历类似：赋值根，递归建立左子树，递归建立右子树
    char c = str[pos++];
    if(c=='#'){
        return NULL;
    }
    TreeNode* root= new TreeNode(c);
    root->leftChild = createTree();
    root->rightChild = createTree();
    return root;
}

void deleteTree(TreeNode* root){//为了释放空间
    if(root==NULL)
        return;
    deleteTree(root->leftChild);
    root->leftChild=NULL;
    deleteTree(root->rightChild);
    root->rightChild=NULL;
    free(root);
}

int main(){
    while(cin>>str){
        pos=0;
        TreeNode* root = createTree();
        InOrder(root);
        cout<<endl;
        deleteTree(root);
    }
    return 0;
}
```



### 二叉树遍历（根据前序、中序构建树，输入不包含空结点）

http://t.cn/AiKgDfLU

分治+递归，每次取前序的第一位，在中序中找到它，并把中序以它为切割点分成两半

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
using namespace std;
 
struct TreeNode{
    char data;
    TreeNode* leftChild;
    TreeNode* rightChild;
};
 
int search(string str, char ch){
    for(int i=0; i<str.length();i++){
        if(ch==str[i])
            return i;
    }
    return -1;
}
 
//分治+递归，每次取前序的第一位，在中序中找到它，并把中序以它为切割点分成两半
TreeNode* Create(string PreO, string InO){
    if(PreO.length()==0)
        return NULL;
    TreeNode* root = new TreeNode;
    char ch =PreO[0];//取当前前序第一个ch
    root->data = ch;//赋值
 
    int pos = search(InO, ch);//在中序遍历中找到这个ch，并返回位置
    int leftNumber = pos;//有i个节点在它左边
    int rightNumber = InO.length()-pos -1;//有InO.length()-pos-1个节点在它右边
    string leftInO = InO.substr(0,leftNumber);//从InO[0]到InO[pos-1]
    string rightInO = InO.substr(pos+1);//InO[pos+1]到结尾
    string leftPreO = PreO.substr(1,leftNumber);
    string rightPreO = PreO.substr(pos+1);
 
    root->leftChild = Create(leftPreO, leftInO);
    root->rightChild = Create(rightPreO, rightInO);
 
    return root;
}
 
//后序遍历
void PostOrder(TreeNode* root){
    if(root==NULL)
        return ;
    PostOrder(root->leftChild);
    PostOrder(root->rightChild);
    cout<<root->data;
    return ;
}
 
int main(){
    string pre,in;
    while(cin>>pre){
        cin>>in;
        TreeNode* root = new TreeNode;
        root = Create(pre,in);
        PostOrder(root);
        cout<<endl;
    }
    return 0;
}
```



### 二叉树排序

http://t.cn/Ai9PAkkv

（相似的题 http://t.cn/AiKD0L5V）

递归建树，如果数组值比当前比较结点（代码里的old）大，则看old的右子树，如果右子树为空则插入，否则old指向old自己的右子树。左子树同理。

每次都是从根节点开始比较，先放自己的代码，之后放书本代码。

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
using namespace std;

int n;
int pos;//当前数组下标
struct TreeNode{
    int data;
    TreeNode* leftChild;
    TreeNode* rightChild;
    TreeNode* father;
    TreeNode(int a):data(a),leftChild(NULL),rightChild(NULL),father(NULL){}
};

void Build(TreeNode* root,int* num, int pos){
    if(pos==n)//超出范围了
        return;
    TreeNode* old = root; //初始指向root，用来后面比较
    TreeNode* current = new TreeNode(num[pos]);//为当前数组元素创造结点
    while(true){
        if(current->data>old->data) {
            if (old->rightChild == NULL) {//插入old左子树
                old->rightChild = current;
                current->father = old;
                cout<<old->data<<endl;
                pos++;
                Build(root, num, pos);
                return;
            } else {//否则old指向它的左子树
                old = old->rightChild;
                continue;
            }
        }
        else {
            if (old->leftChild == NULL) {
                old->leftChild = current;
                current->father = old;
                cout<<old->data<<endl;
                pos++;
                Build(root, num, pos);
                return;
            } else {
                old = old->leftChild;
                continue;
            }
        }
    }
}


int main(){
    while(cin>>n){
        int num[100];
        for(int i=0;i<n;i++)
            cin>>num[i];
        TreeNode* root = new TreeNode(num[0]);
        pos=1;
        cout<<-1<<endl;
        Build(root,num,pos);

    }
    return 0;

}
```

书本是在main函数里面用for循环一个一个插入，而且在输入的时候就插入了，很不错。（不过我觉得没我的好理解）

```
#include<iostream>
#include<cstdio>
 
using namespace std;
 
struct TreeNode{
    int data;
    TreeNode* leftChild;
    TreeNode* rightChild;
    TreeNode(int x): data(x),leftChild(NULL),rightChild(NULL){}
};
 
TreeNode* Insert(TreeNode* root,int x,int father){//把这个当成返回一个已经构建好的子树的根结点
    if(root==NULL){
        root = new TreeNode(x);
        cout<<father<<endl;
    }
    else if(x<root->data){
        root->leftChild = Insert(root->leftChild,x,root->data);
    }
    else if(x>root->data){
        root->rightChild = Insert(root->rightChild,x,root->data);
    }
    return root;
}
 
int main(){
    int N;
    int temp;
    TreeNode* root = NULL;
    cin>>N;
    for(int i=0; i<N; i++){
        cin>>temp;
        root = Insert(root,temp,-1);
    }
    return 0;
}
```





## 优先队列

### 复数集合

http://t.cn/Ai98yYlt

优先队列如果不是系统类型（比如自己定义的结构体）的话，需要自己重载运算符。

还有就是使用结构体的构造函数，之前二叉树声明root时经常用new来返回指针。而普通的结构体不要用new

```
#include <iostream>
#include <queue>
#include <cstring>
#include <algorithm>
#include <string>
using namespace std;

struct Complex{
    int real;
    int imag;
    Complex(int a, int b): real(a), imag(b){}
    bool operator< (Complex c) const{//重载运算符
        return real*real + imag*imag < c.real*c.real + c.imag*c.imag;
    }
};

int main(){
    int n;
    while(cin>>n){
        string instruction;
        string ins;
        priority_queue<Complex> priQue;//定义优先队列
        
        for(int i=0; i<n; i++){
            cin>>instruction;
            if(instruction=="Pop"){
                if(priQue.empty())
                    cout<<"empty"<<endl;
                else{
                    Complex current = priQue.top();
                    priQue.pop();
                    cout<<current.real<<"+i"<<current.imag<<endl;
                    cout<<"SIZE = "<<priQue.size()<<endl;
                }
            }
            else{
                cin>>ins;
                int pos= ins.find('+');
                string realstr = ins.substr(0,pos+1);//截取+前面的子串
                string imagstr = ins.substr(pos+2);//截取i后面的子串
                int realnum = std::stoi(realstr);//string转int
                int imagnum = std::stoi(imagstr);
                Complex current = Complex(realnum,imagnum);//这里没有new了，之前二叉树用new是为了返回指针
                priQue.push(current);
                cout<<"SIZE = "<<priQue.size()<<endl;
            }
        }
        
    }
    return 0;
}
```





### 查找第K小数

http://t.cn/AiCu5hcK

题目不难，这里分别写出两种数据结构的解法。

优先队列：

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <queue>
using namespace std;

int main(){
    int n;
    while(cin>>n){
        priority_queue<int, vector<int>, greater<int>> que;
        for(int i=0; i<n;i++){
            int temp;
            cin>>temp;
            que.push(temp);
        }
        int k;
        cin>>k;
        int pre=-1;
        int cur;
        while(k){
            cur = que.top();
            que.pop();
            if(cur!=pre)//如果和前一个不一样，再减。
                k--;
            pre=cur;
        }
        cout<<cur<<endl;
    }
    return 0;
}
```



map：（来自评论区）

他这里是把每次的输入都放到key里，然后对应的value设成一样的1。

map自动按key排序。并且遇到相同的key时不会引起size的增加。

妙啊。

```
#include <iostream>
#include <map>
using namespace std;
int main()
{
    int n,i,k,tmp;
    while(cin>>n)
    {
        map<int,int> mmap;
        for(i=0;i<n;++i)
        {
            cin>>tmp;
            mmap[tmp]=1;
        }
        cin>>k;
        auto it=mmap.begin();
        for(;it!=mmap.end()&&k!=1;++it,--k){}
        cout << it->first << endl;
    }
    return 0;
}
```



## 散列表

### 查找学生信息（基本题）

http://t.cn/AiCuVIuY

迭代器挺好用的

```
#include <iostream>
#include <map>
#include <cstdio>
#include <cstdlib>
using namespace std;

int main(){
    int N;
    while(cin>>N){
        map<string, string> stu;
        string num, info;
        for(int i=0; i<N; i++){
            cin>>num;//读取key
            getline(cin, info, '\n');//剩下的字符串通过getline接收
            stu.insert(pair<string, string>(num, info));//也可以直接用stu[num]=info赋值
        }
        int M;
        map<string, string>::iterator it;
        cin>>M;
        string key;
        while(M--){
            cin>>key;
            it = stu.find(key);
            if(it!=stu.end())//找到了。 注意，it->first之后自动有一个空格
                cout<<it->first<<it->second<<endl;
            else
                cout<<"No Answer!"<<endl;
        }
    }
    return 0;
}
```



### 子串计算

http://t.cn/AiCuJtI5

map内部自动按key的字典序排序

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <map>
#include <string>
using namespace std;

int main(){
    string str;
    cin>>str;
    map<string, int> myMap;
    string temp;
    for(int i=0; i<str.size(); i++){
        for(int j=i; j<str.size(); j++){
            temp = str.substr(i, j-i+1);
            myMap[temp]++;
        }
    }
    map<string, int>::iterator it;
    for(it= myMap.begin(); it!=myMap.end(); it++){
        if(it->second>1)
            cout<<it->first<<" "<<it->second<<endl;
    }
    return 0;
}
```



### 开门人和关门人

http://t.cn/AiCuM09f

第一遍我是用vector做的，类型是pair<string, string>，定一个cmp比较函数对vector排序一下输出。 

当时糊涂了以为时间不能按字典序排，就把id放在了第一个参数，也没用map。后来写着写着发现时间之间按string比较大小就能比出来。所以map更方便。

vector代码：

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <map>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

bool cmp1(pair<string, string>a, pair<string, string>b){//升序
    return a.second < b.second;
}

bool cmp2(pair<string, string>a, pair<string, string>b){//降序
    return a.second > b.second;
}


int main(){
    int n;
    while(cin>>n){
        vector<pair<string, string> > come;
        vector<pair<string, string> > leave;
        for(int i=0; i<n; i++){
            string id, cometime, leavetime;
            cin>>id>>cometime>>leavetime;
            come.emplace_back(pair<string, string> (id, cometime));
            leave.emplace_back(pair<string, string> (id, leavetime));
        }
        sort(come.begin(), come.end(), cmp1);
        sort(leave.begin(), leave.end(), cmp2);
        cout<<come[0].first<<" "<<leave[0].first<<endl;
    }
    return 0;
}
```



map代码：

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <map>
#include <string>
#include <algorithm>
using namespace std;


int main(){
    int n;
    while(cin>>n){
        map<string, string> come;
        map<string, string> leave;
        for(int i=0; i<n; i++){
            string id, cometime, leavetime;
            cin>>id>>cometime>>leavetime;
            come[cometime]=id;
            leave[leavetime]=id;
        }
        cout<<come.begin()->second<<" "<<leave.rbegin()->second<<endl;
    }
    return 0;
}
```



### 谁是你的潜在朋友

http://t.cn/AiCux4f7

这一题。。怎么说呢，很简单，但是起初用map做起来很别扭。放了4个for循环，主要是不知道怎么解决 读者-书-书的数量这三个的映射关系。

所以三个变量，用两个映射不就行了？

起初只想了一个map，还做了个count数组放在最后。

但是直接把count放在输入里就递增不就行了？

而且这道题读者编号是顺序的，map和数组没多大区别。

所以2个map或1map+1数组或2数组都可以。

2map：

```
#include<iostream>
#include<cstdio>
#include<map>
 
using namespace std;
 
int main(){
    int n,m;
    while(scanf("%d%d",&n,&m)!=EOF){
        map<int,int> book_num;//map<书编号,人数>
        map<int,int> stu_book;//map<读者号,书编号>
        for(int i=0;i<n;i++){//第i个读者
            int bookNumber;
            scanf("%d",&bookNumber);
            stu_book[i]=bookNumber;//第i个读者喜欢看的书编号为bookNumber；
            book_num[bookNumber]++;//同时把喜欢看书编号为bookNumber的人数+1
        }
        map<int,int>::iterator it;
        for(it=stu_book.begin();it!=stu_book.end();it++){//读者号从0~n-1
            int num=book_num[it->second]-1;//把自己减掉
            if(num==0){
                printf("BeiJu\n");
            }else{
                cout<<num<<endl;
            }
        }
    }
    return 0;
}
```

2数组：

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
 
using namespace std;
 
int main(){
    int n,m;
    cin>>n>>m;
    int reader[201]={0}, book[201]={0};
    for(int i=0;i<n;i++){
        int value;
        cin>>value;
        reader[i]=value;
        book[value]++;
    }
    int num;
    for(int i=0;i<n;i++){
        num = book[reader[i]];
        if(num==1)
            cout<<"BeiJu"<<endl;
        else
            cout<<num-1<<endl;
    }
    return 0;
}
```





# 图论

## 并查集

<font color=red>并查集真的好多地方都能用map啊</font>

### 畅通工程

http://t.cn/AiOvBHj9

并查集入门题。Find()函数包含了路径压缩。

并查集最常用来判断图是否为连通图，或用来求图的连通分量。

```
#include <iostream>
#include <cstdio>
using namespace std;

int MAXN = 1000;
int father[1000];
int height[1000];

int Find(int x){  //寻找节点x的根节点
    if (x!=father[x]){  //说明它不是一个树的根节点
        father[x] = Find(father[x]); //路径压缩
    }
    return father[x];
}

void Union(int x, int y){  //合并两棵树
    x = Find(x);
    y = Find(y);
    if(x==y)  //属于同一棵树，什么都不用做
        return;
    if(height[x]>height[y]){
        father[y] = x;  //y合入x
    }
    else if (height[x] < height[y]){
        father[x] = y;
    }
    else{
        father[y] = x;
        height[x]++;
    }
}


int main(){
    int N, M;
    while(cin>>N && N){
        cin>>M;
        //初始化
        for(int i=1; i<=N; i++){
            father[i] = i;
            height[i] = 0;
        }
        int x,y;
        while(M--){
            cin>>x>>y;
            Union(x, y);
        }
        int single = 0;
        for(int i=1; i<=N; i++){
            if(Find(i) == i)  //这棵树上只有自己一个（第一个节点除外）
                single++;
        }
        cout<<single-1<<endl;
    }
    return 0;
}
```



### <font color=blue>Is it A Tree?</font>

http://t.cn/AiO7FyDO

本来想用并查集做的，做着做着就变成暴力了。。。

通过率从1.x%到2.x%再到12.x%，特殊情况一个一个排除，最后ac了。

特殊情况有：只输入0 0； 输入有自环； 多父亲结点。



**我觉得两个方法可以合并一下，书本上的isTree()函数拿来用，但把数组全部替换成map。有空再说**



**暴力：**

```
#include <iostream>
#include <cstdio>
#include <map>
using namespace std;

int father[10000];
map<int, int>mymap;  //父子结点汇总
map<int, int>tail;  //子结点

void Union(int x, int y){  //合并两棵树
    father[y] = x;
}

int main(){
    int start, end;
    int count = 0;
    int Case = 1;
    bool flag = true;  //如果flag为false则确定不是一棵树（比如自环，多父亲结点等）
    bool noNode = true;  //如果最终为true，则表示输入只为 0 0
    //初始化
    for(int i=0; i<10000; i++){
        father[i] = i;
        mymap.clear();
        tail.clear();
    }
    while(cin>>start>>end){
        if(start==-1 && end==-1)//退出程序
            break;
        else if(start==0 && end==0){//一个测试的末尾，输出结果
            map<int, int>::iterator it;
            for(it=mymap.begin(); it!= mymap.end(); it++){//找出孤立节点
                if(father[it->first]==it->first)
                    count++;
            }
//            cout<<count<<endl;
            if((count==1 && flag) || noNode)  //正确的情况只有：孤立节点为1并且flag为true 以及 只输入0 0 的情况
                cout<<"Case "<<Case<<" is a tree."<<endl;
            else
                cout<<"Case "<<Case<<" is not a tree."<<endl;

            //初始化
            for(int i=0; i<10000; i++){
                father[i] = i;
                mymap.clear();
                tail.clear();
            }
            count =0;
            Case++;
            flag = true;
            noNode = true;
        }
        else{//正常输入
            noNode = false;  //只要有正常输入，不管是不是自环，都已经排除了只输入0 0 的情况
            if(start==end) {  //自环
                flag = false;
                continue;
            }
            mymap[start]=1;
            if(tail[end]==1)  //多父亲结点，立刻判断不是树
                flag = false;
            mymap[end]=1;
            tail[end]=1;
            Union(start, end); //合并，其实就一步
        }
    }
    return 0;
}
```

**并查集（书本）：**

```
#include <iostream>
#include <cstdio>
using namespace std;

const int MAXN=10000;

int father[MAXN];
int height[MAXN];
int inDegree[MAXN]; //入度
bool visit[MAXN];

void Initial(){
    for(int i=0; i<MAXN; i++){
        father[i] = i;
        height[i] = 0;
        inDegree[i] = 0;
        visit[i] = false;
    }
}

int Find(int x){
    if(x!=father[x])
        father[x] = Find(father[x]);
    return father[x];
}

void Union(int x, int y){
    x = Find(x);
    y = Find(y);
    if(x!=y){
        if(height[x]<height[y])
            father[x] = y;
        else if(height[y] < height[x])
            father[y] = x;
        else{
            father[y] = x;
            height[x]++;
        }
    }
    return ;
}

bool isTree(){
    bool flag = true; //初始化是个树
    int terminal = 0;  //父亲结点是自己的结点数
    int root = 0; //入度为0的个数
    for(int i=0; i<MAXN; i++){
        if(!visit[i])
            continue;
        if(father[i]==i)
            terminal++;
        if(inDegree[i]==0)
            root++;
        else if (inDegree[i]>1)
            flag = false;
    }

    if(terminal !=1 || root!=1)//不是树
        flag = false;
    if(terminal ==0 && root==0) //空集是树
        flag = true;
    return flag;
}

int main(){
    int x,y;
    int Case = 1;
    Initial();
    while(cin>>x>>y){
        if(x==-1 && y==-1)
            break;
        if(x==0 && y==0){//结束当前Case
            //输出结果
            if(isTree())
                cout<<"Case "<<Case<<" is a tree."<<endl;
            else
                cout<<"Case "<<Case<<" is not a tree."<<endl;
            Case++;
            //重新初始化
            Initial();
        }
        else{//正常输入
            Union(x,y);
            inDegree[y]++;
            visit[x] = true;
            visit[y] = true;
        }
    }
    return 0;
}
```



### 找出直系亲属

http://t.cn/AiOzTX5c

（别人的并查集解法我还没看）

自从学了map之后就不想用数组了。。。 

输入阶段给的输入数据三个字母，用map<char, string>分别存储第一个（孩子）和后两个（家长）。 

在判断关系时，先假设一个辈分比较大，DFS搜索。如果没有结果再假设另一个辈分大，再DFS。

```
#include <iostream>
#include <cstdio>
#include <map>
#include <cstring>
using namespace std;

map<char, string> parents;

int search(char a, char b, int level){//level表示当前的辈分级数，初始为0表示平辈
    int res;
    if(a==b)  //找到了
        return level;
    if(!a|| a=='-'){
        return -1;  //表示找到尽头了没找到
    }
    if(a!=b){
        res = search(parents[a][0], b, level+1);//先拿a的第一个家长和b比较
        if(res>0)
            return res;
        else
            res = search(parents[a][1], b, level+1);//拿a的第二个家长和b比较
        return res;
    }
}

int main(){
    int n,m;
    while(cin>>n>>m){
        parents.clear();
        string str;
        for(int i=0; i<n; i++){
            cin>>str;
            string parstr = str.substr(1,2);
            parents[str[0]] = parstr;
        }
        for(int j=0; j<m; j++){
            cin>>str;
            char a = str[0];
            char b = str[1];
            int res = search(a,b,0);  //假设b的辈分比a大
            if(res>0){//a的辈分小
                //输出结果
                string rank="";
                if(res==1) rank="child";  //b比a大一辈
                else if(res==2) rank="grandchild";//b比a大2辈
                else{
                    rank = "grandchild";
                    for(int base = 3; base<=res; base++)
                        rank = "great-"+rank;
                }
                cout<<rank<<endl;
                continue;
            }
            else  //假设a的辈分比b大
                res = search(b,a,0);
            if(res>0){//a的辈分大
                //输出结果
                string rank="";
                if(res==1) rank="parent";
                else if(res==2) rank="grandparent";
                else{
                    rank = "grandparent";
                    for(int base = 3; base<=res; base++)
                        rank = "great-"+rank;
                }
                cout<<rank<<endl;
            }
            //没有直系关系
            else cout<<"-"<<endl;
        }
    }
    return 0;
}
```



### <font color=orange>第一题__</font>

http://t.cn/AiOhkgMJ

并查集的板子题，map真tm好用。

<font color=red>但是我运行的时间和内存都很大，有空找找原因</font>

```
#include <iostream>
#include <cstdio>
#include <map>
using namespace std;

map<int, int> father;
map<int, int> height;

int Find(int x){
    if(father[x]==0){
        father[x] = x;
    }
    else if(father[x]!=x){
        father[x] = Find(father[x]);
    }

    return father[x];
}

void Union(int x, int y){
    x = Find(x);
    y = Find(y);
    if(x!=y){
        if(height[x]<height[y])
            father[x] = y;
        else if(height[y] < height[x])
            father[y] = x;
        else{
            father[y] = x;
            height[x]++;
        }
    }
    return ;
}

int main(){
    int i,j;
    while(cin>>i>>j &&i&&j){
        Union(i,j);
    }
    map<int, int>::iterator it;
    int count = 0;
    for(it=father.begin(); it!=father.end(); it++){
        if(it->first!=0) {
//            cout << it->first << "   " << it->second << endl;
            if (it->first == it->second)
                count++;
        }
    }
    cout<<count<<endl;
    return 0;
}
```





### <font color=red>Head of gangs</font>

头秃，这道题写了两天。

需要注意的地方是： 

1.  系统输入有问题，它输入的是单个字母作为一个人。所以代码里应该用空格划分 
2. 输入的k是帮派总权重的阈值，我一开始理解错了理解成了帮派头目的权重大于k才行。其实应该是帮派总权重大于k 
3. 我一开始是用一个临时头目来存储整个帮派的人数和总权重（所以只有临时头目对应的人数和总权重是真的，其他的都是假的）。然后等输入结束后再把这个头目更新。 

还有，判断key值是否有对应的value，别用初始值检测了，用下面这个：

https://blog.csdn.net/Leo_csdn_/article/details/85066264

```
#include <iostream>
#include <cstdio>
#include <map>
#include <cstring>
#include <algorithm>
using namespace std;

map<string, string> up;  //(个人, 临时头目)
map<string, int>weight;  //(个人, 个人权重)
map<string, int>cluster;  //(个人, 本帮派人数)  仅有临时头目对应的是真实的
map<string, int>clusterweight;  //(临时头目, 帮派权重)
map<string, int>chosen;  //(临时头目, 人数)
map<string, string>newHeader;  //(临时头目, 最终头目)
map<string, int>chosen2;//(最终头目, 人数)



//找到临时头目
string Find(string x){
    if(up.find(x)== up.end())
        up[x]= x;
    if(up[x]!=x){
        up[x] = Find(up[x]);//路径压缩
    }
    return up[x];
}

//这个合并的结果，每个帮派的根可能并不是权重最大的
void Union(string x, string y, int num){
    string fx = Find(x);
    string fy = Find(y);
    if(fx!=fy){  //来自不同的帮派
        if(weight[fx]<weight[fy]){
            up[fx]=fy;  //头目归属
            //帮派人数、总权重合并
            cluster[fy]+=cluster[fx];
            clusterweight[fy]+=clusterweight[fx];
            clusterweight[fy]+=num;
        }
        else{
            up[fy]=fx;
            cluster[fx]+=cluster[fy];
            clusterweight[fx]+=clusterweight[fy];
            clusterweight[fx]+=num;
        }
    }
    else{
        //同一个帮派只要增加总权重
        clusterweight[fx]+=num;
    }
}

int main(){
    int n,k;
    while(cin>>n>>k){
        //初始化
        up.clear();
        weight.clear();
        cluster.clear();
        chosen.clear();
        newHeader.clear();
        chosen2.clear();
        clusterweight.clear();

        getchar();  //结尾的换行符
        string str;
        string x, y, num;
        for(int i=0; i<n;i++){
            getline(cin, str, '\n');
            int pos = str.find(' ');  //第一个空格
            x = str.substr(0,pos);
            int pos2 = str.rfind(' ');  //反向查找第一个空格
            y = str.substr(pos+1, pos2-pos-1);
            num = str.substr(pos2+1);
            weight[x]+=std::stoi(num);  //string 转int
            weight[y]+=std::stoi(num);
            //如果是新来的，先初始化一下cluster
            if(cluster[x]==0) cluster[x]=1;
            if(cluster[y]==0) cluster[y]=1;
            Union(x,y,std::stoi(num));
        }
        map<string, string>::iterator it;
        //把所有的都压缩一遍
        for(it=up.begin(); it!=up.end(); it++){
            Find(it->first);
        }

//        for(it=up.begin(); it!=up.end(); it++) {
//            cout<<it->first<<" "<<it->second<<" "<<weight[it->first]<<" "<<cluster[it->second]<<clusterweight[it->second]<<endl;
//        }

        //到这一步，帮派已经划分完毕，先筛选人数和权重上符合条件的帮派，并把头目放到chosen里
        map<string, int>::iterator it2;
        for(it=up.begin(); it!=up.end(); it++){
            if(it->second == it->first && cluster[it->first] >2 && clusterweight[it->first] >k){//“头目”
                chosen[it->first] = cluster[it->first];
            }
        }

//        for(it2=chosen.begin(); it2!=chosen.end(); it2++){
//            cout<<it2->first<<" "<<it2->second<<" "<<weight[it2->first]<<endl;
//        }

        //更新头目，放到chosen2里
        for(it2=chosen.begin(); it2!=chosen.end(); it2++){
            string tempheader = it2->first;
            int clusternum = it2->second;
            newHeader[tempheader]=tempheader;  //初始化最终头目是临时头目
            //对于所有头目为临时头目的成员，选取个人权重最大的当作最终头目
            for(it=up.begin(); it!=up.end(); it++) {
                if (it->second == tempheader) {
                    if (weight[it->first] > weight[newHeader[tempheader]]) {
                        newHeader[tempheader] = it->first;
                    }
                }
            }
            chosen2.insert(pair<string, int>(newHeader[tempheader], clusternum));
        }

//        map<string, int>::iterator itt;
//        for(itt=chosen2.begin(); itt!=chosen2.end(); itt++){
//            cout<<itt->first<<" "<<itt->second<<endl;
//        }
        //输出
        cout<<chosen2.size()<<endl;
        map<string, int>::iterator itt;
        for(itt=chosen2.begin(); itt!=chosen2.end(); itt++){
            cout<<itt->first<<" "<<itt->second<<endl;
        }
    }
    return 0;
}
```



## 最小生成树

Kruskal算法步骤：

1. 初始时所有顶点属于孤立的集合
2. 按照<font color=red>边权递增顺序</font>遍历所有边，若遍历到的边的两个顶点仍分属不同的集合，则确定该边为最小生成树上的一条边并将该边两个顶点分属的集合合并
3. 遍历完所有边后，若原图连通，则被选取的边和所有顶点构成最小生成树；若原图不连通，最小生成树不存在。



### 还是畅通工程

并查集+Kruskal算法。 

我本来是用map.size()==n来判断是否全部连通的，但是在系统用例n=50那个过不去，而且系统的输入也没给全，不知道为啥。后来改成了cluster计数，每一次不同类的Union都cluster++，因为最后肯定只剩一类，所以只要cluster==n-1即可。

下面是<font color=blue>能过的</font>，用map+Kruskal

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <map>

using namespace std;

map<int, int>father;
struct edge{
    int v1;
    int v2;
    int distance;
};

int minLength = 0;  //结果
int cluster = 0;  //当前集群数目

int Find(int a){
    if(father.find(a)==father.end()){
        father[a] = a;
    }
    if(father[a]!=a){
        father[a] = Find(father[a]);
    }
    return father[a];
}

void Union(int a, int b, int num){
    a = Find(a);
    b = Find(b);

    if(a!=b){
        father[b] = a;
        minLength+=num;
        cluster++;
    }
}

bool cmp(edge a, edge b){
    return a.distance<b.distance;//根据distance升序
}

int main(){
    int n,m;
    while(cin>>n&&n){
        getchar();
        m = n*(n-1)/2;  //输入数
        father.clear();
        edge e[4550];

        minLength=0; //最小长度
        cluster = 0;
        for(int i=0; i<m; i++){
            cin>>e[i].v1>>e[i].v2>>e[i].distance;
        }
        sort(e, e+m, cmp);
        for(int i=0; i<m; i++){
            if(cluster==n-1)
                break;
            Union(e[i].v1, e[i].v2, e[i].distance);
        }
        cout<<minLength<<endl;
    }
    return 0;
}
```

下面是<font color=red>过不了的</font>：

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <map>

using namespace std;

map<int, int>visit;
struct edge{
    int v1;
    int v2;
    int distance;
};

bool cmp(edge a, edge b){
    return a.distance<b.distance;//根据distance升序
}

int main(){
    int n,m;
    while(cin>>n&&n){
        getchar();
        m = n*(n-1)/2;  //输入数
        visit.clear();
        edge e[4550];

        int minLength=0; //最小长度
        for(int i=0; i<m; i++){
            cin>>e[i].v1;
            cin>>e[i].v2;
            cin>>e[i].distance;
        }
        sort(e, e+m, cmp);
        int v1, v2, distance;
        for(int i=0; i<m; i++){
            if(visit.size()==n)
                break;
            v1 = e[i].v1;
            v2 = e[i].v2;
            distance = e[i].distance;
            if(visit[v1]!=1){
                visit[v1]=1;
                minLength+=distance;
                if(visit[v2]!=1){
                    visit[v2]=1;
                }
                continue;
            }
            else if(visit[v2]!=1){
                visit[v2]=1;
                minLength+=distance;
            }
        }
        cout<<minLength<<endl;
    }
    return 0;
}
```



### Freckles

http://t.cn/AiW3Hbqr

不难，练手。先计算每个结点间的距离，再kruskal。

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <map>
#include <cmath>
using namespace std;

map<int, int>father;
double cost;  //总代价
int cluster; //当前集群大小

struct Edge{
    int v1;
    int v2;
    double len;
};

struct Node{
    double x;
    double y;
};


int Find(int x){
    if(father.find(x)==father.end()){
        father[x]=x;
    }
    if(father[x]!=x){
        father[x]=Find(father[x]);
    }
    return father[x];
}

void Union(int x, int y, double len){
    x = Find(x);
    y = Find(y);
    if(x!=y){
        father[y] = x;
        cost+= len;
        cluster++;
    }
}

bool cmp(Edge x, Edge y){
    return x.len<y.len;
}

int main(){
    int n;
    while(cin>>n && n){
        cost = 0;
        cluster = 1;
        father.clear();
        Node node[101];
        Edge e[4551];
        //输入所有结点
        for(int i=0; i<n; i++){
            cin>>node[i].x>>node[i].y;
        }
        int k=0;
        //计算每个结点间的距离，放在边中
        for(int i=0; i<n; i++){
            for(int j=i+1; j<n; j++){
                e[k].v1 = i;
                e[k].v2 = j;
                double xdis = (node[i].x-node[j].x)*(node[i].x-node[j].x);
                double ydis = (node[i].y-node[j].y)*(node[i].y-node[j].y);
                e[k].len = sqrt(xdis+ydis);
                k++;
            }
        }
        //排序
        sort(e, e+k, cmp);
        for(int i=0; i<k; i++){
            if(cluster==n)
                break;
            Union(e[i].v1, e[i].v2, e[i].len);
        }
        //保留两位小数
        printf("%.2f\n",cost);
    }
    return 0;

}
```



## 最短路径

### <font color=red>畅通工程续</font>

**可以当作板子。**

https://vjudge.net/problem/HDU-1874

对书上的代码<font color=red>改进了一下</font>

设置了visit，松弛的时候，**如果末端结点在始端之前加入集合，那这条边不用松弛**。（即dis[v] > dis[u]+d一定不成立）

（事实证明我加了个visit是多余的，但是我觉得这样好理解）

```
#include <iostream>
#include <cstdio>
#include <vector>
#include <cstring>
#include <queue>
#include <climits>
#include <algorithm>
#include <map>
using namespace std;

const int MAXN = 200;
const int INF  = INT_MAX;

map<int, int> visit;

struct Edge{
    int to;  //终点
    int length;  //长度
    Edge(int t, int l ): to(t), length(l){}
};

struct Point{
    int number; //当前结点编号
    int distance;  //源点到该点的距离
    Point(int n, int d): number(n), distance(d){}
    bool operator< (const Point& p) const{
        return distance > p.distance;  //距离小的优先级高
    }
};

vector<Edge> graph[MAXN];  //每个结点维护一个元素类型为Edge的vector向量，用于存放与该点相连的边
int dis[MAXN];  //源点到各点的距离

void Dijkstra(int s){
    priority_queue<Point> pq;  //优先队列，元素类型为Point，运算符已重载，距离小的结点优先级高
    dis[s]=0; //源点到自己的距离为0
    pq.push(Point(s, dis[s]));  //先把自己放进去
    while(!pq.empty()){
        Point temp = pq.top();
        pq.pop();
        int u = temp.number;
        if(visit.find(u)!=visit.end())  // 如果已经在集合里，则跳过
            continue;
        visit[u]=1;
        dis[u] = temp.distance;

        for(int i=0; i<graph[u].size(); i++){
            int v = graph[u][i].to;
            int d = graph[u][i].length;
            if(dis[v] > dis[u]+d){  //如果dis(s,v) < dis(s,u) + dis(u,v)
                dis[v] = dis[u] + d;
                pq.push(Point(v, dis[v]));  //把结点v放进去
            }
        }
    }
}


int main(){
    int n, m;
    while(cin>>n>>m && n && m){
        visit.clear();
        memset(graph, 0, sizeof(graph)); //初始化所有临接表
        fill(dis, dis+n, INF);
        while(m--){
            int from, to, length;
            cin>>from>>to>>length;
            graph[from].push_back(Edge(to, length));
            graph[to].push_back(Edge(from, length));
        }
        int s, t;
        cin>>s>>t;
        Dijkstra(s);
        if(dis[t]==INF){
            dis[t]=-1;
        }
        cout<<dis[t]<<endl;
    }
    return 0;
}
```



### <font color=blue>最短路径问题</font>

http://t.cn/AilPbME2

Dijkstra算法。上面“畅通工程（续）”的拓展版。 	


畅通工程（续）只考虑最短路径，所以用Dijksra+优先队列，每次取最近的结点加入集合，并松弛每条边。 	

本题引入了代价（花费），但问题不大，只要再开个cost数组就行。 	

需要注意的是，两个结点可能有多条边相连，所以对每条边的信息用结构体存储是比较合适的。

```
#include <iostream>
#include <map>
#include <cstdio>
#include <queue>
#include <algorithm>
#include <vector>
#include <climits>
#include <cstring>
using namespace std;

const int MAXN = 1001;
const int INF = INT_MAX;

map<int, int>visit;  //visit
struct Edge{
    int to;  //目的点
    int length; //长度
    int price; //花费
    Edge(int t, int l, int p): to(t), length(l), price(p) {}
};

struct Point{
    int number; //点的编号
    int distance; //距离源点的总距离
    int pay;  //源点到此点的总代价
    Point(int n, int d, int p): number(n), distance(d), pay(p){}
    //距离小的优先，距离一样则花费小的优先
    bool operator< (const Point& p) const{
        if (distance != p.distance)
            return distance > p.distance;  //距离小的优先级高
        else{
            return pay > p.pay; //距离一样的，花费小的优先
        }
    }
};


vector<Edge>graph[MAXN];
int dis[MAXN];//到源点距离
int cost[MAXN];//到源点代价

void Dijkstra(int s){
    priority_queue<Point> pq;  //优先队列
    dis[s]=0; cost[s]=0;
    pq.push(Point(s, dis[s], cost[s]));
    while(!pq.empty()){
        Point temp = pq.top();
        pq.pop();
        int u = temp.number;
        if(visit.find(u)!=visit.end()){  //如果被访问过（已被加入集合），直接跳过
            continue;
        }
        visit[u]=1;
        dis[u]=temp.distance;
        cost[u]= temp.pay;
//        cout<<u<<" ########## "<<dis[u]<<" "<<cost[u]<<endl;
        //松弛当前结点所连接的所有边
        for(int i=0; i<graph[u].size(); i++){
            int v = graph[u][i].to;
            int d = graph[u][i].length;
            int p = graph[u][i].price;
//            cout<<"("<<u<<","<<v<<")"<<" "<<d<<" "<<p<<" disV: "<<dis[v]<<" dis[u]+d: " <<dis[u]+d<<endl;
            if(dis[v]>dis[u]+d){//有更短的路
                dis[v] = dis[u]+d;
                cost[v] = cost[u]+p;  //这里别忘了更新
                pq.push(Point(v, dis[v], cost[v]));
            }
            else if(dis[v]==dis[u]+d && cost[v] > cost[u]+p){//长度相同但代价更小
                cost[v] = cost[u]+p;
                pq.push(Point(v, dis[v], cost[v]));
            }
        }
    }
}

int main(){
    int n,m;
    while(cin>>n>>m && n &&m){
        visit.clear();
        memset(graph, 0, sizeof(graph)); //初始化所有临接表
        fill(dis, dis+MAXN, INF);//初始化到所有点距离为INF
        fill(cost, cost+MAXN, INF);//初始化到所有点代价为INF
        int a,b,d,p; //点a，点b，长度d，花费p
        int s,t; //起点，终点
        for(int i=0; i<m; i++){
            cin>>a>>b>>d>>p;
            graph[a].push_back(Edge(b,d,p));
            graph[b].push_back(Edge(a,d,p));
        }
        cin>>s>>t;
        Dijkstra(s);
        if(dis[t]==INF){
            dis[t]=-1;
            cost[t]=-1;
        }
        cout<<dis[t]<<" "<<cost[t]<<endl;
    }
    return 0;
}
```



### <font color=red>最短路径</font>

http://t.cn/AilPKHTx

<font color=red>评论区说还有用最小生成树的方法，有时间去看看</font>

这道题数字太大了，一般的快速幂也不行。只能用字符串快速幂。

评论区的代码加了点注释。

这道题的特殊数据值，字符串加法很有亮点。

```
#include<iostream>
#include<algorithm>
#include<queue>
#include<cstring>
#include<vector>
using namespace std;
const int MAXN = 300;
struct Edge{
    int to;
    string  length;
    Edge(int t, string l): to(t), length(l) {}
    bool operator < (Edge c) const{
        return length < c.length;
    }
};

struct Point{
    int number;
    string distance;
    Point(int n, string d) : number(n), distance(d) {}
    bool operator<(Point c)const{
        return distance > c.distance;
    }
};

string dis[MAXN];       //源点到其他点的距离
int cost[MAXN];
vector<Edge> graph[MAXN];
priority_queue<Point> pq;     //用于筛选最短距离的点

//二进制表示2^u
string chart(int u){
    string s;
    s.insert(0, 502, '0');//这里使用固定长度，则接下来运算的时候就不用再对齐了
    s[s.size()-1-u] = '1';
    return s;
}


string adds(string a, string b){ //字符串加法
    string s;
    for (int i = 0; i < a.size(); i++)
        //因为每条路用二进制表示只有1位是1，且各路都不相同，所以只要不是往返走一条路，就不会出现某位>=1的情况
        //而我们知道，不可能存在往返
        s.append(1, (a[i] - '0' + b[i] - '0')+'0');
    return s;
}

int atois(string s){   //快速幂取模
    int ans=0;
    int front = 1;
//    cout<<s<<endl;
    for (int i = s.size()-1; i>=0; i--){
        if (s[i] == '1'){
            ans += front;
            ans = ans % 100000;
        }
        front = (front * 2) % 100000;
    }
    return ans;
}


void Dijkstra(int start){     //最短路径
    dis[start][0] = '0';
    pq.push(Point(start,dis[start]));
    while (!pq.empty()){
        int u = pq.top().number;
        pq.pop();
        
        for (int i =0 ; i < graph[u].size(); i++){
            int v = graph[u][i].to;
            string newLength = adds(dis[u], graph[u][i].length);

            if (dis[v] > newLength ){
//                cout<<newLength<<endl;
                dis[v] = newLength;
                pq.push(Point(graph[u][i].to, dis[graph[u][i].to]));
            }
        }
    }
}

void Initial(){
    for(int i = 0; i < MAXN; i++)
        dis[i] = chart(501);  // 1000...000
    dis[0][0] = '0';
}

int main(){
    int n, m;
    int a, b;
    while (cin>>n>>m){
        Initial();
        for (int i = 0; i < m; i++){
            cin>>a>>b;
            graph[a].push_back(Edge(b,chart(i)));
            graph[b].push_back(Edge(a,chart(i)));
        }
        Dijkstra(0);
        for (int i = 1; i < n; i++){
            if (dis[i] == chart(501))
                cout << "-1" << endl;
            else
                cout << atois(dis[i])<<endl;
        }
    }
}
```



### I Wanna Go Home

先使用Dijkstra计算相同阵营的城市间的最短路径（源点分别是1，2），结果分别在数组t1[], t2[]中

然后G[i][j]在此前已经输入，这里令i全为阵营1里的城市，j全为阵营2里的城市

则需要求的是 t1[i] + G[i][j] + t2[j]的最小值

```
#include <iostream>
#include <cstdio>
#include <vector>
#include <cstring>
#include <queue>
#include <climits>
#include <algorithm>
#include <map>
using namespace std;

const int MAXN = 601;
const int INF  = INT_MAX;

map<int, int> visit;
map<int, int> side1;
map<int, int> side2;
int camp[MAXN]; //阵营，取值为1或2
int G[MAXN][MAXN];  //代价图，G[i][j]表示城市i到城市j的时间代价
int t1[MAXN];  //城市1到同阵营的最短时间
int t2[MAXN];  //城市2到同阵营的最短时间
int n, m;
int minTime;  //最小时间


struct Point{
    int number;  //节点编号
    int dis;  // 到源点的距离（时间）
    Point(int n, int d): number(n), dis(d){}
    bool operator< (const Point& p) const{
        return dis > p.dis;
    }
};

void Dijkstra(int t[], int side){ //计算阵营为side的最短时间
    priority_queue<Point> pq;  //优先队列
    t[side] = 0;
    pq.push(Point(side, t[side]));  //源点入队
    while(!pq.empty()){
        Point temp = pq.top();
        pq.pop();
        //其实可以取消visit，因为先加入集合的点不会被后面的点松弛
        if(visit[temp.number])
            continue;
        int u = temp.number;
        t[u] = temp.dis;
        visit[u] =1;
        for(int i=1; i<=n ;i++){
            if(G[u][i]!=INT_MAX && camp[i]==side){//如果有路并且是同一阵营
                int roadTime = G[u][i];
                if(t[i] > t[u]+roadTime){
                    t[i] = t[u]+roadTime;
                    pq.push(Point(i,t[i]));
                }
            }
        }
    }
}

int main(){
    while(cin>>n>>m && n && m){
        //初始化各参数
        minTime = INT_MAX;
        memset(camp, 0, sizeof(camp));//初始化阵营全为0
        visit.clear();
        side1.clear();
        side2.clear();
        fill(t1, t1+MAXN, INT_MAX);
        fill(t2, t2+MAXN, INT_MAX);
        //初始化代价图
        for(int i=0; i<MAXN; i++){
            for(int j=0; j<MAXN; j++){
                if(i==j)
                    G[i][j]=0;
                else
                    G[i][j]=INT_MAX;
            }
        }
        //输入数据
        for(int i=0; i<m;i++){
            int v1, v2, roadTime;
            cin>>v1>>v2>>roadTime;
            if(roadTime<G[v1][v2]){
                G[v1][v2] = roadTime;
                G[v2][v1] = roadTime;
            }
        }
        //站队
        for(int i=1; i<=n; i++){
            cin>>camp[i];
            if(camp[i]==1)
                side1[i]=1;
            else side2[i]=1;
        }
        //计算1和2到其阵营的最短路径
        Dijkstra(t1, 1);
        Dijkstra(t2, 2);

        //找出最小的 t1[i] + G[i][j] + t2[j]
        map<int, int>::iterator it1;
        map<int, int>::iterator it2;
        for(it1=side1.begin(); it1!=side1.end(); it1++){
            if(t1[it1->first]==INT_MAX)
                continue;
            for(it2=side2.begin(); it2!=side2.end(); it2++){
                if(t2[it2->first]==INT_MAX)
                    continue;
                if(G[it1->first][it2->first]!=INT_MAX){
                    int curTime = t1[it1->first]+ G[it1->first][it2->first]+t2[it2->first];
                    if(minTime> curTime)
                        minTime = curTime;
                }
            }
        }
        if(minTime == INT_MAX)
            minTime = -1;
        cout<<minTime<<endl;
    }
    return 0;
}
```



## 拓扑排序

## 关键路径



# 动态规划

## 递推求解

### N阶楼梯上楼问题

 http://t.cn/Aij9Fr3V 

斐波那契水题，但是评论区好像有非斐波那契解法。

```
#include <iostream>
#include <cstdio>
using namespace std;

const int MAXN= 91;
long long dp[MAXN];
int main(){
    dp[0]=1;
    dp[1]=1;
    for(int i=2; i<MAXN; i++){
        dp[i] = dp[i-1] + dp[i-2];
    }
    int n;
    while(cin>>n && n){
        cout<<dp[n]<<endl;
    }
    return 0;
}
```

​	

## 最大连续子序列和

### 最大序列和

 http://t.cn/AiYSlQMU 

状态转移方程 
$$
dp[i] = \max(A[i], dp[i-1]+A[i])
$$

```
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <cstring>
using namespace std;
const int MAXN = 1000001;

long long arr[MAXN];
long long dp[MAXN];
int n;

long long maxSubsequence(){
    long long maxSum = arr[0];
    for(int i=0; i<n; i++){
        if(i==0)
            dp[i]=arr[0];
        else{
            dp[i] = max(arr[i], dp[i-1]+arr[i]);
        }
        maxSum = max(maxSum, dp[i]);
    }
    return maxSum;
}

int main(){
    while(cin>>n){
        memset(arr, 0, sizeof(arr));
        memset(dp, 0, sizeof(dp));
        for(int i=0; i<n; i++){
            cin>>arr[i];
        }
        long long answer = maxSubsequence();
        cout<<answer<<endl;
    }
    return 0;
}
```

### 最大子矩阵

https://www.nowcoder.com/questionTerminal/a5a0b05f0505406ca837a3a76a5419b3 

假设原二维矩阵中最大子矩阵所在的行是从i到j，那么只会出现下面这两种情况：

1. 当 i == j 时，求最大子矩阵和就转换成了求第i行元素的最大连续子序列和
2. 当 i != j 时，把从第i行到第j行的所有行的元素加起来，得到只有一行的一维数组，这个一维数组的最大连续子序列和便是最大子矩阵和。

只需要从小到大枚举并依次遍历i和j，接着输出所有子矩阵中的最大值。

事先用一个辅助二维矩阵记录原始矩阵从上到下加起来的累加矩阵，在求第i行到第j行的一维数组只需要相减就行。

```
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <climits>
using namespace std;
const int MAXN = 100;
 
int arr[MAXN][MAXN];    //数据
int sum[MAXN][MAXN];  //前n行的和
int temp[MAXN];
int dp[MAXN];
 
//最大连续子串序列和
int MaxSubSequence(int n){
    int maxSum = INT_MIN;
    for(int i=0; i<n; i++){
        if(i==0){
            dp[i] = temp[i];
        }
        else{
            dp[i] = max(temp[i], dp[i-1]+ temp[i]);
        }
        maxSum = max(maxSum, dp[i]);
    }
    return maxSum;
}
 
//最大子矩阵
int MaxSubMatrix(int n){
    int maxSum = INT_MIN;
    for(int i=0; i<n; i++){
        for(int j=i; j<n; j++){
            if(j==i){
                for(int k=0; k<n; k++){
                    temp[k] = arr[i][k];
                }
            }
            else{
                for(int k=0; k<n; k++){
                    temp[k] = sum[j][k] - sum[i-1][k];
                }
            }
            maxSum = max(maxSum, MaxSubSequence(n));
        }
    }
    return maxSum;
}
 
int main(int argc, char** argv) {
    int n;
    while(cin>>n){
        memset(arr, 0, sizeof(arr));
        memset(sum, 0, sizeof(sum));
        memset(temp, 0, sizeof(temp));
        memset(dp, 0, sizeof(dp));
        int result = 0;
        for(int i=0; i<n; i++){
            for(int j=0; j<n; j++){
                cin>>arr[i][j];
                if(i==0){
                    sum[i][j] =  arr[i][j];
                }
                else{
                    sum[i][j] = sum[i-1][j] + arr[i][j];
                }
            }
        }
        result = MaxSubMatrix(n);
        cout<<result<<endl;
    }
     
    return 0;
}

```



### 最大连续子序列

http://t.cn/AiYoUkjP 

把以前的int dp[]换成结构体类型的数组。

结构体的参数为 当前值num，首字符下标firstI，末尾字符下标lastI

在计算当前和的时候根据不同情况选择放弃前面的和或是借用前面的和。

等dp计算完了，再求最大的dp[i].num，赋值给最大和，此时的dp[i].firstI和dp[i].lastI就是对应的下标。

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <climits>
#include <cstring>
using namespace std;

const int MAXN = 10000;
struct node{
    int num;  //数值
    int firstI;  //首字符下标
    int lastI;  //末尾下标
};

int n;
int arr[MAXN];
node dp[MAXN];
int firstIndex;  //最终首字符下标
int lastIndex;  //最终末尾下标

int MaxSubSequence(){
    int maxSum = INT_MIN;
    for(int i=0; i<n; i++){
        //初始化
        if(i==0){
            dp[i].num = arr[i];
            dp[i].firstI = i;
            dp[i].lastI = i;
        }
        else{
            //计算dp
            int tempSum = dp[i-1].num + arr[i];
            if(arr[i]> tempSum){//放弃前面的和
                //将firstI和lastI 都赋值成自己下标
                dp[i].num = arr[i];
                dp[i].firstI = i;
                dp[i].lastI = i;
            }
            else{ //继承前面的firstI，并将lastI更新成自己的下标
                dp[i].num = tempSum;
                dp[i].firstI = dp[i-1].firstI;
                dp[i].lastI = i;
            }
        }
    }
    //找出最大的和，并对全局变量firstIndex和lastIndex赋值
    for(int i=0; i<n; i++){
        if(maxSum < dp[i].num){
            firstIndex = dp[i].firstI;
            lastIndex = dp[i].lastI;
            maxSum = dp[i].num;
        }
    }
    return maxSum;
}

int main(){
    while(cin>>n && n){
        int maxSum;
        int neg = 0;  //负数数量
        memset(arr, 0, sizeof(arr));
        for(int i=0; i<n; i++){
            cin>>arr[i];
            if(arr[i]<0)
                neg++;
        }
        if(neg == n){  //如果全为负数
            maxSum = 0;
            firstIndex = 0;
            lastIndex = n-1;
        }
        else
            maxSum = MaxSubSequence();
        cout<<maxSum<<" "<<arr[firstIndex]<<" "<<arr[lastIndex]<<endl;
    }
    return 0;
}
```



## 最长递增子序列(LIS)

问题描述的是在一个已知序列$\{A_1, A_2, ···, A_n\}$中，取出若干元素（不必连续）组成一个新的序列$\{A_x, ···, A_y\}$，新序列中的各个数之间依旧保持原序列中的先后顺序。 

若对该子序列中的任意下标$x<y$有$A_x < A_y$，则称该子序列为原序列的一个递增子序列。最长递增子序列问题就是求给定序列的所有递增子序列中最长的那个子序列长度。



首先设置一个数组dp[]，令dp[i]表示以A[i]作为末尾的最长递增子序列的长度。则只有以下两种情况

- A[i]之前的元素都比A[i]大，即最长递增子序列只有A[i]本身，即dp[i] = 1
- A[i]之前的元素A[j]比A[i]小，此时只需将A[i]添加到以A[j]作为末尾的递增子序列，便能构成一个新的递增子序列。dp[i] = dp[j] +1。 **于是将i之前的元素逐一遍历，便可以获得以A[i]作为末尾的最长递增子序列的长度dp[i]**

从这两种情况可以得到状态转移方程
$$
dp[i] = \max \{1, dp[j]+1 \quad | \quad j<i \quad \text{&&} \quad A_j < A_i \}
$$
**dp记得初始化为1**



### 最大上升子序列和

http://t.cn/AiYNAGD3

不同于最长递增子序列，但差不多。 水题。这里dp应初始化自身数据。

```
#include <iostream>
#include <cstdio>
#include <cstring>
#include <cmath>
#include <algorithm>

using namespace std;
const int MAXN = 1001;
int num[MAXN];
int dp[MAXN];

int main(){
    int n;
    while(cin>>n && n ){
        memset(num, 0, sizeof(num));
        int maxnum = 0;
        
        for(int i=0; i<n; i++){
            cin>>num[i];
            dp[i] = num[i];  //这里应该是初始化为自己，我之前没注意直接初始化为0了
        }
        for(int i=0; i<n; i++){
            for(int j=0; j<i; j++){
                if(num[j]<num[i])
                    dp[i] = max(dp[i], dp[j]+num[i]);
            }
            if(maxnum<dp[i])
                maxnum = dp[i];
        }
        cout<<maxnum<<endl;
    }
    return 0;
}
```



## 最长公共子序列

设字符串S1长度为n，S2长度为m。

首先设置一个二维数组dp\[][]，令dp\[i][j]表示以S1\[i]作为末尾和以S2\[j]作为末尾的最长公共子序列的长度，则最后需要求的是dp\[n][m]。

dp\[i][j]表示以S1\[i]作为末尾和以S2\[j]作为末尾的最长公共子序列的长度，根据S1\[i]和S2\[j]的关系可分为两种情况：

- S1\[i] = S2\[j]，此时必定存在一个最长公共子串以S1\[i] 和 S2\[j]结尾，其他部分等价于S1中前i-1个字符和S2中前j-1个字符的最长公共子串，于是这个子串长度比dp\[i-1][j-1]多1，即dp\[i][j] = dp\[i-1][j-1]+1
- S1\[i] != S2\[j]，此时最长公共子串长度为S1中前i-1个字符和S2中前j个字符的LCS长度与S1中前i个字符和S2中前j-1个字符的LCS长度的较大者，即在两种情况下得到的LCS都不会因为其中有一个字符串又增加了一个字符长度而发生改变， 也就是dp\[i][j] = max\{dp\[i-1][j], dp\[i][j-1]}

从这两种情况可以得到状态转移方程：
$$
dp[i][j] =
\begin{cases}
 dp[i-1][j-1]+1\quad \quad\quad\quad\quad\quad\quad  S1[i] = S2[j]\\
	\max \{dp[i-1][j], dp[i][j-1]\} \quad \quad \quad S1[i]!=S2[j]
\end{cases}
$$
而对于边界情况，如果两个字符串中的其中一个为空串，那么公共字符串的长度必定为0，于是可以轻松地得到：
$$
dp[i][0] = 0 \quad (0<=i<=n)\\
dp[0][j] = 0 \quad (0<=j<=m)
$$

**需要注意的是，字符串最好从下标1而非0开始输入，因为这样处理有利于边界情况的分析和初始化。**

### Coincidence

http://t.cn/AiY03RO5

```
#include <iostream>
#include <cstring>
#include <cstdio>
#include <cmath>
#include <algorithm>
using namespace std;

string s1;
string s2;
int dp[101][101];

int main(){
    while(cin>>s1>>s2){
        int m = s1.length();
        int n = s2.length();
        s1 = ' '+s1;
        s2 = ' '+s2;
        for(int i=0; i<=m; i++){
            for(int j=0; j<=n; j++){
                if(i==0 || j==0){
                    dp[i][j]=0;
                    continue;
                }
                if(s1[i]==s2[j]){
                    dp[i][j] = dp[i-1][j-1]+1;
                }
                else{
                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
                }
            }
        }
        cout<<dp[m][n]<<endl;
    }
    return 0;
}

```



## 背包问题

**<font color=gold>0-1背包</font>**

令dp\[i][j]表示当前i个物品装进容量为j的背包能获得的最大价值。 则dp\[m][n]的值就是0-1背包问题的解。
只考虑第i件物品时，可将情况分为是否放入第i件物品两种：

- 对于容量为j的背包，如果不放入第i件物品，那么这个问题就转换成将前i-1个物品放入容量为j的背包的问题，即dp\[i][j] = dp\[i-1][j]
- 对于容量为j的背包，如果放入第i件物品，那么当前背包的容量就变成了j-w\[i]，并得到这个物品的价值v\[i]。之后这个问题就转化成将前i-1个物品放入容量为j-w\[i]的背包的问题，即dp\[i][j] = dp\[i-1][j-w\[i]] + v\[i]

而从这两种情况可以得到状态转移方程：
$$
dp[i][j] = \max (dp[i-1][j], dp[i-1][j-w[i]]+v[i])
$$
转移时要注意j-w\[i]的值是否为非负值，若为负则代表背包当前容量无法放入第i件物品，不能进行转移。

对于边界情况：
$$
dp[i][0] = 0 \quad (0<=i<=n)\\
dp[0][j] = 0 \quad (0<=j<=m)
$$





## 其他问题